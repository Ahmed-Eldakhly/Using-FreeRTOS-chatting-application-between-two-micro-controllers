
FreeRTOS_SprintsChallenges_FinalProject.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005ffa  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000086  00800060  00005ffa  0000608e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000657  008000e6  008000e6  00006114  2**0
                  ALLOC
  3 .stab         0000a0ec  00000000  00000000  00006114  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004fef  00000000  00000000  00010200  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 d4 13 	jmp	0x27a8	; 0x27a8 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea ef       	ldi	r30, 0xFA	; 250
      68:	ff e5       	ldi	r31, 0x5F	; 95
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a6 3e       	cpi	r26, 0xE6	; 230
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a6 ee       	ldi	r26, 0xE6	; 230
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ad 33       	cpi	r26, 0x3D	; 61
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 e6 10 	call	0x21cc	; 0x21cc <main>
      8a:	0c 94 fb 2f 	jmp	0x5ff6	; 0x5ff6 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_WritePin>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <DIO_WritePin+0x6>
      98:	cd b7       	in	r28, 0x3d	; 61
      9a:	de b7       	in	r29, 0x3e	; 62
      9c:	89 83       	std	Y+1, r24	; 0x01
      9e:	6a 83       	std	Y+2, r22	; 0x02
      a0:	8a 81       	ldd	r24, Y+2	; 0x02
      a2:	81 30       	cpi	r24, 0x01	; 1
      a4:	09 f0       	breq	.+2      	; 0xa8 <DIO_WritePin+0x16>
      a6:	6d c0       	rjmp	.+218    	; 0x182 <DIO_WritePin+0xf0>
      a8:	89 81       	ldd	r24, Y+1	; 0x01
      aa:	88 30       	cpi	r24, 0x08	; 8
      ac:	a0 f4       	brcc	.+40     	; 0xd6 <DIO_WritePin+0x44>
      ae:	ab e3       	ldi	r26, 0x3B	; 59
      b0:	b0 e0       	ldi	r27, 0x00	; 0
      b2:	eb e3       	ldi	r30, 0x3B	; 59
      b4:	f0 e0       	ldi	r31, 0x00	; 0
      b6:	80 81       	ld	r24, Z
      b8:	48 2f       	mov	r20, r24
      ba:	89 81       	ldd	r24, Y+1	; 0x01
      bc:	28 2f       	mov	r18, r24
      be:	30 e0       	ldi	r19, 0x00	; 0
      c0:	81 e0       	ldi	r24, 0x01	; 1
      c2:	90 e0       	ldi	r25, 0x00	; 0
      c4:	02 2e       	mov	r0, r18
      c6:	02 c0       	rjmp	.+4      	; 0xcc <DIO_WritePin+0x3a>
      c8:	88 0f       	add	r24, r24
      ca:	99 1f       	adc	r25, r25
      cc:	0a 94       	dec	r0
      ce:	e2 f7       	brpl	.-8      	; 0xc8 <DIO_WritePin+0x36>
      d0:	84 2b       	or	r24, r20
      d2:	8c 93       	st	X, r24
      d4:	c8 c0       	rjmp	.+400    	; 0x266 <DIO_WritePin+0x1d4>
      d6:	89 81       	ldd	r24, Y+1	; 0x01
      d8:	88 30       	cpi	r24, 0x08	; 8
      da:	c8 f0       	brcs	.+50     	; 0x10e <DIO_WritePin+0x7c>
      dc:	89 81       	ldd	r24, Y+1	; 0x01
      de:	80 31       	cpi	r24, 0x10	; 16
      e0:	b0 f4       	brcc	.+44     	; 0x10e <DIO_WritePin+0x7c>
      e2:	a8 e3       	ldi	r26, 0x38	; 56
      e4:	b0 e0       	ldi	r27, 0x00	; 0
      e6:	e8 e3       	ldi	r30, 0x38	; 56
      e8:	f0 e0       	ldi	r31, 0x00	; 0
      ea:	80 81       	ld	r24, Z
      ec:	48 2f       	mov	r20, r24
      ee:	89 81       	ldd	r24, Y+1	; 0x01
      f0:	88 2f       	mov	r24, r24
      f2:	90 e0       	ldi	r25, 0x00	; 0
      f4:	08 97       	sbiw	r24, 0x08	; 8
      f6:	9c 01       	movw	r18, r24
      f8:	81 e0       	ldi	r24, 0x01	; 1
      fa:	90 e0       	ldi	r25, 0x00	; 0
      fc:	02 2e       	mov	r0, r18
      fe:	02 c0       	rjmp	.+4      	; 0x104 <DIO_WritePin+0x72>
     100:	88 0f       	add	r24, r24
     102:	99 1f       	adc	r25, r25
     104:	0a 94       	dec	r0
     106:	e2 f7       	brpl	.-8      	; 0x100 <DIO_WritePin+0x6e>
     108:	84 2b       	or	r24, r20
     10a:	8c 93       	st	X, r24
     10c:	ac c0       	rjmp	.+344    	; 0x266 <DIO_WritePin+0x1d4>
     10e:	89 81       	ldd	r24, Y+1	; 0x01
     110:	80 31       	cpi	r24, 0x10	; 16
     112:	c8 f0       	brcs	.+50     	; 0x146 <DIO_WritePin+0xb4>
     114:	89 81       	ldd	r24, Y+1	; 0x01
     116:	88 31       	cpi	r24, 0x18	; 24
     118:	b0 f4       	brcc	.+44     	; 0x146 <DIO_WritePin+0xb4>
     11a:	a5 e3       	ldi	r26, 0x35	; 53
     11c:	b0 e0       	ldi	r27, 0x00	; 0
     11e:	e5 e3       	ldi	r30, 0x35	; 53
     120:	f0 e0       	ldi	r31, 0x00	; 0
     122:	80 81       	ld	r24, Z
     124:	48 2f       	mov	r20, r24
     126:	89 81       	ldd	r24, Y+1	; 0x01
     128:	88 2f       	mov	r24, r24
     12a:	90 e0       	ldi	r25, 0x00	; 0
     12c:	40 97       	sbiw	r24, 0x10	; 16
     12e:	9c 01       	movw	r18, r24
     130:	81 e0       	ldi	r24, 0x01	; 1
     132:	90 e0       	ldi	r25, 0x00	; 0
     134:	02 2e       	mov	r0, r18
     136:	02 c0       	rjmp	.+4      	; 0x13c <DIO_WritePin+0xaa>
     138:	88 0f       	add	r24, r24
     13a:	99 1f       	adc	r25, r25
     13c:	0a 94       	dec	r0
     13e:	e2 f7       	brpl	.-8      	; 0x138 <DIO_WritePin+0xa6>
     140:	84 2b       	or	r24, r20
     142:	8c 93       	st	X, r24
     144:	90 c0       	rjmp	.+288    	; 0x266 <DIO_WritePin+0x1d4>
     146:	89 81       	ldd	r24, Y+1	; 0x01
     148:	88 31       	cpi	r24, 0x18	; 24
     14a:	08 f4       	brcc	.+2      	; 0x14e <DIO_WritePin+0xbc>
     14c:	8c c0       	rjmp	.+280    	; 0x266 <DIO_WritePin+0x1d4>
     14e:	89 81       	ldd	r24, Y+1	; 0x01
     150:	80 32       	cpi	r24, 0x20	; 32
     152:	08 f0       	brcs	.+2      	; 0x156 <DIO_WritePin+0xc4>
     154:	88 c0       	rjmp	.+272    	; 0x266 <DIO_WritePin+0x1d4>
     156:	a2 e3       	ldi	r26, 0x32	; 50
     158:	b0 e0       	ldi	r27, 0x00	; 0
     15a:	e2 e3       	ldi	r30, 0x32	; 50
     15c:	f0 e0       	ldi	r31, 0x00	; 0
     15e:	80 81       	ld	r24, Z
     160:	48 2f       	mov	r20, r24
     162:	89 81       	ldd	r24, Y+1	; 0x01
     164:	88 2f       	mov	r24, r24
     166:	90 e0       	ldi	r25, 0x00	; 0
     168:	48 97       	sbiw	r24, 0x18	; 24
     16a:	9c 01       	movw	r18, r24
     16c:	81 e0       	ldi	r24, 0x01	; 1
     16e:	90 e0       	ldi	r25, 0x00	; 0
     170:	02 2e       	mov	r0, r18
     172:	02 c0       	rjmp	.+4      	; 0x178 <DIO_WritePin+0xe6>
     174:	88 0f       	add	r24, r24
     176:	99 1f       	adc	r25, r25
     178:	0a 94       	dec	r0
     17a:	e2 f7       	brpl	.-8      	; 0x174 <DIO_WritePin+0xe2>
     17c:	84 2b       	or	r24, r20
     17e:	8c 93       	st	X, r24
     180:	72 c0       	rjmp	.+228    	; 0x266 <DIO_WritePin+0x1d4>
     182:	8a 81       	ldd	r24, Y+2	; 0x02
     184:	88 23       	and	r24, r24
     186:	09 f0       	breq	.+2      	; 0x18a <DIO_WritePin+0xf8>
     188:	6e c0       	rjmp	.+220    	; 0x266 <DIO_WritePin+0x1d4>
     18a:	89 81       	ldd	r24, Y+1	; 0x01
     18c:	88 30       	cpi	r24, 0x08	; 8
     18e:	a8 f4       	brcc	.+42     	; 0x1ba <DIO_WritePin+0x128>
     190:	ab e3       	ldi	r26, 0x3B	; 59
     192:	b0 e0       	ldi	r27, 0x00	; 0
     194:	eb e3       	ldi	r30, 0x3B	; 59
     196:	f0 e0       	ldi	r31, 0x00	; 0
     198:	80 81       	ld	r24, Z
     19a:	48 2f       	mov	r20, r24
     19c:	89 81       	ldd	r24, Y+1	; 0x01
     19e:	28 2f       	mov	r18, r24
     1a0:	30 e0       	ldi	r19, 0x00	; 0
     1a2:	81 e0       	ldi	r24, 0x01	; 1
     1a4:	90 e0       	ldi	r25, 0x00	; 0
     1a6:	02 2e       	mov	r0, r18
     1a8:	02 c0       	rjmp	.+4      	; 0x1ae <DIO_WritePin+0x11c>
     1aa:	88 0f       	add	r24, r24
     1ac:	99 1f       	adc	r25, r25
     1ae:	0a 94       	dec	r0
     1b0:	e2 f7       	brpl	.-8      	; 0x1aa <DIO_WritePin+0x118>
     1b2:	80 95       	com	r24
     1b4:	84 23       	and	r24, r20
     1b6:	8c 93       	st	X, r24
     1b8:	56 c0       	rjmp	.+172    	; 0x266 <DIO_WritePin+0x1d4>
     1ba:	89 81       	ldd	r24, Y+1	; 0x01
     1bc:	88 30       	cpi	r24, 0x08	; 8
     1be:	d0 f0       	brcs	.+52     	; 0x1f4 <DIO_WritePin+0x162>
     1c0:	89 81       	ldd	r24, Y+1	; 0x01
     1c2:	80 31       	cpi	r24, 0x10	; 16
     1c4:	b8 f4       	brcc	.+46     	; 0x1f4 <DIO_WritePin+0x162>
     1c6:	a8 e3       	ldi	r26, 0x38	; 56
     1c8:	b0 e0       	ldi	r27, 0x00	; 0
     1ca:	e8 e3       	ldi	r30, 0x38	; 56
     1cc:	f0 e0       	ldi	r31, 0x00	; 0
     1ce:	80 81       	ld	r24, Z
     1d0:	48 2f       	mov	r20, r24
     1d2:	89 81       	ldd	r24, Y+1	; 0x01
     1d4:	88 2f       	mov	r24, r24
     1d6:	90 e0       	ldi	r25, 0x00	; 0
     1d8:	08 97       	sbiw	r24, 0x08	; 8
     1da:	9c 01       	movw	r18, r24
     1dc:	81 e0       	ldi	r24, 0x01	; 1
     1de:	90 e0       	ldi	r25, 0x00	; 0
     1e0:	02 2e       	mov	r0, r18
     1e2:	02 c0       	rjmp	.+4      	; 0x1e8 <DIO_WritePin+0x156>
     1e4:	88 0f       	add	r24, r24
     1e6:	99 1f       	adc	r25, r25
     1e8:	0a 94       	dec	r0
     1ea:	e2 f7       	brpl	.-8      	; 0x1e4 <DIO_WritePin+0x152>
     1ec:	80 95       	com	r24
     1ee:	84 23       	and	r24, r20
     1f0:	8c 93       	st	X, r24
     1f2:	39 c0       	rjmp	.+114    	; 0x266 <DIO_WritePin+0x1d4>
     1f4:	89 81       	ldd	r24, Y+1	; 0x01
     1f6:	80 31       	cpi	r24, 0x10	; 16
     1f8:	d0 f0       	brcs	.+52     	; 0x22e <DIO_WritePin+0x19c>
     1fa:	89 81       	ldd	r24, Y+1	; 0x01
     1fc:	88 31       	cpi	r24, 0x18	; 24
     1fe:	b8 f4       	brcc	.+46     	; 0x22e <DIO_WritePin+0x19c>
     200:	a5 e3       	ldi	r26, 0x35	; 53
     202:	b0 e0       	ldi	r27, 0x00	; 0
     204:	e5 e3       	ldi	r30, 0x35	; 53
     206:	f0 e0       	ldi	r31, 0x00	; 0
     208:	80 81       	ld	r24, Z
     20a:	48 2f       	mov	r20, r24
     20c:	89 81       	ldd	r24, Y+1	; 0x01
     20e:	88 2f       	mov	r24, r24
     210:	90 e0       	ldi	r25, 0x00	; 0
     212:	40 97       	sbiw	r24, 0x10	; 16
     214:	9c 01       	movw	r18, r24
     216:	81 e0       	ldi	r24, 0x01	; 1
     218:	90 e0       	ldi	r25, 0x00	; 0
     21a:	02 2e       	mov	r0, r18
     21c:	02 c0       	rjmp	.+4      	; 0x222 <DIO_WritePin+0x190>
     21e:	88 0f       	add	r24, r24
     220:	99 1f       	adc	r25, r25
     222:	0a 94       	dec	r0
     224:	e2 f7       	brpl	.-8      	; 0x21e <DIO_WritePin+0x18c>
     226:	80 95       	com	r24
     228:	84 23       	and	r24, r20
     22a:	8c 93       	st	X, r24
     22c:	1c c0       	rjmp	.+56     	; 0x266 <DIO_WritePin+0x1d4>
     22e:	89 81       	ldd	r24, Y+1	; 0x01
     230:	88 31       	cpi	r24, 0x18	; 24
     232:	c8 f0       	brcs	.+50     	; 0x266 <DIO_WritePin+0x1d4>
     234:	89 81       	ldd	r24, Y+1	; 0x01
     236:	80 32       	cpi	r24, 0x20	; 32
     238:	b0 f4       	brcc	.+44     	; 0x266 <DIO_WritePin+0x1d4>
     23a:	a2 e3       	ldi	r26, 0x32	; 50
     23c:	b0 e0       	ldi	r27, 0x00	; 0
     23e:	e2 e3       	ldi	r30, 0x32	; 50
     240:	f0 e0       	ldi	r31, 0x00	; 0
     242:	80 81       	ld	r24, Z
     244:	48 2f       	mov	r20, r24
     246:	89 81       	ldd	r24, Y+1	; 0x01
     248:	88 2f       	mov	r24, r24
     24a:	90 e0       	ldi	r25, 0x00	; 0
     24c:	48 97       	sbiw	r24, 0x18	; 24
     24e:	9c 01       	movw	r18, r24
     250:	81 e0       	ldi	r24, 0x01	; 1
     252:	90 e0       	ldi	r25, 0x00	; 0
     254:	02 2e       	mov	r0, r18
     256:	02 c0       	rjmp	.+4      	; 0x25c <DIO_WritePin+0x1ca>
     258:	88 0f       	add	r24, r24
     25a:	99 1f       	adc	r25, r25
     25c:	0a 94       	dec	r0
     25e:	e2 f7       	brpl	.-8      	; 0x258 <DIO_WritePin+0x1c6>
     260:	80 95       	com	r24
     262:	84 23       	and	r24, r20
     264:	8c 93       	st	X, r24
     266:	0f 90       	pop	r0
     268:	0f 90       	pop	r0
     26a:	cf 91       	pop	r28
     26c:	df 91       	pop	r29
     26e:	08 95       	ret

00000270 <DIO_ReadPin>:
		}
	}

}
uint8 DIO_ReadPin(uint8 PinNum)
{
     270:	df 93       	push	r29
     272:	cf 93       	push	r28
     274:	00 d0       	rcall	.+0      	; 0x276 <DIO_ReadPin+0x6>
     276:	cd b7       	in	r28, 0x3d	; 61
     278:	de b7       	in	r29, 0x3e	; 62
     27a:	89 83       	std	Y+1, r24	; 0x01
	if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     27c:	89 81       	ldd	r24, Y+1	; 0x01
     27e:	88 30       	cpi	r24, 0x08	; 8
     280:	98 f4       	brcc	.+38     	; 0x2a8 <DIO_ReadPin+0x38>
	{
		return GET_BIT(DIO_PINA,PinNum);
     282:	e9 e3       	ldi	r30, 0x39	; 57
     284:	f0 e0       	ldi	r31, 0x00	; 0
     286:	80 81       	ld	r24, Z
     288:	28 2f       	mov	r18, r24
     28a:	30 e0       	ldi	r19, 0x00	; 0
     28c:	89 81       	ldd	r24, Y+1	; 0x01
     28e:	88 2f       	mov	r24, r24
     290:	90 e0       	ldi	r25, 0x00	; 0
     292:	a9 01       	movw	r20, r18
     294:	02 c0       	rjmp	.+4      	; 0x29a <DIO_ReadPin+0x2a>
     296:	55 95       	asr	r21
     298:	47 95       	ror	r20
     29a:	8a 95       	dec	r24
     29c:	e2 f7       	brpl	.-8      	; 0x296 <DIO_ReadPin+0x26>
     29e:	ca 01       	movw	r24, r20
     2a0:	58 2f       	mov	r21, r24
     2a2:	51 70       	andi	r21, 0x01	; 1
     2a4:	5a 83       	std	Y+2, r21	; 0x02
     2a6:	50 c0       	rjmp	.+160    	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     2a8:	89 81       	ldd	r24, Y+1	; 0x01
     2aa:	88 30       	cpi	r24, 0x08	; 8
     2ac:	b8 f0       	brcs	.+46     	; 0x2dc <DIO_ReadPin+0x6c>
     2ae:	89 81       	ldd	r24, Y+1	; 0x01
     2b0:	80 31       	cpi	r24, 0x10	; 16
     2b2:	a0 f4       	brcc	.+40     	; 0x2dc <DIO_ReadPin+0x6c>
	{
		return GET_BIT(DIO_PINB,(PinNum-DIO_PIN8));
     2b4:	e6 e3       	ldi	r30, 0x36	; 54
     2b6:	f0 e0       	ldi	r31, 0x00	; 0
     2b8:	80 81       	ld	r24, Z
     2ba:	28 2f       	mov	r18, r24
     2bc:	30 e0       	ldi	r19, 0x00	; 0
     2be:	89 81       	ldd	r24, Y+1	; 0x01
     2c0:	88 2f       	mov	r24, r24
     2c2:	90 e0       	ldi	r25, 0x00	; 0
     2c4:	08 97       	sbiw	r24, 0x08	; 8
     2c6:	a9 01       	movw	r20, r18
     2c8:	02 c0       	rjmp	.+4      	; 0x2ce <DIO_ReadPin+0x5e>
     2ca:	55 95       	asr	r21
     2cc:	47 95       	ror	r20
     2ce:	8a 95       	dec	r24
     2d0:	e2 f7       	brpl	.-8      	; 0x2ca <DIO_ReadPin+0x5a>
     2d2:	ca 01       	movw	r24, r20
     2d4:	58 2f       	mov	r21, r24
     2d6:	51 70       	andi	r21, 0x01	; 1
     2d8:	5a 83       	std	Y+2, r21	; 0x02
     2da:	36 c0       	rjmp	.+108    	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     2dc:	89 81       	ldd	r24, Y+1	; 0x01
     2de:	80 31       	cpi	r24, 0x10	; 16
     2e0:	b8 f0       	brcs	.+46     	; 0x310 <DIO_ReadPin+0xa0>
     2e2:	89 81       	ldd	r24, Y+1	; 0x01
     2e4:	88 31       	cpi	r24, 0x18	; 24
     2e6:	a0 f4       	brcc	.+40     	; 0x310 <DIO_ReadPin+0xa0>
	{
		return GET_BIT(DIO_PINC,(PinNum-DIO_PIN16));
     2e8:	e3 e3       	ldi	r30, 0x33	; 51
     2ea:	f0 e0       	ldi	r31, 0x00	; 0
     2ec:	80 81       	ld	r24, Z
     2ee:	28 2f       	mov	r18, r24
     2f0:	30 e0       	ldi	r19, 0x00	; 0
     2f2:	89 81       	ldd	r24, Y+1	; 0x01
     2f4:	88 2f       	mov	r24, r24
     2f6:	90 e0       	ldi	r25, 0x00	; 0
     2f8:	40 97       	sbiw	r24, 0x10	; 16
     2fa:	a9 01       	movw	r20, r18
     2fc:	02 c0       	rjmp	.+4      	; 0x302 <DIO_ReadPin+0x92>
     2fe:	55 95       	asr	r21
     300:	47 95       	ror	r20
     302:	8a 95       	dec	r24
     304:	e2 f7       	brpl	.-8      	; 0x2fe <DIO_ReadPin+0x8e>
     306:	ca 01       	movw	r24, r20
     308:	58 2f       	mov	r21, r24
     30a:	51 70       	andi	r21, 0x01	; 1
     30c:	5a 83       	std	Y+2, r21	; 0x02
     30e:	1c c0       	rjmp	.+56     	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     310:	89 81       	ldd	r24, Y+1	; 0x01
     312:	88 31       	cpi	r24, 0x18	; 24
     314:	b8 f0       	brcs	.+46     	; 0x344 <DIO_ReadPin+0xd4>
     316:	89 81       	ldd	r24, Y+1	; 0x01
     318:	80 32       	cpi	r24, 0x20	; 32
     31a:	a0 f4       	brcc	.+40     	; 0x344 <DIO_ReadPin+0xd4>
	{
		return GET_BIT(DIO_PIND,(PinNum-DIO_PIN24));
     31c:	e0 e3       	ldi	r30, 0x30	; 48
     31e:	f0 e0       	ldi	r31, 0x00	; 0
     320:	80 81       	ld	r24, Z
     322:	28 2f       	mov	r18, r24
     324:	30 e0       	ldi	r19, 0x00	; 0
     326:	89 81       	ldd	r24, Y+1	; 0x01
     328:	88 2f       	mov	r24, r24
     32a:	90 e0       	ldi	r25, 0x00	; 0
     32c:	48 97       	sbiw	r24, 0x18	; 24
     32e:	a9 01       	movw	r20, r18
     330:	02 c0       	rjmp	.+4      	; 0x336 <DIO_ReadPin+0xc6>
     332:	55 95       	asr	r21
     334:	47 95       	ror	r20
     336:	8a 95       	dec	r24
     338:	e2 f7       	brpl	.-8      	; 0x332 <DIO_ReadPin+0xc2>
     33a:	ca 01       	movw	r24, r20
     33c:	58 2f       	mov	r21, r24
     33e:	51 70       	andi	r21, 0x01	; 1
     340:	5a 83       	std	Y+2, r21	; 0x02
     342:	02 c0       	rjmp	.+4      	; 0x348 <DIO_ReadPin+0xd8>
	}
	return DIO_PIN8;
     344:	88 e0       	ldi	r24, 0x08	; 8
     346:	8a 83       	std	Y+2, r24	; 0x02
     348:	8a 81       	ldd	r24, Y+2	; 0x02
}
     34a:	0f 90       	pop	r0
     34c:	0f 90       	pop	r0
     34e:	cf 91       	pop	r28
     350:	df 91       	pop	r29
     352:	08 95       	ret

00000354 <DIO_SetPinDirection>:
void DIO_SetPinDirection(uint8 PinNum,uint8 PinDirection)
{
     354:	df 93       	push	r29
     356:	cf 93       	push	r28
     358:	00 d0       	rcall	.+0      	; 0x35a <DIO_SetPinDirection+0x6>
     35a:	cd b7       	in	r28, 0x3d	; 61
     35c:	de b7       	in	r29, 0x3e	; 62
     35e:	89 83       	std	Y+1, r24	; 0x01
     360:	6a 83       	std	Y+2, r22	; 0x02
	if(PinDirection==INPUT)
     362:	8a 81       	ldd	r24, Y+2	; 0x02
     364:	88 23       	and	r24, r24
     366:	09 f0       	breq	.+2      	; 0x36a <DIO_SetPinDirection+0x16>
     368:	71 c0       	rjmp	.+226    	; 0x44c <DIO_SetPinDirection+0xf8>
	{
		if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     36a:	89 81       	ldd	r24, Y+1	; 0x01
     36c:	88 30       	cpi	r24, 0x08	; 8
     36e:	a8 f4       	brcc	.+42     	; 0x39a <DIO_SetPinDirection+0x46>
		{
			CLEAR_BIT(DIO_DDRA,PinNum);
     370:	aa e3       	ldi	r26, 0x3A	; 58
     372:	b0 e0       	ldi	r27, 0x00	; 0
     374:	ea e3       	ldi	r30, 0x3A	; 58
     376:	f0 e0       	ldi	r31, 0x00	; 0
     378:	80 81       	ld	r24, Z
     37a:	48 2f       	mov	r20, r24
     37c:	89 81       	ldd	r24, Y+1	; 0x01
     37e:	28 2f       	mov	r18, r24
     380:	30 e0       	ldi	r19, 0x00	; 0
     382:	81 e0       	ldi	r24, 0x01	; 1
     384:	90 e0       	ldi	r25, 0x00	; 0
     386:	02 2e       	mov	r0, r18
     388:	02 c0       	rjmp	.+4      	; 0x38e <DIO_SetPinDirection+0x3a>
     38a:	88 0f       	add	r24, r24
     38c:	99 1f       	adc	r25, r25
     38e:	0a 94       	dec	r0
     390:	e2 f7       	brpl	.-8      	; 0x38a <DIO_SetPinDirection+0x36>
     392:	80 95       	com	r24
     394:	84 23       	and	r24, r20
     396:	8c 93       	st	X, r24
     398:	c7 c0       	rjmp	.+398    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     39a:	89 81       	ldd	r24, Y+1	; 0x01
     39c:	88 30       	cpi	r24, 0x08	; 8
     39e:	d0 f0       	brcs	.+52     	; 0x3d4 <DIO_SetPinDirection+0x80>
     3a0:	89 81       	ldd	r24, Y+1	; 0x01
     3a2:	80 31       	cpi	r24, 0x10	; 16
     3a4:	b8 f4       	brcc	.+46     	; 0x3d4 <DIO_SetPinDirection+0x80>
		{
			CLEAR_BIT(DIO_DDRB,(PinNum-DIO_PIN8));
     3a6:	a7 e3       	ldi	r26, 0x37	; 55
     3a8:	b0 e0       	ldi	r27, 0x00	; 0
     3aa:	e7 e3       	ldi	r30, 0x37	; 55
     3ac:	f0 e0       	ldi	r31, 0x00	; 0
     3ae:	80 81       	ld	r24, Z
     3b0:	48 2f       	mov	r20, r24
     3b2:	89 81       	ldd	r24, Y+1	; 0x01
     3b4:	88 2f       	mov	r24, r24
     3b6:	90 e0       	ldi	r25, 0x00	; 0
     3b8:	08 97       	sbiw	r24, 0x08	; 8
     3ba:	9c 01       	movw	r18, r24
     3bc:	81 e0       	ldi	r24, 0x01	; 1
     3be:	90 e0       	ldi	r25, 0x00	; 0
     3c0:	02 2e       	mov	r0, r18
     3c2:	02 c0       	rjmp	.+4      	; 0x3c8 <DIO_SetPinDirection+0x74>
     3c4:	88 0f       	add	r24, r24
     3c6:	99 1f       	adc	r25, r25
     3c8:	0a 94       	dec	r0
     3ca:	e2 f7       	brpl	.-8      	; 0x3c4 <DIO_SetPinDirection+0x70>
     3cc:	80 95       	com	r24
     3ce:	84 23       	and	r24, r20
     3d0:	8c 93       	st	X, r24
     3d2:	aa c0       	rjmp	.+340    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     3d4:	89 81       	ldd	r24, Y+1	; 0x01
     3d6:	80 31       	cpi	r24, 0x10	; 16
     3d8:	d0 f0       	brcs	.+52     	; 0x40e <DIO_SetPinDirection+0xba>
     3da:	89 81       	ldd	r24, Y+1	; 0x01
     3dc:	88 31       	cpi	r24, 0x18	; 24
     3de:	b8 f4       	brcc	.+46     	; 0x40e <DIO_SetPinDirection+0xba>
		{
			CLEAR_BIT(DIO_DDRC,(PinNum-DIO_PIN16));
     3e0:	a4 e3       	ldi	r26, 0x34	; 52
     3e2:	b0 e0       	ldi	r27, 0x00	; 0
     3e4:	e4 e3       	ldi	r30, 0x34	; 52
     3e6:	f0 e0       	ldi	r31, 0x00	; 0
     3e8:	80 81       	ld	r24, Z
     3ea:	48 2f       	mov	r20, r24
     3ec:	89 81       	ldd	r24, Y+1	; 0x01
     3ee:	88 2f       	mov	r24, r24
     3f0:	90 e0       	ldi	r25, 0x00	; 0
     3f2:	40 97       	sbiw	r24, 0x10	; 16
     3f4:	9c 01       	movw	r18, r24
     3f6:	81 e0       	ldi	r24, 0x01	; 1
     3f8:	90 e0       	ldi	r25, 0x00	; 0
     3fa:	02 2e       	mov	r0, r18
     3fc:	02 c0       	rjmp	.+4      	; 0x402 <DIO_SetPinDirection+0xae>
     3fe:	88 0f       	add	r24, r24
     400:	99 1f       	adc	r25, r25
     402:	0a 94       	dec	r0
     404:	e2 f7       	brpl	.-8      	; 0x3fe <DIO_SetPinDirection+0xaa>
     406:	80 95       	com	r24
     408:	84 23       	and	r24, r20
     40a:	8c 93       	st	X, r24
     40c:	8d c0       	rjmp	.+282    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     40e:	89 81       	ldd	r24, Y+1	; 0x01
     410:	88 31       	cpi	r24, 0x18	; 24
     412:	08 f4       	brcc	.+2      	; 0x416 <DIO_SetPinDirection+0xc2>
     414:	89 c0       	rjmp	.+274    	; 0x528 <DIO_SetPinDirection+0x1d4>
     416:	89 81       	ldd	r24, Y+1	; 0x01
     418:	80 32       	cpi	r24, 0x20	; 32
     41a:	08 f0       	brcs	.+2      	; 0x41e <DIO_SetPinDirection+0xca>
     41c:	85 c0       	rjmp	.+266    	; 0x528 <DIO_SetPinDirection+0x1d4>
		{
			CLEAR_BIT(DIO_DDRD,(PinNum-DIO_PIN24));
     41e:	a1 e3       	ldi	r26, 0x31	; 49
     420:	b0 e0       	ldi	r27, 0x00	; 0
     422:	e1 e3       	ldi	r30, 0x31	; 49
     424:	f0 e0       	ldi	r31, 0x00	; 0
     426:	80 81       	ld	r24, Z
     428:	48 2f       	mov	r20, r24
     42a:	89 81       	ldd	r24, Y+1	; 0x01
     42c:	88 2f       	mov	r24, r24
     42e:	90 e0       	ldi	r25, 0x00	; 0
     430:	48 97       	sbiw	r24, 0x18	; 24
     432:	9c 01       	movw	r18, r24
     434:	81 e0       	ldi	r24, 0x01	; 1
     436:	90 e0       	ldi	r25, 0x00	; 0
     438:	02 2e       	mov	r0, r18
     43a:	02 c0       	rjmp	.+4      	; 0x440 <DIO_SetPinDirection+0xec>
     43c:	88 0f       	add	r24, r24
     43e:	99 1f       	adc	r25, r25
     440:	0a 94       	dec	r0
     442:	e2 f7       	brpl	.-8      	; 0x43c <DIO_SetPinDirection+0xe8>
     444:	80 95       	com	r24
     446:	84 23       	and	r24, r20
     448:	8c 93       	st	X, r24
     44a:	6e c0       	rjmp	.+220    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
	}
	else if(PinDirection==OUTPUT)
     44c:	8a 81       	ldd	r24, Y+2	; 0x02
     44e:	81 30       	cpi	r24, 0x01	; 1
     450:	09 f0       	breq	.+2      	; 0x454 <DIO_SetPinDirection+0x100>
     452:	6a c0       	rjmp	.+212    	; 0x528 <DIO_SetPinDirection+0x1d4>
	{
		if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     454:	89 81       	ldd	r24, Y+1	; 0x01
     456:	88 30       	cpi	r24, 0x08	; 8
     458:	a0 f4       	brcc	.+40     	; 0x482 <DIO_SetPinDirection+0x12e>
		{
			SET_BIT(DIO_DDRA,PinNum);
     45a:	aa e3       	ldi	r26, 0x3A	; 58
     45c:	b0 e0       	ldi	r27, 0x00	; 0
     45e:	ea e3       	ldi	r30, 0x3A	; 58
     460:	f0 e0       	ldi	r31, 0x00	; 0
     462:	80 81       	ld	r24, Z
     464:	48 2f       	mov	r20, r24
     466:	89 81       	ldd	r24, Y+1	; 0x01
     468:	28 2f       	mov	r18, r24
     46a:	30 e0       	ldi	r19, 0x00	; 0
     46c:	81 e0       	ldi	r24, 0x01	; 1
     46e:	90 e0       	ldi	r25, 0x00	; 0
     470:	02 2e       	mov	r0, r18
     472:	02 c0       	rjmp	.+4      	; 0x478 <DIO_SetPinDirection+0x124>
     474:	88 0f       	add	r24, r24
     476:	99 1f       	adc	r25, r25
     478:	0a 94       	dec	r0
     47a:	e2 f7       	brpl	.-8      	; 0x474 <DIO_SetPinDirection+0x120>
     47c:	84 2b       	or	r24, r20
     47e:	8c 93       	st	X, r24
     480:	53 c0       	rjmp	.+166    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     482:	89 81       	ldd	r24, Y+1	; 0x01
     484:	88 30       	cpi	r24, 0x08	; 8
     486:	c8 f0       	brcs	.+50     	; 0x4ba <DIO_SetPinDirection+0x166>
     488:	89 81       	ldd	r24, Y+1	; 0x01
     48a:	80 31       	cpi	r24, 0x10	; 16
     48c:	b0 f4       	brcc	.+44     	; 0x4ba <DIO_SetPinDirection+0x166>
		{
			SET_BIT(DIO_DDRB,(PinNum-DIO_PIN8));
     48e:	a7 e3       	ldi	r26, 0x37	; 55
     490:	b0 e0       	ldi	r27, 0x00	; 0
     492:	e7 e3       	ldi	r30, 0x37	; 55
     494:	f0 e0       	ldi	r31, 0x00	; 0
     496:	80 81       	ld	r24, Z
     498:	48 2f       	mov	r20, r24
     49a:	89 81       	ldd	r24, Y+1	; 0x01
     49c:	88 2f       	mov	r24, r24
     49e:	90 e0       	ldi	r25, 0x00	; 0
     4a0:	08 97       	sbiw	r24, 0x08	; 8
     4a2:	9c 01       	movw	r18, r24
     4a4:	81 e0       	ldi	r24, 0x01	; 1
     4a6:	90 e0       	ldi	r25, 0x00	; 0
     4a8:	02 2e       	mov	r0, r18
     4aa:	02 c0       	rjmp	.+4      	; 0x4b0 <DIO_SetPinDirection+0x15c>
     4ac:	88 0f       	add	r24, r24
     4ae:	99 1f       	adc	r25, r25
     4b0:	0a 94       	dec	r0
     4b2:	e2 f7       	brpl	.-8      	; 0x4ac <DIO_SetPinDirection+0x158>
     4b4:	84 2b       	or	r24, r20
     4b6:	8c 93       	st	X, r24
     4b8:	37 c0       	rjmp	.+110    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     4ba:	89 81       	ldd	r24, Y+1	; 0x01
     4bc:	80 31       	cpi	r24, 0x10	; 16
     4be:	c8 f0       	brcs	.+50     	; 0x4f2 <DIO_SetPinDirection+0x19e>
     4c0:	89 81       	ldd	r24, Y+1	; 0x01
     4c2:	88 31       	cpi	r24, 0x18	; 24
     4c4:	b0 f4       	brcc	.+44     	; 0x4f2 <DIO_SetPinDirection+0x19e>
		{
			SET_BIT(DIO_DDRC,(PinNum-DIO_PIN16));
     4c6:	a4 e3       	ldi	r26, 0x34	; 52
     4c8:	b0 e0       	ldi	r27, 0x00	; 0
     4ca:	e4 e3       	ldi	r30, 0x34	; 52
     4cc:	f0 e0       	ldi	r31, 0x00	; 0
     4ce:	80 81       	ld	r24, Z
     4d0:	48 2f       	mov	r20, r24
     4d2:	89 81       	ldd	r24, Y+1	; 0x01
     4d4:	88 2f       	mov	r24, r24
     4d6:	90 e0       	ldi	r25, 0x00	; 0
     4d8:	40 97       	sbiw	r24, 0x10	; 16
     4da:	9c 01       	movw	r18, r24
     4dc:	81 e0       	ldi	r24, 0x01	; 1
     4de:	90 e0       	ldi	r25, 0x00	; 0
     4e0:	02 2e       	mov	r0, r18
     4e2:	02 c0       	rjmp	.+4      	; 0x4e8 <DIO_SetPinDirection+0x194>
     4e4:	88 0f       	add	r24, r24
     4e6:	99 1f       	adc	r25, r25
     4e8:	0a 94       	dec	r0
     4ea:	e2 f7       	brpl	.-8      	; 0x4e4 <DIO_SetPinDirection+0x190>
     4ec:	84 2b       	or	r24, r20
     4ee:	8c 93       	st	X, r24
     4f0:	1b c0       	rjmp	.+54     	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     4f2:	89 81       	ldd	r24, Y+1	; 0x01
     4f4:	88 31       	cpi	r24, 0x18	; 24
     4f6:	c0 f0       	brcs	.+48     	; 0x528 <DIO_SetPinDirection+0x1d4>
     4f8:	89 81       	ldd	r24, Y+1	; 0x01
     4fa:	80 32       	cpi	r24, 0x20	; 32
     4fc:	a8 f4       	brcc	.+42     	; 0x528 <DIO_SetPinDirection+0x1d4>
		{
			SET_BIT(DIO_DDRD,(PinNum-DIO_PIN24));
     4fe:	a1 e3       	ldi	r26, 0x31	; 49
     500:	b0 e0       	ldi	r27, 0x00	; 0
     502:	e1 e3       	ldi	r30, 0x31	; 49
     504:	f0 e0       	ldi	r31, 0x00	; 0
     506:	80 81       	ld	r24, Z
     508:	48 2f       	mov	r20, r24
     50a:	89 81       	ldd	r24, Y+1	; 0x01
     50c:	88 2f       	mov	r24, r24
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	48 97       	sbiw	r24, 0x18	; 24
     512:	9c 01       	movw	r18, r24
     514:	81 e0       	ldi	r24, 0x01	; 1
     516:	90 e0       	ldi	r25, 0x00	; 0
     518:	02 2e       	mov	r0, r18
     51a:	02 c0       	rjmp	.+4      	; 0x520 <DIO_SetPinDirection+0x1cc>
     51c:	88 0f       	add	r24, r24
     51e:	99 1f       	adc	r25, r25
     520:	0a 94       	dec	r0
     522:	e2 f7       	brpl	.-8      	; 0x51c <DIO_SetPinDirection+0x1c8>
     524:	84 2b       	or	r24, r20
     526:	8c 93       	st	X, r24
		}
	}


}
     528:	0f 90       	pop	r0
     52a:	0f 90       	pop	r0
     52c:	cf 91       	pop	r28
     52e:	df 91       	pop	r29
     530:	08 95       	ret

00000532 <PushButton_Init>:
 * Outputs:         NULL
 *
 * Return:          NULL
 *******************************************************************************/
void PushButton_Init(void)
{
     532:	df 93       	push	r29
     534:	cf 93       	push	r28
     536:	cd b7       	in	r28, 0x3d	; 61
     538:	de b7       	in	r29, 0x3e	; 62
    /*set Pins Of Push Button*/
    DIO_SetPinDirection(DIO_PIN10 , INPUT);
     53a:	8a e0       	ldi	r24, 0x0A	; 10
     53c:	60 e0       	ldi	r22, 0x00	; 0
     53e:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
    DIO_SetPinDirection(DIO_PIN20 , INPUT);
     542:	84 e1       	ldi	r24, 0x14	; 20
     544:	60 e0       	ldi	r22, 0x00	; 0
     546:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>


}
     54a:	cf 91       	pop	r28
     54c:	df 91       	pop	r29
     54e:	08 95       	ret

00000550 <Buttons_getPressedButton>:
 * Outputs:         NULL
 *
 * Return:          pressed Push Button (uint8_t)
 *******************************************************************************/
uint8 Buttons_getPressedButton(void)
{
     550:	df 93       	push	r29
     552:	cf 93       	push	r28
     554:	0f 92       	push	r0
     556:	cd b7       	in	r28, 0x3d	; 61
     558:	de b7       	in	r29, 0x3e	; 62
    /*return value*/
    uint8 ReturnVal=10;
     55a:	8a e0       	ldi	r24, 0x0A	; 10
     55c:	89 83       	std	Y+1, r24	; 0x01


    /*Loop to check if button is pressed to return its value*/

    if(DIO_ReadPin(DIO_PIN10) == 1)
     55e:	8a e0       	ldi	r24, 0x0A	; 10
     560:	0e 94 38 01 	call	0x270	; 0x270 <DIO_ReadPin>
     564:	81 30       	cpi	r24, 0x01	; 1
     566:	19 f4       	brne	.+6      	; 0x56e <Buttons_getPressedButton+0x1e>
    {
        ReturnVal = 2;
     568:	82 e0       	ldi	r24, 0x02	; 2
     56a:	89 83       	std	Y+1, r24	; 0x01
     56c:	07 c0       	rjmp	.+14     	; 0x57c <Buttons_getPressedButton+0x2c>
    }
    else if(DIO_ReadPin(DIO_PIN20) == 1)
     56e:	84 e1       	ldi	r24, 0x14	; 20
     570:	0e 94 38 01 	call	0x270	; 0x270 <DIO_ReadPin>
     574:	81 30       	cpi	r24, 0x01	; 1
     576:	11 f4       	brne	.+4      	; 0x57c <Buttons_getPressedButton+0x2c>
    {
        ReturnVal = 1;
     578:	81 e0       	ldi	r24, 0x01	; 1
     57a:	89 83       	std	Y+1, r24	; 0x01
    }
    else
    {
        /*Do Nothing*/
    }
    return ReturnVal;
     57c:	89 81       	ldd	r24, Y+1	; 0x01
}
     57e:	0f 90       	pop	r0
     580:	cf 91       	pop	r28
     582:	df 91       	pop	r29
     584:	08 95       	ret

00000586 <UART_Init>:
 *  rate,Baud rate mood,Data size,Number of stop bits,Parity Mood and_		*
 *  interrupts mood.															*
 *																			*
 *****************************************************************************/
Status_t UART_Init(void)
{
     586:	df 93       	push	r29
     588:	cf 93       	push	r28
     58a:	00 d0       	rcall	.+0      	; 0x58c <UART_Init+0x6>
     58c:	00 d0       	rcall	.+0      	; 0x58e <UART_Init+0x8>
     58e:	0f 92       	push	r0
     590:	cd b7       	in	r28, 0x3d	; 61
     592:	de b7       	in	r29, 0x3e	; 62
	Status_t ReturnValue=NOT_OK;
     594:	19 82       	std	Y+1, r1	; 0x01
	/*select Baud rate mood*/
	if((UART_Config.Init_DoubleSpeed)==Dou_Speed)
     596:	80 91 e0 00 	lds	r24, 0x00E0
     59a:	81 30       	cpi	r24, 0x01	; 1
     59c:	09 f5       	brne	.+66     	; 0x5e0 <UART_Init+0x5a>
	{
		SET_BIT(USART_UCSRA,Bit_U2X);
     59e:	ab e2       	ldi	r26, 0x2B	; 43
     5a0:	b0 e0       	ldi	r27, 0x00	; 0
     5a2:	eb e2       	ldi	r30, 0x2B	; 43
     5a4:	f0 e0       	ldi	r31, 0x00	; 0
     5a6:	80 81       	ld	r24, Z
     5a8:	82 60       	ori	r24, 0x02	; 2
     5aa:	8c 93       	st	X, r24
		USART_BaudRateLow=UART_Config.BuadRate;
     5ac:	e9 e2       	ldi	r30, 0x29	; 41
     5ae:	f0 e0       	ldi	r31, 0x00	; 0
     5b0:	80 91 d8 00 	lds	r24, 0x00D8
     5b4:	90 91 d9 00 	lds	r25, 0x00D9
     5b8:	80 83       	st	Z, r24
		CLEAR_BIT(USART_BaudRateHigh,SelectRegister_URSEL);
     5ba:	a0 e4       	ldi	r26, 0x40	; 64
     5bc:	b0 e0       	ldi	r27, 0x00	; 0
     5be:	e0 e4       	ldi	r30, 0x40	; 64
     5c0:	f0 e0       	ldi	r31, 0x00	; 0
     5c2:	80 81       	ld	r24, Z
     5c4:	8f 77       	andi	r24, 0x7F	; 127
     5c6:	8c 93       	st	X, r24
		USART_BaudRateHigh=((UART_Config.BuadRate)>>8);
     5c8:	e0 e4       	ldi	r30, 0x40	; 64
     5ca:	f0 e0       	ldi	r31, 0x00	; 0
     5cc:	80 91 d8 00 	lds	r24, 0x00D8
     5d0:	90 91 d9 00 	lds	r25, 0x00D9
     5d4:	89 2f       	mov	r24, r25
     5d6:	99 27       	eor	r25, r25
     5d8:	80 83       	st	Z, r24
		ReturnValue=OK;
     5da:	81 e0       	ldi	r24, 0x01	; 1
     5dc:	89 83       	std	Y+1, r24	; 0x01
     5de:	16 c0       	rjmp	.+44     	; 0x60c <UART_Init+0x86>
	}
	else if((UART_Config.Init_DoubleSpeed)==NormalSpeed)
     5e0:	80 91 e0 00 	lds	r24, 0x00E0
     5e4:	88 23       	and	r24, r24
     5e6:	89 f4       	brne	.+34     	; 0x60a <UART_Init+0x84>
	{
		CLEAR_BIT(USART_UCSRA,Bit_U2X);
     5e8:	ab e2       	ldi	r26, 0x2B	; 43
     5ea:	b0 e0       	ldi	r27, 0x00	; 0
     5ec:	eb e2       	ldi	r30, 0x2B	; 43
     5ee:	f0 e0       	ldi	r31, 0x00	; 0
     5f0:	80 81       	ld	r24, Z
     5f2:	8d 7f       	andi	r24, 0xFD	; 253
     5f4:	8c 93       	st	X, r24
		USART_BaudRateLow=UART_Config.BuadRate;
     5f6:	e9 e2       	ldi	r30, 0x29	; 41
     5f8:	f0 e0       	ldi	r31, 0x00	; 0
     5fa:	80 91 d8 00 	lds	r24, 0x00D8
     5fe:	90 91 d9 00 	lds	r25, 0x00D9
     602:	80 83       	st	Z, r24
		ReturnValue=OK;
     604:	81 e0       	ldi	r24, 0x01	; 1
     606:	89 83       	std	Y+1, r24	; 0x01
     608:	01 c0       	rjmp	.+2      	; 0x60c <UART_Init+0x86>
	}
	else
		ReturnValue=NOT_OK;
     60a:	19 82       	std	Y+1, r1	; 0x01
	/*select parity mood*/
	switch(UART_Config.Init_Parity)
     60c:	80 91 da 00 	lds	r24, 0x00DA
     610:	28 2f       	mov	r18, r24
     612:	30 e0       	ldi	r19, 0x00	; 0
     614:	3d 83       	std	Y+5, r19	; 0x05
     616:	2c 83       	std	Y+4, r18	; 0x04
     618:	8c 81       	ldd	r24, Y+4	; 0x04
     61a:	9d 81       	ldd	r25, Y+5	; 0x05
     61c:	81 30       	cpi	r24, 0x01	; 1
     61e:	91 05       	cpc	r25, r1
     620:	d9 f0       	breq	.+54     	; 0x658 <UART_Init+0xd2>
     622:	2c 81       	ldd	r18, Y+4	; 0x04
     624:	3d 81       	ldd	r19, Y+5	; 0x05
     626:	22 30       	cpi	r18, 0x02	; 2
     628:	31 05       	cpc	r19, r1
     62a:	69 f0       	breq	.+26     	; 0x646 <UART_Init+0xc0>
     62c:	8c 81       	ldd	r24, Y+4	; 0x04
     62e:	9d 81       	ldd	r25, Y+5	; 0x05
     630:	00 97       	sbiw	r24, 0x00	; 0
     632:	d1 f4       	brne	.+52     	; 0x668 <UART_Init+0xe2>
	{
	case NoParity:
		USART_UCSRC=(USART_UCSRC|0x80)&(~(1<<Bit0_UPM0))&(~(1<<Bit1_UPM1));
     634:	a0 e4       	ldi	r26, 0x40	; 64
     636:	b0 e0       	ldi	r27, 0x00	; 0
     638:	e0 e4       	ldi	r30, 0x40	; 64
     63a:	f0 e0       	ldi	r31, 0x00	; 0
     63c:	80 81       	ld	r24, Z
     63e:	8f 74       	andi	r24, 0x4F	; 79
     640:	80 68       	ori	r24, 0x80	; 128
     642:	8c 93       	st	X, r24
     644:	12 c0       	rjmp	.+36     	; 0x66a <UART_Init+0xe4>
		if(ReturnValue==OK)
			ReturnValue=OK;
		break;
	case EvenParity:
		USART_UCSRC=(USART_UCSRC|0xA0)&(~(1<<Bit0_UPM0));
     646:	a0 e4       	ldi	r26, 0x40	; 64
     648:	b0 e0       	ldi	r27, 0x00	; 0
     64a:	e0 e4       	ldi	r30, 0x40	; 64
     64c:	f0 e0       	ldi	r31, 0x00	; 0
     64e:	80 81       	ld	r24, Z
     650:	8f 74       	andi	r24, 0x4F	; 79
     652:	80 6a       	ori	r24, 0xA0	; 160
     654:	8c 93       	st	X, r24
     656:	09 c0       	rjmp	.+18     	; 0x66a <UART_Init+0xe4>
		if(ReturnValue==OK)
			ReturnValue=OK;
		break;
	case OddParity:
		USART_UCSRC=(USART_UCSRC|0xB0);
     658:	a0 e4       	ldi	r26, 0x40	; 64
     65a:	b0 e0       	ldi	r27, 0x00	; 0
     65c:	e0 e4       	ldi	r30, 0x40	; 64
     65e:	f0 e0       	ldi	r31, 0x00	; 0
     660:	80 81       	ld	r24, Z
     662:	80 6b       	ori	r24, 0xB0	; 176
     664:	8c 93       	st	X, r24
     666:	01 c0       	rjmp	.+2      	; 0x66a <UART_Init+0xe4>
		if(ReturnValue==OK)
			ReturnValue=OK;
		break;
	default:
		ReturnValue=NOT_OK;
     668:	19 82       	std	Y+1, r1	; 0x01
	}
	/*select number of stop bits*/
	if(UART_Config.Init_Stop==OneStopBit)
     66a:	80 91 db 00 	lds	r24, 0x00DB
     66e:	88 23       	and	r24, r24
     670:	49 f4       	brne	.+18     	; 0x684 <UART_Init+0xfe>
	{
		USART_UCSRC=(USART_UCSRC|0x80)&(~(1<<StopBits_USBS));
     672:	a0 e4       	ldi	r26, 0x40	; 64
     674:	b0 e0       	ldi	r27, 0x00	; 0
     676:	e0 e4       	ldi	r30, 0x40	; 64
     678:	f0 e0       	ldi	r31, 0x00	; 0
     67a:	80 81       	ld	r24, Z
     67c:	87 77       	andi	r24, 0x77	; 119
     67e:	80 68       	ori	r24, 0x80	; 128
     680:	8c 93       	st	X, r24
     682:	0d c0       	rjmp	.+26     	; 0x69e <UART_Init+0x118>
		if(ReturnValue==OK)
			ReturnValue=OK;
	}
	else if(UART_Config.Init_Stop==TwoStopBit)
     684:	80 91 db 00 	lds	r24, 0x00DB
     688:	81 30       	cpi	r24, 0x01	; 1
     68a:	41 f4       	brne	.+16     	; 0x69c <UART_Init+0x116>
	{
		USART_UCSRC=(USART_UCSRC|0x88);
     68c:	a0 e4       	ldi	r26, 0x40	; 64
     68e:	b0 e0       	ldi	r27, 0x00	; 0
     690:	e0 e4       	ldi	r30, 0x40	; 64
     692:	f0 e0       	ldi	r31, 0x00	; 0
     694:	80 81       	ld	r24, Z
     696:	88 68       	ori	r24, 0x88	; 136
     698:	8c 93       	st	X, r24
     69a:	01 c0       	rjmp	.+2      	; 0x69e <UART_Init+0x118>
		if(ReturnValue==OK)
			ReturnValue=OK;
	}
	else
		ReturnValue=NOT_OK;
     69c:	19 82       	std	Y+1, r1	; 0x01
	/*select data size*/
	switch(UART_Config.Init_DataSize)
     69e:	80 91 dc 00 	lds	r24, 0x00DC
     6a2:	28 2f       	mov	r18, r24
     6a4:	30 e0       	ldi	r19, 0x00	; 0
     6a6:	3b 83       	std	Y+3, r19	; 0x03
     6a8:	2a 83       	std	Y+2, r18	; 0x02
     6aa:	8a 81       	ldd	r24, Y+2	; 0x02
     6ac:	9b 81       	ldd	r25, Y+3	; 0x03
     6ae:	82 30       	cpi	r24, 0x02	; 2
     6b0:	91 05       	cpc	r25, r1
     6b2:	d9 f1       	breq	.+118    	; 0x72a <UART_Init+0x1a4>
     6b4:	2a 81       	ldd	r18, Y+2	; 0x02
     6b6:	3b 81       	ldd	r19, Y+3	; 0x03
     6b8:	23 30       	cpi	r18, 0x03	; 3
     6ba:	31 05       	cpc	r19, r1
     6bc:	54 f4       	brge	.+20     	; 0x6d2 <UART_Init+0x14c>
     6be:	8a 81       	ldd	r24, Y+2	; 0x02
     6c0:	9b 81       	ldd	r25, Y+3	; 0x03
     6c2:	00 97       	sbiw	r24, 0x00	; 0
     6c4:	91 f0       	breq	.+36     	; 0x6ea <UART_Init+0x164>
     6c6:	2a 81       	ldd	r18, Y+2	; 0x02
     6c8:	3b 81       	ldd	r19, Y+3	; 0x03
     6ca:	21 30       	cpi	r18, 0x01	; 1
     6cc:	31 05       	cpc	r19, r1
     6ce:	e9 f0       	breq	.+58     	; 0x70a <UART_Init+0x184>
     6d0:	5a c0       	rjmp	.+180    	; 0x786 <UART_Init+0x200>
     6d2:	8a 81       	ldd	r24, Y+2	; 0x02
     6d4:	9b 81       	ldd	r25, Y+3	; 0x03
     6d6:	83 30       	cpi	r24, 0x03	; 3
     6d8:	91 05       	cpc	r25, r1
     6da:	b9 f1       	breq	.+110    	; 0x74a <UART_Init+0x1c4>
     6dc:	2a 81       	ldd	r18, Y+2	; 0x02
     6de:	3b 81       	ldd	r19, Y+3	; 0x03
     6e0:	24 30       	cpi	r18, 0x04	; 4
     6e2:	31 05       	cpc	r19, r1
     6e4:	09 f4       	brne	.+2      	; 0x6e8 <UART_Init+0x162>
     6e6:	40 c0       	rjmp	.+128    	; 0x768 <UART_Init+0x1e2>
     6e8:	4e c0       	rjmp	.+156    	; 0x786 <UART_Init+0x200>
	{
	case _5_bit:
		USART_UCSRC=(USART_UCSRC|0x80)&(~(1<<Bit0_UCSZ0))&(~(1<<Bit1_UCSZ1));
     6ea:	a0 e4       	ldi	r26, 0x40	; 64
     6ec:	b0 e0       	ldi	r27, 0x00	; 0
     6ee:	e0 e4       	ldi	r30, 0x40	; 64
     6f0:	f0 e0       	ldi	r31, 0x00	; 0
     6f2:	80 81       	ld	r24, Z
     6f4:	89 77       	andi	r24, 0x79	; 121
     6f6:	80 68       	ori	r24, 0x80	; 128
     6f8:	8c 93       	st	X, r24
		CLEAR_BIT(USART_UCSRB,Bit2_UCSZ2);
     6fa:	aa e2       	ldi	r26, 0x2A	; 42
     6fc:	b0 e0       	ldi	r27, 0x00	; 0
     6fe:	ea e2       	ldi	r30, 0x2A	; 42
     700:	f0 e0       	ldi	r31, 0x00	; 0
     702:	80 81       	ld	r24, Z
     704:	8b 7f       	andi	r24, 0xFB	; 251
     706:	8c 93       	st	X, r24
     708:	3f c0       	rjmp	.+126    	; 0x788 <UART_Init+0x202>
		if(ReturnValue==OK)
			ReturnValue=OK;
		break;
	case _6_bit:
		USART_UCSRC=(USART_UCSRC|0x82)&(~(1<<Bit1_UCSZ1));
     70a:	a0 e4       	ldi	r26, 0x40	; 64
     70c:	b0 e0       	ldi	r27, 0x00	; 0
     70e:	e0 e4       	ldi	r30, 0x40	; 64
     710:	f0 e0       	ldi	r31, 0x00	; 0
     712:	80 81       	ld	r24, Z
     714:	89 77       	andi	r24, 0x79	; 121
     716:	82 68       	ori	r24, 0x82	; 130
     718:	8c 93       	st	X, r24
		CLEAR_BIT(USART_UCSRB,Bit2_UCSZ2);
     71a:	aa e2       	ldi	r26, 0x2A	; 42
     71c:	b0 e0       	ldi	r27, 0x00	; 0
     71e:	ea e2       	ldi	r30, 0x2A	; 42
     720:	f0 e0       	ldi	r31, 0x00	; 0
     722:	80 81       	ld	r24, Z
     724:	8b 7f       	andi	r24, 0xFB	; 251
     726:	8c 93       	st	X, r24
     728:	2f c0       	rjmp	.+94     	; 0x788 <UART_Init+0x202>
		if(ReturnValue==OK)
			ReturnValue=OK;
		break;
	case _7_bit:
		USART_UCSRC=(USART_UCSRC|0x84)&(~(1<<Bit0_UCSZ0));
     72a:	a0 e4       	ldi	r26, 0x40	; 64
     72c:	b0 e0       	ldi	r27, 0x00	; 0
     72e:	e0 e4       	ldi	r30, 0x40	; 64
     730:	f0 e0       	ldi	r31, 0x00	; 0
     732:	80 81       	ld	r24, Z
     734:	89 77       	andi	r24, 0x79	; 121
     736:	84 68       	ori	r24, 0x84	; 132
     738:	8c 93       	st	X, r24
		CLEAR_BIT(USART_UCSRB,Bit2_UCSZ2);
     73a:	aa e2       	ldi	r26, 0x2A	; 42
     73c:	b0 e0       	ldi	r27, 0x00	; 0
     73e:	ea e2       	ldi	r30, 0x2A	; 42
     740:	f0 e0       	ldi	r31, 0x00	; 0
     742:	80 81       	ld	r24, Z
     744:	8b 7f       	andi	r24, 0xFB	; 251
     746:	8c 93       	st	X, r24
     748:	1f c0       	rjmp	.+62     	; 0x788 <UART_Init+0x202>
		if(ReturnValue==OK)
			ReturnValue=OK;
		break;
	case _8_bit:
		USART_UCSRC=(USART_UCSRC|0x86);
     74a:	a0 e4       	ldi	r26, 0x40	; 64
     74c:	b0 e0       	ldi	r27, 0x00	; 0
     74e:	e0 e4       	ldi	r30, 0x40	; 64
     750:	f0 e0       	ldi	r31, 0x00	; 0
     752:	80 81       	ld	r24, Z
     754:	86 68       	ori	r24, 0x86	; 134
     756:	8c 93       	st	X, r24
		CLEAR_BIT(USART_UCSRB,Bit2_UCSZ2);
     758:	aa e2       	ldi	r26, 0x2A	; 42
     75a:	b0 e0       	ldi	r27, 0x00	; 0
     75c:	ea e2       	ldi	r30, 0x2A	; 42
     75e:	f0 e0       	ldi	r31, 0x00	; 0
     760:	80 81       	ld	r24, Z
     762:	8b 7f       	andi	r24, 0xFB	; 251
     764:	8c 93       	st	X, r24
     766:	10 c0       	rjmp	.+32     	; 0x788 <UART_Init+0x202>
		if(ReturnValue==OK)
			ReturnValue=OK;
		break;
	case _9_bit:
		USART_UCSRC=(USART_UCSRC|0x86);
     768:	a0 e4       	ldi	r26, 0x40	; 64
     76a:	b0 e0       	ldi	r27, 0x00	; 0
     76c:	e0 e4       	ldi	r30, 0x40	; 64
     76e:	f0 e0       	ldi	r31, 0x00	; 0
     770:	80 81       	ld	r24, Z
     772:	86 68       	ori	r24, 0x86	; 134
     774:	8c 93       	st	X, r24
		SET_BIT(USART_UCSRB,Bit2_UCSZ2);
     776:	aa e2       	ldi	r26, 0x2A	; 42
     778:	b0 e0       	ldi	r27, 0x00	; 0
     77a:	ea e2       	ldi	r30, 0x2A	; 42
     77c:	f0 e0       	ldi	r31, 0x00	; 0
     77e:	80 81       	ld	r24, Z
     780:	84 60       	ori	r24, 0x04	; 4
     782:	8c 93       	st	X, r24
     784:	01 c0       	rjmp	.+2      	; 0x788 <UART_Init+0x202>
		if(ReturnValue==OK)
			ReturnValue=OK;
		break;
	default:
		ReturnValue=NOT_OK;
     786:	19 82       	std	Y+1, r1	; 0x01
	}
	/*enable or disable empty data register interrupt*/
	if(UART_Config.Init_Em)
     788:	80 91 dd 00 	lds	r24, 0x00DD
     78c:	88 23       	and	r24, r24
     78e:	41 f0       	breq	.+16     	; 0x7a0 <UART_Init+0x21a>
	{
		CLEAR_BIT(USART_UCSRB,InterruptEnable_UDRIE);
     790:	aa e2       	ldi	r26, 0x2A	; 42
     792:	b0 e0       	ldi	r27, 0x00	; 0
     794:	ea e2       	ldi	r30, 0x2A	; 42
     796:	f0 e0       	ldi	r31, 0x00	; 0
     798:	80 81       	ld	r24, Z
     79a:	8f 7d       	andi	r24, 0xDF	; 223
     79c:	8c 93       	st	X, r24
     79e:	0d c0       	rjmp	.+26     	; 0x7ba <UART_Init+0x234>
		if(ReturnValue==OK)
			ReturnValue=OK;
	}
	else if((UART_Config.Init_Em)==EnableEM)
     7a0:	80 91 dd 00 	lds	r24, 0x00DD
     7a4:	88 23       	and	r24, r24
     7a6:	41 f4       	brne	.+16     	; 0x7b8 <UART_Init+0x232>
	{
		SET_BIT(USART_UCSRB,InterruptEnable_UDRIE);
     7a8:	aa e2       	ldi	r26, 0x2A	; 42
     7aa:	b0 e0       	ldi	r27, 0x00	; 0
     7ac:	ea e2       	ldi	r30, 0x2A	; 42
     7ae:	f0 e0       	ldi	r31, 0x00	; 0
     7b0:	80 81       	ld	r24, Z
     7b2:	80 62       	ori	r24, 0x20	; 32
     7b4:	8c 93       	st	X, r24
     7b6:	01 c0       	rjmp	.+2      	; 0x7ba <UART_Init+0x234>
		if(ReturnValue==OK)
			ReturnValue=OK;
	}
	else
		ReturnValue=NOT_OK;
     7b8:	19 82       	std	Y+1, r1	; 0x01
	/*enable or disable transmitter interrupt*/
	if(UART_Config.Init_TX)
     7ba:	80 91 de 00 	lds	r24, 0x00DE
     7be:	88 23       	and	r24, r24
     7c0:	41 f0       	breq	.+16     	; 0x7d2 <UART_Init+0x24c>
	{
		CLEAR_BIT(USART_UCSRB,InterruptEnable_TXCIE);
     7c2:	aa e2       	ldi	r26, 0x2A	; 42
     7c4:	b0 e0       	ldi	r27, 0x00	; 0
     7c6:	ea e2       	ldi	r30, 0x2A	; 42
     7c8:	f0 e0       	ldi	r31, 0x00	; 0
     7ca:	80 81       	ld	r24, Z
     7cc:	8f 7b       	andi	r24, 0xBF	; 191
     7ce:	8c 93       	st	X, r24
     7d0:	0d c0       	rjmp	.+26     	; 0x7ec <UART_Init+0x266>
		if(ReturnValue==OK)
			ReturnValue=OK;
	}
	else if((UART_Config.Init_TX)==EnableTX)
     7d2:	80 91 de 00 	lds	r24, 0x00DE
     7d6:	88 23       	and	r24, r24
     7d8:	41 f4       	brne	.+16     	; 0x7ea <UART_Init+0x264>
	{
		SET_BIT(USART_UCSRB,InterruptEnable_TXCIE);
     7da:	aa e2       	ldi	r26, 0x2A	; 42
     7dc:	b0 e0       	ldi	r27, 0x00	; 0
     7de:	ea e2       	ldi	r30, 0x2A	; 42
     7e0:	f0 e0       	ldi	r31, 0x00	; 0
     7e2:	80 81       	ld	r24, Z
     7e4:	80 64       	ori	r24, 0x40	; 64
     7e6:	8c 93       	st	X, r24
     7e8:	01 c0       	rjmp	.+2      	; 0x7ec <UART_Init+0x266>
		if(ReturnValue==OK)
			ReturnValue=OK;
	}
	else
		ReturnValue=NOT_OK;
     7ea:	19 82       	std	Y+1, r1	; 0x01
	/*enable or disable receiver interrupt*/
	if(UART_Config.Init_RX)
     7ec:	80 91 df 00 	lds	r24, 0x00DF
     7f0:	88 23       	and	r24, r24
     7f2:	41 f0       	breq	.+16     	; 0x804 <UART_Init+0x27e>
	{
		CLEAR_BIT(USART_UCSRB,InterruptEnable_RXCIE);
     7f4:	aa e2       	ldi	r26, 0x2A	; 42
     7f6:	b0 e0       	ldi	r27, 0x00	; 0
     7f8:	ea e2       	ldi	r30, 0x2A	; 42
     7fa:	f0 e0       	ldi	r31, 0x00	; 0
     7fc:	80 81       	ld	r24, Z
     7fe:	8f 77       	andi	r24, 0x7F	; 127
     800:	8c 93       	st	X, r24
     802:	0d c0       	rjmp	.+26     	; 0x81e <UART_Init+0x298>
		if(ReturnValue==OK)
			ReturnValue=OK;
	}
	else if((UART_Config.Init_RX)==EnableRX)
     804:	80 91 df 00 	lds	r24, 0x00DF
     808:	88 23       	and	r24, r24
     80a:	41 f4       	brne	.+16     	; 0x81c <UART_Init+0x296>
	{
		SET_BIT(USART_UCSRB,InterruptEnable_RXCIE);
     80c:	aa e2       	ldi	r26, 0x2A	; 42
     80e:	b0 e0       	ldi	r27, 0x00	; 0
     810:	ea e2       	ldi	r30, 0x2A	; 42
     812:	f0 e0       	ldi	r31, 0x00	; 0
     814:	80 81       	ld	r24, Z
     816:	80 68       	ori	r24, 0x80	; 128
     818:	8c 93       	st	X, r24
     81a:	01 c0       	rjmp	.+2      	; 0x81e <UART_Init+0x298>
		if(ReturnValue==OK)
			ReturnValue=OK;
	}
	else
		ReturnValue=NOT_OK;
     81c:	19 82       	std	Y+1, r1	; 0x01
	SET_BIT(USART_UCSRB,Enable_RXEN);
     81e:	aa e2       	ldi	r26, 0x2A	; 42
     820:	b0 e0       	ldi	r27, 0x00	; 0
     822:	ea e2       	ldi	r30, 0x2A	; 42
     824:	f0 e0       	ldi	r31, 0x00	; 0
     826:	80 81       	ld	r24, Z
     828:	80 61       	ori	r24, 0x10	; 16
     82a:	8c 93       	st	X, r24
	SET_BIT(USART_UCSRB,Enable_TXEN);
     82c:	aa e2       	ldi	r26, 0x2A	; 42
     82e:	b0 e0       	ldi	r27, 0x00	; 0
     830:	ea e2       	ldi	r30, 0x2A	; 42
     832:	f0 e0       	ldi	r31, 0x00	; 0
     834:	80 81       	ld	r24, Z
     836:	88 60       	ori	r24, 0x08	; 8
     838:	8c 93       	st	X, r24
	return ReturnValue;
     83a:	89 81       	ldd	r24, Y+1	; 0x01
}
     83c:	0f 90       	pop	r0
     83e:	0f 90       	pop	r0
     840:	0f 90       	pop	r0
     842:	0f 90       	pop	r0
     844:	0f 90       	pop	r0
     846:	cf 91       	pop	r28
     848:	df 91       	pop	r29
     84a:	08 95       	ret

0000084c <UART_ReceiveChar>:
 *	                                                       				    *
 *4-this function's role is return data that is received by UART				*
 *																			*
 *****************************************************************************/
Status_t UART_ReceiveChar(uint8* a_data_ptr)
{
     84c:	df 93       	push	r29
     84e:	cf 93       	push	r28
     850:	00 d0       	rcall	.+0      	; 0x852 <UART_ReceiveChar+0x6>
     852:	00 d0       	rcall	.+0      	; 0x854 <UART_ReceiveChar+0x8>
     854:	0f 92       	push	r0
     856:	cd b7       	in	r28, 0x3d	; 61
     858:	de b7       	in	r29, 0x3e	; 62
     85a:	9d 83       	std	Y+5, r25	; 0x05
     85c:	8c 83       	std	Y+4, r24	; 0x04
	uint16 dummy;
	Status_t ReturnValue;

	/*check if pulling is selected*/
	if(!(GET_BIT(USART_UCSRB,InterruptEnable_RXCIE)))
     85e:	ea e2       	ldi	r30, 0x2A	; 42
     860:	f0 e0       	ldi	r31, 0x00	; 0
     862:	80 81       	ld	r24, Z
     864:	88 23       	and	r24, r24
     866:	2c f0       	brlt	.+10     	; 0x872 <__stack+0x13>
	{
		/*pull on receive flag*/
		while(!(GET_BIT(USART_UCSRA,Flag_RXC)));
     868:	eb e2       	ldi	r30, 0x2B	; 43
     86a:	f0 e0       	ldi	r31, 0x00	; 0
     86c:	80 81       	ld	r24, Z
     86e:	88 23       	and	r24, r24
     870:	dc f7       	brge	.-10     	; 0x868 <__stack+0x9>
	}
	/*get Data from data register of UART*/
	if(USART_UCSRA&((1<<Flag_PE)|(1<<Flag_DOR)|(1<<Flag_FE)))
     872:	eb e2       	ldi	r30, 0x2B	; 43
     874:	f0 e0       	ldi	r31, 0x00	; 0
     876:	80 81       	ld	r24, Z
     878:	88 2f       	mov	r24, r24
     87a:	90 e0       	ldi	r25, 0x00	; 0
     87c:	8c 71       	andi	r24, 0x1C	; 28
     87e:	90 70       	andi	r25, 0x00	; 0
     880:	00 97       	sbiw	r24, 0x00	; 0
     882:	49 f0       	breq	.+18     	; 0x896 <__stack+0x37>
	{
		dummy=USART_DataRegister;
     884:	ec e2       	ldi	r30, 0x2C	; 44
     886:	f0 e0       	ldi	r31, 0x00	; 0
     888:	80 81       	ld	r24, Z
     88a:	88 2f       	mov	r24, r24
     88c:	90 e0       	ldi	r25, 0x00	; 0
     88e:	9b 83       	std	Y+3, r25	; 0x03
     890:	8a 83       	std	Y+2, r24	; 0x02
		ReturnValue=NOT_OK;
     892:	19 82       	std	Y+1, r1	; 0x01
     894:	08 c0       	rjmp	.+16     	; 0x8a6 <__stack+0x47>
	}
	else
	{
		*a_data_ptr=USART_DataRegister;
     896:	ec e2       	ldi	r30, 0x2C	; 44
     898:	f0 e0       	ldi	r31, 0x00	; 0
     89a:	80 81       	ld	r24, Z
     89c:	ec 81       	ldd	r30, Y+4	; 0x04
     89e:	fd 81       	ldd	r31, Y+5	; 0x05
     8a0:	80 83       	st	Z, r24
		ReturnValue=OK;
     8a2:	81 e0       	ldi	r24, 0x01	; 1
     8a4:	89 83       	std	Y+1, r24	; 0x01
	}
	return ReturnValue;
     8a6:	89 81       	ldd	r24, Y+1	; 0x01
}
     8a8:	0f 90       	pop	r0
     8aa:	0f 90       	pop	r0
     8ac:	0f 90       	pop	r0
     8ae:	0f 90       	pop	r0
     8b0:	0f 90       	pop	r0
     8b2:	cf 91       	pop	r28
     8b4:	df 91       	pop	r29
     8b6:	08 95       	ret

000008b8 <UART_SendChar>:
 *	                                                       				    *
 *4-this function's role is send data from user by UART						*
 *																			*
 *****************************************************************************/
Status_t UART_SendChar(uint8 a_data)
{
     8b8:	df 93       	push	r29
     8ba:	cf 93       	push	r28
     8bc:	00 d0       	rcall	.+0      	; 0x8be <UART_SendChar+0x6>
     8be:	cd b7       	in	r28, 0x3d	; 61
     8c0:	de b7       	in	r29, 0x3e	; 62
     8c2:	8a 83       	std	Y+2, r24	; 0x02
	Status_t ReturnValue;
	/*check if pulling is selected*/
	if(!(GET_BIT(USART_UCSRB,InterruptEnable_UDRIE)))
     8c4:	ea e2       	ldi	r30, 0x2A	; 42
     8c6:	f0 e0       	ldi	r31, 0x00	; 0
     8c8:	80 81       	ld	r24, Z
     8ca:	82 95       	swap	r24
     8cc:	86 95       	lsr	r24
     8ce:	87 70       	andi	r24, 0x07	; 7
     8d0:	88 2f       	mov	r24, r24
     8d2:	90 e0       	ldi	r25, 0x00	; 0
     8d4:	81 70       	andi	r24, 0x01	; 1
     8d6:	90 70       	andi	r25, 0x00	; 0
     8d8:	00 97       	sbiw	r24, 0x00	; 0
     8da:	61 f4       	brne	.+24     	; 0x8f4 <UART_SendChar+0x3c>
		/*pull on empty Data register flag*/
		while(!(GET_BIT(USART_UCSRA,Flag_UDRE)));
     8dc:	eb e2       	ldi	r30, 0x2B	; 43
     8de:	f0 e0       	ldi	r31, 0x00	; 0
     8e0:	80 81       	ld	r24, Z
     8e2:	82 95       	swap	r24
     8e4:	86 95       	lsr	r24
     8e6:	87 70       	andi	r24, 0x07	; 7
     8e8:	88 2f       	mov	r24, r24
     8ea:	90 e0       	ldi	r25, 0x00	; 0
     8ec:	81 70       	andi	r24, 0x01	; 1
     8ee:	90 70       	andi	r25, 0x00	; 0
     8f0:	00 97       	sbiw	r24, 0x00	; 0
     8f2:	a1 f3       	breq	.-24     	; 0x8dc <UART_SendChar+0x24>
	/*put Data on data register of UART*/
	if(GET_BIT(USART_UCSRB,Enable_TXEN))
     8f4:	ea e2       	ldi	r30, 0x2A	; 42
     8f6:	f0 e0       	ldi	r31, 0x00	; 0
     8f8:	80 81       	ld	r24, Z
     8fa:	86 95       	lsr	r24
     8fc:	86 95       	lsr	r24
     8fe:	86 95       	lsr	r24
     900:	88 2f       	mov	r24, r24
     902:	90 e0       	ldi	r25, 0x00	; 0
     904:	81 70       	andi	r24, 0x01	; 1
     906:	90 70       	andi	r25, 0x00	; 0
     908:	88 23       	and	r24, r24
     90a:	39 f0       	breq	.+14     	; 0x91a <UART_SendChar+0x62>
	{
		USART_DataRegister=a_data;
     90c:	ec e2       	ldi	r30, 0x2C	; 44
     90e:	f0 e0       	ldi	r31, 0x00	; 0
     910:	8a 81       	ldd	r24, Y+2	; 0x02
     912:	80 83       	st	Z, r24
		ReturnValue=OK;
     914:	81 e0       	ldi	r24, 0x01	; 1
     916:	89 83       	std	Y+1, r24	; 0x01
     918:	01 c0       	rjmp	.+2      	; 0x91c <UART_SendChar+0x64>
	}
	else
		ReturnValue=NOT_OK;
     91a:	19 82       	std	Y+1, r1	; 0x01
	return ReturnValue;
     91c:	89 81       	ldd	r24, Y+1	; 0x01
}
     91e:	0f 90       	pop	r0
     920:	0f 90       	pop	r0
     922:	cf 91       	pop	r28
     924:	df 91       	pop	r29
     926:	08 95       	ret

00000928 <UART_Receive>:
 *	                                                       				    *
 *4-this function's role is return string that is received by UART			*
 *																			*
 *****************************************************************************/
Status_t UART_Receive( uint8* const a_data_ptr)
{
     928:	df 93       	push	r29
     92a:	cf 93       	push	r28
     92c:	00 d0       	rcall	.+0      	; 0x92e <UART_Receive+0x6>
     92e:	00 d0       	rcall	.+0      	; 0x930 <UART_Receive+0x8>
     930:	0f 92       	push	r0
     932:	cd b7       	in	r28, 0x3d	; 61
     934:	de b7       	in	r29, 0x3e	; 62
     936:	9c 83       	std	Y+4, r25	; 0x04
     938:	8b 83       	std	Y+3, r24	; 0x03
	Status_t ReturnValue;
	/*Loop to Receive string by UART*/
	for(uint8 Count=0;a_data_ptr[Count-1]!='\0';Count++)
     93a:	19 82       	std	Y+1, r1	; 0x01
     93c:	13 c0       	rjmp	.+38     	; 0x964 <UART_Receive+0x3c>
	{
		ReturnValue=UART_ReceiveChar(&(a_data_ptr[Count]));
     93e:	89 81       	ldd	r24, Y+1	; 0x01
     940:	28 2f       	mov	r18, r24
     942:	30 e0       	ldi	r19, 0x00	; 0
     944:	8b 81       	ldd	r24, Y+3	; 0x03
     946:	9c 81       	ldd	r25, Y+4	; 0x04
     948:	82 0f       	add	r24, r18
     94a:	93 1f       	adc	r25, r19
     94c:	0e 94 26 04 	call	0x84c	; 0x84c <UART_ReceiveChar>
     950:	8a 83       	std	Y+2, r24	; 0x02
		if(!(ReturnValue))
     952:	8a 81       	ldd	r24, Y+2	; 0x02
     954:	88 23       	and	r24, r24
     956:	19 f4       	brne	.+6      	; 0x95e <UART_Receive+0x36>
			return ReturnValue;
     958:	8a 81       	ldd	r24, Y+2	; 0x02
     95a:	8d 83       	std	Y+5, r24	; 0x05
     95c:	13 c0       	rjmp	.+38     	; 0x984 <UART_Receive+0x5c>
 *****************************************************************************/
Status_t UART_Receive( uint8* const a_data_ptr)
{
	Status_t ReturnValue;
	/*Loop to Receive string by UART*/
	for(uint8 Count=0;a_data_ptr[Count-1]!='\0';Count++)
     95e:	89 81       	ldd	r24, Y+1	; 0x01
     960:	8f 5f       	subi	r24, 0xFF	; 255
     962:	89 83       	std	Y+1, r24	; 0x01
     964:	89 81       	ldd	r24, Y+1	; 0x01
     966:	88 2f       	mov	r24, r24
     968:	90 e0       	ldi	r25, 0x00	; 0
     96a:	9c 01       	movw	r18, r24
     96c:	21 50       	subi	r18, 0x01	; 1
     96e:	30 40       	sbci	r19, 0x00	; 0
     970:	8b 81       	ldd	r24, Y+3	; 0x03
     972:	9c 81       	ldd	r25, Y+4	; 0x04
     974:	fc 01       	movw	r30, r24
     976:	e2 0f       	add	r30, r18
     978:	f3 1f       	adc	r31, r19
     97a:	80 81       	ld	r24, Z
     97c:	88 23       	and	r24, r24
     97e:	f9 f6       	brne	.-66     	; 0x93e <UART_Receive+0x16>
	{
		ReturnValue=UART_ReceiveChar(&(a_data_ptr[Count]));
		if(!(ReturnValue))
			return ReturnValue;
	}
	return ReturnValue;
     980:	8a 81       	ldd	r24, Y+2	; 0x02
     982:	8d 83       	std	Y+5, r24	; 0x05
     984:	8d 81       	ldd	r24, Y+5	; 0x05
}
     986:	0f 90       	pop	r0
     988:	0f 90       	pop	r0
     98a:	0f 90       	pop	r0
     98c:	0f 90       	pop	r0
     98e:	0f 90       	pop	r0
     990:	cf 91       	pop	r28
     992:	df 91       	pop	r29
     994:	08 95       	ret

00000996 <UART_Send>:
 *	                                                       				    *
 *4-this function's role is send string from user by UART					*
 *																			*
 *****************************************************************************/
Status_t UART_Send(uint8* a_data_ptr)
{
     996:	df 93       	push	r29
     998:	cf 93       	push	r28
     99a:	00 d0       	rcall	.+0      	; 0x99c <UART_Send+0x6>
     99c:	00 d0       	rcall	.+0      	; 0x99e <UART_Send+0x8>
     99e:	0f 92       	push	r0
     9a0:	cd b7       	in	r28, 0x3d	; 61
     9a2:	de b7       	in	r29, 0x3e	; 62
     9a4:	9c 83       	std	Y+4, r25	; 0x04
     9a6:	8b 83       	std	Y+3, r24	; 0x03
	Status_t ReturnValue;
	/*Loop on string to send by UART*/
	for(uint8 Count=0;a_data_ptr[Count]!='\0';Count++)
     9a8:	19 82       	std	Y+1, r1	; 0x01
     9aa:	15 c0       	rjmp	.+42     	; 0x9d6 <UART_Send+0x40>
	{
		ReturnValue=UART_SendChar((a_data_ptr[Count]));
     9ac:	89 81       	ldd	r24, Y+1	; 0x01
     9ae:	28 2f       	mov	r18, r24
     9b0:	30 e0       	ldi	r19, 0x00	; 0
     9b2:	8b 81       	ldd	r24, Y+3	; 0x03
     9b4:	9c 81       	ldd	r25, Y+4	; 0x04
     9b6:	fc 01       	movw	r30, r24
     9b8:	e2 0f       	add	r30, r18
     9ba:	f3 1f       	adc	r31, r19
     9bc:	80 81       	ld	r24, Z
     9be:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <UART_SendChar>
     9c2:	8a 83       	std	Y+2, r24	; 0x02
		if(!(ReturnValue))
     9c4:	8a 81       	ldd	r24, Y+2	; 0x02
     9c6:	88 23       	and	r24, r24
     9c8:	19 f4       	brne	.+6      	; 0x9d0 <UART_Send+0x3a>
			return ReturnValue;
     9ca:	8a 81       	ldd	r24, Y+2	; 0x02
     9cc:	8d 83       	std	Y+5, r24	; 0x05
     9ce:	10 c0       	rjmp	.+32     	; 0x9f0 <UART_Send+0x5a>
 *****************************************************************************/
Status_t UART_Send(uint8* a_data_ptr)
{
	Status_t ReturnValue;
	/*Loop on string to send by UART*/
	for(uint8 Count=0;a_data_ptr[Count]!='\0';Count++)
     9d0:	89 81       	ldd	r24, Y+1	; 0x01
     9d2:	8f 5f       	subi	r24, 0xFF	; 255
     9d4:	89 83       	std	Y+1, r24	; 0x01
     9d6:	89 81       	ldd	r24, Y+1	; 0x01
     9d8:	28 2f       	mov	r18, r24
     9da:	30 e0       	ldi	r19, 0x00	; 0
     9dc:	8b 81       	ldd	r24, Y+3	; 0x03
     9de:	9c 81       	ldd	r25, Y+4	; 0x04
     9e0:	fc 01       	movw	r30, r24
     9e2:	e2 0f       	add	r30, r18
     9e4:	f3 1f       	adc	r31, r19
     9e6:	80 81       	ld	r24, Z
     9e8:	88 23       	and	r24, r24
     9ea:	01 f7       	brne	.-64     	; 0x9ac <UART_Send+0x16>
	{
		ReturnValue=UART_SendChar((a_data_ptr[Count]));
		if(!(ReturnValue))
			return ReturnValue;
	}
	return ReturnValue;
     9ec:	8a 81       	ldd	r24, Y+2	; 0x02
     9ee:	8d 83       	std	Y+5, r24	; 0x05
     9f0:	8d 81       	ldd	r24, Y+5	; 0x05
}
     9f2:	0f 90       	pop	r0
     9f4:	0f 90       	pop	r0
     9f6:	0f 90       	pop	r0
     9f8:	0f 90       	pop	r0
     9fa:	0f 90       	pop	r0
     9fc:	cf 91       	pop	r28
     9fe:	df 91       	pop	r29
     a00:	08 95       	ret

00000a02 <UART_StartComm>:
 *4-this function's role is starting UART communication_		*
 *  by Set Enable Bits for receive and transmit.				*
 *																*
 * **************************************************************/
Status_t UART_StartComm(void)
{
     a02:	df 93       	push	r29
     a04:	cf 93       	push	r28
     a06:	0f 92       	push	r0
     a08:	cd b7       	in	r28, 0x3d	; 61
     a0a:	de b7       	in	r29, 0x3e	; 62
	Status_t ReturnValue;
	SET_BIT(USART_UCSRB,Enable_TXEN);
     a0c:	aa e2       	ldi	r26, 0x2A	; 42
     a0e:	b0 e0       	ldi	r27, 0x00	; 0
     a10:	ea e2       	ldi	r30, 0x2A	; 42
     a12:	f0 e0       	ldi	r31, 0x00	; 0
     a14:	80 81       	ld	r24, Z
     a16:	88 60       	ori	r24, 0x08	; 8
     a18:	8c 93       	st	X, r24
	SET_BIT(USART_UCSRB,Enable_RXEN);
     a1a:	aa e2       	ldi	r26, 0x2A	; 42
     a1c:	b0 e0       	ldi	r27, 0x00	; 0
     a1e:	ea e2       	ldi	r30, 0x2A	; 42
     a20:	f0 e0       	ldi	r31, 0x00	; 0
     a22:	80 81       	ld	r24, Z
     a24:	80 61       	ori	r24, 0x10	; 16
     a26:	8c 93       	st	X, r24
	if((GET_BIT(USART_UCSRB,Enable_TXEN)))
     a28:	ea e2       	ldi	r30, 0x2A	; 42
     a2a:	f0 e0       	ldi	r31, 0x00	; 0
     a2c:	80 81       	ld	r24, Z
     a2e:	86 95       	lsr	r24
     a30:	86 95       	lsr	r24
     a32:	86 95       	lsr	r24
     a34:	88 2f       	mov	r24, r24
     a36:	90 e0       	ldi	r25, 0x00	; 0
     a38:	81 70       	andi	r24, 0x01	; 1
     a3a:	90 70       	andi	r25, 0x00	; 0
     a3c:	88 23       	and	r24, r24
     a3e:	81 f0       	breq	.+32     	; 0xa60 <UART_StartComm+0x5e>
	{
		if((GET_BIT(USART_UCSRB,Enable_RXEN)))
     a40:	ea e2       	ldi	r30, 0x2A	; 42
     a42:	f0 e0       	ldi	r31, 0x00	; 0
     a44:	80 81       	ld	r24, Z
     a46:	82 95       	swap	r24
     a48:	8f 70       	andi	r24, 0x0F	; 15
     a4a:	88 2f       	mov	r24, r24
     a4c:	90 e0       	ldi	r25, 0x00	; 0
     a4e:	81 70       	andi	r24, 0x01	; 1
     a50:	90 70       	andi	r25, 0x00	; 0
     a52:	88 23       	and	r24, r24
     a54:	19 f0       	breq	.+6      	; 0xa5c <UART_StartComm+0x5a>
			ReturnValue=OK;
     a56:	81 e0       	ldi	r24, 0x01	; 1
     a58:	89 83       	std	Y+1, r24	; 0x01
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <UART_StartComm+0x60>
		else
			ReturnValue=NOT_OK;
     a5c:	19 82       	std	Y+1, r1	; 0x01
     a5e:	01 c0       	rjmp	.+2      	; 0xa62 <UART_StartComm+0x60>
	}
	else
		ReturnValue=NOT_OK;
     a60:	19 82       	std	Y+1, r1	; 0x01
	return ReturnValue;
     a62:	89 81       	ldd	r24, Y+1	; 0x01

}
     a64:	0f 90       	pop	r0
     a66:	cf 91       	pop	r28
     a68:	df 91       	pop	r29
     a6a:	08 95       	ret

00000a6c <UART_StopComm>:
 *4-this function's role is stopping UART communication_		*
 *  by Clear Enable Bits for receive and transmit.				*
 *																*
 * **************************************************************/
Status_t UART_StopComm(void)
{
     a6c:	df 93       	push	r29
     a6e:	cf 93       	push	r28
     a70:	0f 92       	push	r0
     a72:	cd b7       	in	r28, 0x3d	; 61
     a74:	de b7       	in	r29, 0x3e	; 62
	Status_t ReturnValue;
	while((GET_BIT(USART_UCSRA,Flag_UDRE))==0);
     a76:	eb e2       	ldi	r30, 0x2B	; 43
     a78:	f0 e0       	ldi	r31, 0x00	; 0
     a7a:	80 81       	ld	r24, Z
     a7c:	82 95       	swap	r24
     a7e:	86 95       	lsr	r24
     a80:	87 70       	andi	r24, 0x07	; 7
     a82:	88 2f       	mov	r24, r24
     a84:	90 e0       	ldi	r25, 0x00	; 0
     a86:	81 70       	andi	r24, 0x01	; 1
     a88:	90 70       	andi	r25, 0x00	; 0
     a8a:	00 97       	sbiw	r24, 0x00	; 0
     a8c:	a1 f3       	breq	.-24     	; 0xa76 <UART_StopComm+0xa>
	CLEAR_BIT(USART_UCSRB,Enable_TXEN);
     a8e:	aa e2       	ldi	r26, 0x2A	; 42
     a90:	b0 e0       	ldi	r27, 0x00	; 0
     a92:	ea e2       	ldi	r30, 0x2A	; 42
     a94:	f0 e0       	ldi	r31, 0x00	; 0
     a96:	80 81       	ld	r24, Z
     a98:	87 7f       	andi	r24, 0xF7	; 247
     a9a:	8c 93       	st	X, r24
	CLEAR_BIT(USART_UCSRB,Enable_RXEN);
     a9c:	aa e2       	ldi	r26, 0x2A	; 42
     a9e:	b0 e0       	ldi	r27, 0x00	; 0
     aa0:	ea e2       	ldi	r30, 0x2A	; 42
     aa2:	f0 e0       	ldi	r31, 0x00	; 0
     aa4:	80 81       	ld	r24, Z
     aa6:	8f 7e       	andi	r24, 0xEF	; 239
     aa8:	8c 93       	st	X, r24
	CLEAR_BIT(USART_UCSRB,InterruptEnable_UDRIE);
     aaa:	aa e2       	ldi	r26, 0x2A	; 42
     aac:	b0 e0       	ldi	r27, 0x00	; 0
     aae:	ea e2       	ldi	r30, 0x2A	; 42
     ab0:	f0 e0       	ldi	r31, 0x00	; 0
     ab2:	80 81       	ld	r24, Z
     ab4:	8f 7d       	andi	r24, 0xDF	; 223
     ab6:	8c 93       	st	X, r24
	CLEAR_BIT(USART_UCSRB,InterruptEnable_TXCIE);
     ab8:	aa e2       	ldi	r26, 0x2A	; 42
     aba:	b0 e0       	ldi	r27, 0x00	; 0
     abc:	ea e2       	ldi	r30, 0x2A	; 42
     abe:	f0 e0       	ldi	r31, 0x00	; 0
     ac0:	80 81       	ld	r24, Z
     ac2:	8f 7b       	andi	r24, 0xBF	; 191
     ac4:	8c 93       	st	X, r24
	CLEAR_BIT(USART_UCSRB,InterruptEnable_RXCIE);
     ac6:	aa e2       	ldi	r26, 0x2A	; 42
     ac8:	b0 e0       	ldi	r27, 0x00	; 0
     aca:	ea e2       	ldi	r30, 0x2A	; 42
     acc:	f0 e0       	ldi	r31, 0x00	; 0
     ace:	80 81       	ld	r24, Z
     ad0:	8f 77       	andi	r24, 0x7F	; 127
     ad2:	8c 93       	st	X, r24
	if(!(GET_BIT(USART_UCSRB,Enable_TXEN)))
     ad4:	ea e2       	ldi	r30, 0x2A	; 42
     ad6:	f0 e0       	ldi	r31, 0x00	; 0
     ad8:	80 81       	ld	r24, Z
     ada:	86 95       	lsr	r24
     adc:	86 95       	lsr	r24
     ade:	86 95       	lsr	r24
     ae0:	88 2f       	mov	r24, r24
     ae2:	90 e0       	ldi	r25, 0x00	; 0
     ae4:	81 70       	andi	r24, 0x01	; 1
     ae6:	90 70       	andi	r25, 0x00	; 0
     ae8:	00 97       	sbiw	r24, 0x00	; 0
     aea:	81 f4       	brne	.+32     	; 0xb0c <UART_StopComm+0xa0>
	{
		if(!(GET_BIT(USART_UCSRB,Enable_RXEN)))
     aec:	ea e2       	ldi	r30, 0x2A	; 42
     aee:	f0 e0       	ldi	r31, 0x00	; 0
     af0:	80 81       	ld	r24, Z
     af2:	82 95       	swap	r24
     af4:	8f 70       	andi	r24, 0x0F	; 15
     af6:	88 2f       	mov	r24, r24
     af8:	90 e0       	ldi	r25, 0x00	; 0
     afa:	81 70       	andi	r24, 0x01	; 1
     afc:	90 70       	andi	r25, 0x00	; 0
     afe:	00 97       	sbiw	r24, 0x00	; 0
     b00:	19 f4       	brne	.+6      	; 0xb08 <UART_StopComm+0x9c>
			ReturnValue=OK;
     b02:	81 e0       	ldi	r24, 0x01	; 1
     b04:	89 83       	std	Y+1, r24	; 0x01
     b06:	03 c0       	rjmp	.+6      	; 0xb0e <UART_StopComm+0xa2>
		else
			ReturnValue=NOT_OK;
     b08:	19 82       	std	Y+1, r1	; 0x01
     b0a:	01 c0       	rjmp	.+2      	; 0xb0e <UART_StopComm+0xa2>
	}
	else
		ReturnValue=NOT_OK;
     b0c:	19 82       	std	Y+1, r1	; 0x01
	return ReturnValue;
     b0e:	89 81       	ldd	r24, Y+1	; 0x01
}
     b10:	0f 90       	pop	r0
     b12:	cf 91       	pop	r28
     b14:	df 91       	pop	r29
     b16:	08 95       	ret

00000b18 <UART_EmptyRegisterInterrupt>:
 *4-this function's role enable or disable empty register		*
 *interrupt.													*
 *																*
 * **************************************************************/
Status_t UART_EmptyRegisterInterrupt(void)
{
     b18:	df 93       	push	r29
     b1a:	cf 93       	push	r28
     b1c:	0f 92       	push	r0
     b1e:	cd b7       	in	r28, 0x3d	; 61
     b20:	de b7       	in	r29, 0x3e	; 62
	Status_t ReturnValue=NOT_OK;
     b22:	19 82       	std	Y+1, r1	; 0x01
	/*enable or disable empty data register interrupt*/
	if(UART_Config.Init_Em)
     b24:	80 91 dd 00 	lds	r24, 0x00DD
     b28:	88 23       	and	r24, r24
     b2a:	41 f0       	breq	.+16     	; 0xb3c <UART_EmptyRegisterInterrupt+0x24>
	{
		CLEAR_BIT(USART_UCSRB,InterruptEnable_UDRIE);
     b2c:	aa e2       	ldi	r26, 0x2A	; 42
     b2e:	b0 e0       	ldi	r27, 0x00	; 0
     b30:	ea e2       	ldi	r30, 0x2A	; 42
     b32:	f0 e0       	ldi	r31, 0x00	; 0
     b34:	80 81       	ld	r24, Z
     b36:	8f 7d       	andi	r24, 0xDF	; 223
     b38:	8c 93       	st	X, r24
     b3a:	0d c0       	rjmp	.+26     	; 0xb56 <UART_EmptyRegisterInterrupt+0x3e>
		if(ReturnValue==OK)
			ReturnValue=OK;
	}
	else if((UART_Config.Init_Em)==EnableEM)
     b3c:	80 91 dd 00 	lds	r24, 0x00DD
     b40:	88 23       	and	r24, r24
     b42:	41 f4       	brne	.+16     	; 0xb54 <UART_EmptyRegisterInterrupt+0x3c>
	{
		SET_BIT(USART_UCSRB,InterruptEnable_UDRIE);
     b44:	aa e2       	ldi	r26, 0x2A	; 42
     b46:	b0 e0       	ldi	r27, 0x00	; 0
     b48:	ea e2       	ldi	r30, 0x2A	; 42
     b4a:	f0 e0       	ldi	r31, 0x00	; 0
     b4c:	80 81       	ld	r24, Z
     b4e:	80 62       	ori	r24, 0x20	; 32
     b50:	8c 93       	st	X, r24
     b52:	01 c0       	rjmp	.+2      	; 0xb56 <UART_EmptyRegisterInterrupt+0x3e>
		if(ReturnValue==OK)
			ReturnValue=OK;
	}
	else
		ReturnValue=NOT_OK;
     b54:	19 82       	std	Y+1, r1	; 0x01
	return ReturnValue;
     b56:	89 81       	ldd	r24, Y+1	; 0x01
}
     b58:	0f 90       	pop	r0
     b5a:	cf 91       	pop	r28
     b5c:	df 91       	pop	r29
     b5e:	08 95       	ret

00000b60 <UART_ReceiveInterrupt>:
 *	                                                            *
 *4-this function's role enable or disable receive interrupt.	*													*
 *																*
 * **************************************************************/
Status_t UART_ReceiveInterrupt(void)
{
     b60:	df 93       	push	r29
     b62:	cf 93       	push	r28
     b64:	0f 92       	push	r0
     b66:	cd b7       	in	r28, 0x3d	; 61
     b68:	de b7       	in	r29, 0x3e	; 62
	Status_t ReturnValue=NOT_OK;
     b6a:	19 82       	std	Y+1, r1	; 0x01
	/*enable or disable receiver interrupt*/
	if(UART_Config.Init_RX)
     b6c:	80 91 df 00 	lds	r24, 0x00DF
     b70:	88 23       	and	r24, r24
     b72:	41 f0       	breq	.+16     	; 0xb84 <UART_ReceiveInterrupt+0x24>
	{
		CLEAR_BIT(USART_UCSRB,InterruptEnable_RXCIE);
     b74:	aa e2       	ldi	r26, 0x2A	; 42
     b76:	b0 e0       	ldi	r27, 0x00	; 0
     b78:	ea e2       	ldi	r30, 0x2A	; 42
     b7a:	f0 e0       	ldi	r31, 0x00	; 0
     b7c:	80 81       	ld	r24, Z
     b7e:	8f 77       	andi	r24, 0x7F	; 127
     b80:	8c 93       	st	X, r24
     b82:	0d c0       	rjmp	.+26     	; 0xb9e <UART_ReceiveInterrupt+0x3e>
		if(ReturnValue==OK)
			ReturnValue=OK;
	}
	else if((UART_Config.Init_RX)==EnableRX)
     b84:	80 91 df 00 	lds	r24, 0x00DF
     b88:	88 23       	and	r24, r24
     b8a:	41 f4       	brne	.+16     	; 0xb9c <UART_ReceiveInterrupt+0x3c>
	{
		SET_BIT(USART_UCSRB,InterruptEnable_RXCIE);
     b8c:	aa e2       	ldi	r26, 0x2A	; 42
     b8e:	b0 e0       	ldi	r27, 0x00	; 0
     b90:	ea e2       	ldi	r30, 0x2A	; 42
     b92:	f0 e0       	ldi	r31, 0x00	; 0
     b94:	80 81       	ld	r24, Z
     b96:	80 68       	ori	r24, 0x80	; 128
     b98:	8c 93       	st	X, r24
     b9a:	01 c0       	rjmp	.+2      	; 0xb9e <UART_ReceiveInterrupt+0x3e>
		if(ReturnValue==OK)
			ReturnValue=OK;
	}
	else
		ReturnValue=NOT_OK;
     b9c:	19 82       	std	Y+1, r1	; 0x01
	return ReturnValue;
     b9e:	89 81       	ldd	r24, Y+1	; 0x01
}
     ba0:	0f 90       	pop	r0
     ba2:	cf 91       	pop	r28
     ba4:	df 91       	pop	r29
     ba6:	08 95       	ret

00000ba8 <UART_transmitInterrupt>:
 *	                                                            *
 *4-this function's role enable or disable transmit interrupt.	*													*
 *																*
 * **************************************************************/
Status_t UART_transmitInterrupt(void)
{
     ba8:	df 93       	push	r29
     baa:	cf 93       	push	r28
     bac:	0f 92       	push	r0
     bae:	cd b7       	in	r28, 0x3d	; 61
     bb0:	de b7       	in	r29, 0x3e	; 62
	Status_t ReturnValue=NOT_OK;
     bb2:	19 82       	std	Y+1, r1	; 0x01
	/*enable or disable transmitter interrupt*/
		if(UART_Config.Init_TX)
     bb4:	80 91 de 00 	lds	r24, 0x00DE
     bb8:	88 23       	and	r24, r24
     bba:	41 f0       	breq	.+16     	; 0xbcc <UART_transmitInterrupt+0x24>
		{
			CLEAR_BIT(USART_UCSRB,InterruptEnable_TXCIE);
     bbc:	aa e2       	ldi	r26, 0x2A	; 42
     bbe:	b0 e0       	ldi	r27, 0x00	; 0
     bc0:	ea e2       	ldi	r30, 0x2A	; 42
     bc2:	f0 e0       	ldi	r31, 0x00	; 0
     bc4:	80 81       	ld	r24, Z
     bc6:	8f 7b       	andi	r24, 0xBF	; 191
     bc8:	8c 93       	st	X, r24
     bca:	0d c0       	rjmp	.+26     	; 0xbe6 <UART_transmitInterrupt+0x3e>
			if(ReturnValue==OK)
				ReturnValue=OK;
		}
		else if((UART_Config.Init_TX)==EnableTX)
     bcc:	80 91 de 00 	lds	r24, 0x00DE
     bd0:	88 23       	and	r24, r24
     bd2:	41 f4       	brne	.+16     	; 0xbe4 <UART_transmitInterrupt+0x3c>
		{
			SET_BIT(USART_UCSRB,InterruptEnable_TXCIE);
     bd4:	aa e2       	ldi	r26, 0x2A	; 42
     bd6:	b0 e0       	ldi	r27, 0x00	; 0
     bd8:	ea e2       	ldi	r30, 0x2A	; 42
     bda:	f0 e0       	ldi	r31, 0x00	; 0
     bdc:	80 81       	ld	r24, Z
     bde:	80 64       	ori	r24, 0x40	; 64
     be0:	8c 93       	st	X, r24
     be2:	01 c0       	rjmp	.+2      	; 0xbe6 <UART_transmitInterrupt+0x3e>
			if(ReturnValue==OK)
				ReturnValue=OK;
		}
		else
			ReturnValue=NOT_OK;
     be4:	19 82       	std	Y+1, r1	; 0x01
	return ReturnValue;
     be6:	89 81       	ldd	r24, Y+1	; 0x01
}
     be8:	0f 90       	pop	r0
     bea:	cf 91       	pop	r28
     bec:	df 91       	pop	r29
     bee:	08 95       	ret

00000bf0 <init_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void init_Task(void * a_Task_ptr)
{
     bf0:	ef 92       	push	r14
     bf2:	ff 92       	push	r15
     bf4:	0f 93       	push	r16
     bf6:	df 93       	push	r29
     bf8:	cf 93       	push	r28
     bfa:	00 d0       	rcall	.+0      	; 0xbfc <init_Task+0xc>
     bfc:	cd b7       	in	r28, 0x3d	; 61
     bfe:	de b7       	in	r29, 0x3e	; 62
     c00:	9a 83       	std	Y+2, r25	; 0x02
     c02:	89 83       	std	Y+1, r24	; 0x01
	/*initialize all HW and preipherals*/
	PushButton_Init();
     c04:	0e 94 99 02 	call	0x532	; 0x532 <PushButton_Init>
	UART_Init();
     c08:	0e 94 c3 02 	call	0x586	; 0x586 <UART_Init>
	KeyPad_Init();
     c0c:	0e 94 ed 0c 	call	0x19da	; 0x19da <KeyPad_Init>
	LCD_init();
     c10:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <LCD_init>
	DIO_SetPinDirection(DIO_PIN12,OUTPUT);
     c14:	8c e0       	ldi	r24, 0x0C	; 12
     c16:	61 e0       	ldi	r22, 0x01	; 1
     c18:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
	DIO_SetPinDirection(DIO_PIN13,OUTPUT);
     c1c:	8d e0       	ldi	r24, 0x0D	; 13
     c1e:	61 e0       	ldi	r22, 0x01	; 1
     c20:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>

	/*Create Queues*/
	Queue_PushButton = xQueueCreate( 3 , sizeof(uint8) );
     c24:	83 e0       	ldi	r24, 0x03	; 3
     c26:	61 e0       	ldi	r22, 0x01	; 1
     c28:	40 e0       	ldi	r20, 0x00	; 0
     c2a:	0e 94 5d 14 	call	0x28ba	; 0x28ba <xQueueGenericCreate>
     c2e:	90 93 e9 00 	sts	0x00E9, r25
     c32:	80 93 e8 00 	sts	0x00E8, r24
	Queue_Keypad_Task = xQueueCreate( 3 , sizeof(uint8) );
     c36:	83 e0       	ldi	r24, 0x03	; 3
     c38:	61 e0       	ldi	r22, 0x01	; 1
     c3a:	40 e0       	ldi	r20, 0x00	; 0
     c3c:	0e 94 5d 14 	call	0x28ba	; 0x28ba <xQueueGenericCreate>
     c40:	90 93 ed 00 	sts	0x00ED, r25
     c44:	80 93 ec 00 	sts	0x00EC, r24
	Queue_ReceivedUART_Task = xQueueCreate( 3 , sizeof(uint8) );
     c48:	83 e0       	ldi	r24, 0x03	; 3
     c4a:	61 e0       	ldi	r22, 0x01	; 1
     c4c:	40 e0       	ldi	r20, 0x00	; 0
     c4e:	0e 94 5d 14 	call	0x28ba	; 0x28ba <xQueueGenericCreate>
     c52:	90 93 eb 00 	sts	0x00EB, r25
     c56:	80 93 ea 00 	sts	0x00EA, r24

	/*Create 5 Tasks*/
	/*create Push Button task to reset LCD*/
	xTaskCreate(PushButton_Task  , "PushButton_Task" , 100 ,
     c5a:	81 e8       	ldi	r24, 0x81	; 129
     c5c:	96 e0       	ldi	r25, 0x06	; 6
     c5e:	20 e6       	ldi	r18, 0x60	; 96
     c60:	30 e0       	ldi	r19, 0x00	; 0
     c62:	b9 01       	movw	r22, r18
     c64:	44 e6       	ldi	r20, 0x64	; 100
     c66:	50 e0       	ldi	r21, 0x00	; 0
     c68:	20 e0       	ldi	r18, 0x00	; 0
     c6a:	30 e0       	ldi	r19, 0x00	; 0
     c6c:	01 e0       	ldi	r16, 0x01	; 1
     c6e:	ee 24       	eor	r14, r14
     c70:	ff 24       	eor	r15, r15
     c72:	0e 94 8d 22 	call	0x451a	; 0x451a <xTaskCreate>
			NULL , (1 | portPRIVILEGE_BIT) , NULL);

	/*create UART Task to receive Data by UART*/
	xTaskCreate(UART_Task  , "UART_Task" , configMINIMAL_STACK_SIZE ,
     c76:	81 e7       	ldi	r24, 0x71	; 113
     c78:	98 e0       	ldi	r25, 0x08	; 8
     c7a:	20 e7       	ldi	r18, 0x70	; 112
     c7c:	30 e0       	ldi	r19, 0x00	; 0
     c7e:	b9 01       	movw	r22, r18
     c80:	46 e9       	ldi	r20, 0x96	; 150
     c82:	50 e0       	ldi	r21, 0x00	; 0
     c84:	20 e0       	ldi	r18, 0x00	; 0
     c86:	30 e0       	ldi	r19, 0x00	; 0
     c88:	03 e0       	ldi	r16, 0x03	; 3
     c8a:	ee 24       	eor	r14, r14
     c8c:	ff 24       	eor	r15, r15
     c8e:	0e 94 8d 22 	call	0x451a	; 0x451a <xTaskCreate>
			NULL , (3 | portPRIVILEGE_BIT) , NULL);

	/*create Keypad task to read temperature sensor*/
	xTaskCreate(KeyPad_Task  , "KeyPad_Task" , configMINIMAL_STACK_SIZE ,
     c92:	86 e1       	ldi	r24, 0x16	; 22
     c94:	97 e0       	ldi	r25, 0x07	; 7
     c96:	2a e7       	ldi	r18, 0x7A	; 122
     c98:	30 e0       	ldi	r19, 0x00	; 0
     c9a:	b9 01       	movw	r22, r18
     c9c:	46 e9       	ldi	r20, 0x96	; 150
     c9e:	50 e0       	ldi	r21, 0x00	; 0
     ca0:	20 e0       	ldi	r18, 0x00	; 0
     ca2:	30 e0       	ldi	r19, 0x00	; 0
     ca4:	02 e0       	ldi	r16, 0x02	; 2
     ca6:	ee 24       	eor	r14, r14
     ca8:	ff 24       	eor	r15, r15
     caa:	0e 94 8d 22 	call	0x451a	; 0x451a <xTaskCreate>
			NULL , (2 | portPRIVILEGE_BIT) , NULL);

	/*create LCD task to display other tasks on LCD*/
	xTaskCreate(LCD_Task  , "LCD_Task" , configMINIMAL_STACK_SIZE,
     cae:	8e e6       	ldi	r24, 0x6E	; 110
     cb0:	97 e0       	ldi	r25, 0x07	; 7
     cb2:	26 e8       	ldi	r18, 0x86	; 134
     cb4:	30 e0       	ldi	r19, 0x00	; 0
     cb6:	b9 01       	movw	r22, r18
     cb8:	46 e9       	ldi	r20, 0x96	; 150
     cba:	50 e0       	ldi	r21, 0x00	; 0
     cbc:	20 e0       	ldi	r18, 0x00	; 0
     cbe:	30 e0       	ldi	r19, 0x00	; 0
     cc0:	04 e0       	ldi	r16, 0x04	; 4
     cc2:	ee 24       	eor	r14, r14
     cc4:	ff 24       	eor	r15, r15
     cc6:	0e 94 8d 22 	call	0x451a	; 0x451a <xTaskCreate>
			NULL , (4 | portPRIVILEGE_BIT) , NULL);

	/*create LED task to display other tasks on LCD*/
	xTaskCreate(LED_Task  , "SendLED_Task" , configMINIMAL_STACK_SIZE,
     cca:	88 ec       	ldi	r24, 0xC8	; 200
     ccc:	98 e0       	ldi	r25, 0x08	; 8
     cce:	2f e8       	ldi	r18, 0x8F	; 143
     cd0:	30 e0       	ldi	r19, 0x00	; 0
     cd2:	b9 01       	movw	r22, r18
     cd4:	46 e9       	ldi	r20, 0x96	; 150
     cd6:	50 e0       	ldi	r21, 0x00	; 0
     cd8:	20 e0       	ldi	r18, 0x00	; 0
     cda:	30 e0       	ldi	r19, 0x00	; 0
     cdc:	04 e0       	ldi	r16, 0x04	; 4
     cde:	ee 24       	eor	r14, r14
     ce0:	ff 24       	eor	r15, r15
     ce2:	0e 94 8d 22 	call	0x451a	; 0x451a <xTaskCreate>
			NULL , (4 | portPRIVILEGE_BIT) , NULL);

	/*suspend this task*/
	vTaskSuspend(InitTask_Flag);
     ce6:	80 91 e6 00 	lds	r24, 0x00E6
     cea:	90 91 e7 00 	lds	r25, 0x00E7
     cee:	0e 94 cd 24 	call	0x499a	; 0x499a <vTaskSuspend>
}
     cf2:	0f 90       	pop	r0
     cf4:	0f 90       	pop	r0
     cf6:	cf 91       	pop	r28
     cf8:	df 91       	pop	r29
     cfa:	0f 91       	pop	r16
     cfc:	ff 90       	pop	r15
     cfe:	ef 90       	pop	r14
     d00:	08 95       	ret

00000d02 <PushButton_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void PushButton_Task(void * a_Task_ptr)
{
     d02:	df 93       	push	r29
     d04:	cf 93       	push	r28
     d06:	00 d0       	rcall	.+0      	; 0xd08 <PushButton_Task+0x6>
     d08:	00 d0       	rcall	.+0      	; 0xd0a <PushButton_Task+0x8>
     d0a:	0f 92       	push	r0
     d0c:	cd b7       	in	r28, 0x3d	; 61
     d0e:	de b7       	in	r29, 0x3e	; 62
     d10:	9d 83       	std	Y+5, r25	; 0x05
     d12:	8c 83       	std	Y+4, r24	; 0x04
	vTaskDelay(50);
     d14:	82 e3       	ldi	r24, 0x32	; 50
     d16:	90 e0       	ldi	r25, 0x00	; 0
     d18:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
	/* Data is sent to LCD by Queue*/
	uint8 SendData = 1;
     d1c:	81 e0       	ldi	r24, 0x01	; 1
     d1e:	8b 83       	std	Y+3, r24	; 0x03
	/*de_bouncing Flag to make sure key is pressed*/
	uint8 Debouncing = 0;
     d20:	1a 82       	std	Y+2, r1	; 0x02

	/*comparing value to check if key is pressed*/
	uint8 OldPressedValue = 0;
     d22:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{
		/*Check if Button is pressed and enable de_bouncing*/
		if(Debouncing == 0 && Buttons_getPressedButton()==2)
     d24:	8a 81       	ldd	r24, Y+2	; 0x02
     d26:	88 23       	and	r24, r24
     d28:	79 f4       	brne	.+30     	; 0xd48 <PushButton_Task+0x46>
     d2a:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     d2e:	82 30       	cpi	r24, 0x02	; 2
     d30:	59 f4       	brne	.+22     	; 0xd48 <PushButton_Task+0x46>
		{
			OldPressedValue =  Buttons_getPressedButton();
     d32:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     d36:	89 83       	std	Y+1, r24	; 0x01
			Debouncing++;
     d38:	8a 81       	ldd	r24, Y+2	; 0x02
     d3a:	8f 5f       	subi	r24, 0xFF	; 255
     d3c:	8a 83       	std	Y+2, r24	; 0x02
			/*de_bouncing Delay*/
			vTaskDelay(10);
     d3e:	8a e0       	ldi	r24, 0x0A	; 10
     d40:	90 e0       	ldi	r25, 0x00	; 0
     d42:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
     d46:	ee cf       	rjmp	.-36     	; 0xd24 <PushButton_Task+0x22>
		}
		else if(Debouncing == 1)
     d48:	8a 81       	ldd	r24, Y+2	; 0x02
     d4a:	81 30       	cpi	r24, 0x01	; 1
     d4c:	b9 f5       	brne	.+110    	; 0xdbc <PushButton_Task+0xba>
     d4e:	2d c0       	rjmp	.+90     	; 0xdaa <PushButton_Task+0xa8>
		{
			/*check if button is still pressed after de_bouncing time*/
			while(OldPressedValue == Buttons_getPressedButton())
			{
				SendData = 1;
     d50:	81 e0       	ldi	r24, 0x01	; 1
     d52:	8b 83       	std	Y+3, r24	; 0x03
				/*Send push Button was pressed to Lcd by queue*/
				xQueueSend(Queue_PushButton , &SendData , 5);
     d54:	80 91 e8 00 	lds	r24, 0x00E8
     d58:	90 91 e9 00 	lds	r25, 0x00E9
     d5c:	9e 01       	movw	r18, r28
     d5e:	2d 5f       	subi	r18, 0xFD	; 253
     d60:	3f 4f       	sbci	r19, 0xFF	; 255
     d62:	b9 01       	movw	r22, r18
     d64:	45 e0       	ldi	r20, 0x05	; 5
     d66:	50 e0       	ldi	r21, 0x00	; 0
     d68:	20 e0       	ldi	r18, 0x00	; 0
     d6a:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <xQueueGenericSend>
				xQueueSend(Queue_PushButton , &SendData , 5);
     d6e:	80 91 e8 00 	lds	r24, 0x00E8
     d72:	90 91 e9 00 	lds	r25, 0x00E9
     d76:	9e 01       	movw	r18, r28
     d78:	2d 5f       	subi	r18, 0xFD	; 253
     d7a:	3f 4f       	sbci	r19, 0xFF	; 255
     d7c:	b9 01       	movw	r22, r18
     d7e:	45 e0       	ldi	r20, 0x05	; 5
     d80:	50 e0       	ldi	r21, 0x00	; 0
     d82:	20 e0       	ldi	r18, 0x00	; 0
     d84:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <xQueueGenericSend>
				xQueueSend(Queue_PushButton , &SendData , 5);
     d88:	80 91 e8 00 	lds	r24, 0x00E8
     d8c:	90 91 e9 00 	lds	r25, 0x00E9
     d90:	9e 01       	movw	r18, r28
     d92:	2d 5f       	subi	r18, 0xFD	; 253
     d94:	3f 4f       	sbci	r19, 0xFF	; 255
     d96:	b9 01       	movw	r22, r18
     d98:	45 e0       	ldi	r20, 0x05	; 5
     d9a:	50 e0       	ldi	r21, 0x00	; 0
     d9c:	20 e0       	ldi	r18, 0x00	; 0
     d9e:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <xQueueGenericSend>

				vTaskDelay(50);
     da2:	82 e3       	ldi	r24, 0x32	; 50
     da4:	90 e0       	ldi	r25, 0x00	; 0
     da6:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
			vTaskDelay(10);
		}
		else if(Debouncing == 1)
		{
			/*check if button is still pressed after de_bouncing time*/
			while(OldPressedValue == Buttons_getPressedButton())
     daa:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     dae:	98 2f       	mov	r25, r24
     db0:	89 81       	ldd	r24, Y+1	; 0x01
     db2:	98 17       	cp	r25, r24
     db4:	69 f2       	breq	.-102    	; 0xd50 <PushButton_Task+0x4e>
				xQueueSend(Queue_PushButton , &SendData , 5);
				xQueueSend(Queue_PushButton , &SendData , 5);

				vTaskDelay(50);
			}
			Debouncing = 2;
     db6:	82 e0       	ldi	r24, 0x02	; 2
     db8:	8a 83       	std	Y+2, r24	; 0x02
     dba:	b4 cf       	rjmp	.-152    	; 0xd24 <PushButton_Task+0x22>
		}
		else if(Debouncing == 2)
     dbc:	8a 81       	ldd	r24, Y+2	; 0x02
     dbe:	82 30       	cpi	r24, 0x02	; 2
     dc0:	39 f4       	brne	.+14     	; 0xdd0 <PushButton_Task+0xce>
		{
			SendData = 0;
     dc2:	1b 82       	std	Y+3, r1	; 0x03
			/*Send push Button was released to Lcd by queue*/
			Debouncing = 0;
     dc4:	1a 82       	std	Y+2, r1	; 0x02
			vTaskDelay(50);
     dc6:	82 e3       	ldi	r24, 0x32	; 50
     dc8:	90 e0       	ldi	r25, 0x00	; 0
     dca:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
     dce:	aa cf       	rjmp	.-172    	; 0xd24 <PushButton_Task+0x22>
		}
		else
		{
			/*Send push Button is in Idle state to Lcd by queue*/
			SendData = 3;
     dd0:	83 e0       	ldi	r24, 0x03	; 3
     dd2:	8b 83       	std	Y+3, r24	; 0x03
			xQueueSend(Queue_PushButton , &SendData , 5);
     dd4:	80 91 e8 00 	lds	r24, 0x00E8
     dd8:	90 91 e9 00 	lds	r25, 0x00E9
     ddc:	9e 01       	movw	r18, r28
     dde:	2d 5f       	subi	r18, 0xFD	; 253
     de0:	3f 4f       	sbci	r19, 0xFF	; 255
     de2:	b9 01       	movw	r22, r18
     de4:	45 e0       	ldi	r20, 0x05	; 5
     de6:	50 e0       	ldi	r21, 0x00	; 0
     de8:	20 e0       	ldi	r18, 0x00	; 0
     dea:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <xQueueGenericSend>
			xQueueSend(Queue_PushButton , &SendData , 5);
     dee:	80 91 e8 00 	lds	r24, 0x00E8
     df2:	90 91 e9 00 	lds	r25, 0x00E9
     df6:	9e 01       	movw	r18, r28
     df8:	2d 5f       	subi	r18, 0xFD	; 253
     dfa:	3f 4f       	sbci	r19, 0xFF	; 255
     dfc:	b9 01       	movw	r22, r18
     dfe:	45 e0       	ldi	r20, 0x05	; 5
     e00:	50 e0       	ldi	r21, 0x00	; 0
     e02:	20 e0       	ldi	r18, 0x00	; 0
     e04:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <xQueueGenericSend>
			xQueueSend(Queue_PushButton , &SendData , 5);
     e08:	80 91 e8 00 	lds	r24, 0x00E8
     e0c:	90 91 e9 00 	lds	r25, 0x00E9
     e10:	9e 01       	movw	r18, r28
     e12:	2d 5f       	subi	r18, 0xFD	; 253
     e14:	3f 4f       	sbci	r19, 0xFF	; 255
     e16:	b9 01       	movw	r22, r18
     e18:	45 e0       	ldi	r20, 0x05	; 5
     e1a:	50 e0       	ldi	r21, 0x00	; 0
     e1c:	20 e0       	ldi	r18, 0x00	; 0
     e1e:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <xQueueGenericSend>
			vTaskDelay(50);
     e22:	82 e3       	ldi	r24, 0x32	; 50
     e24:	90 e0       	ldi	r25, 0x00	; 0
     e26:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
     e2a:	7c cf       	rjmp	.-264    	; 0xd24 <PushButton_Task+0x22>

00000e2c <KeyPad_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void KeyPad_Task(void * a_Task_ptr)
{
     e2c:	df 93       	push	r29
     e2e:	cf 93       	push	r28
     e30:	00 d0       	rcall	.+0      	; 0xe32 <KeyPad_Task+0x6>
     e32:	00 d0       	rcall	.+0      	; 0xe34 <KeyPad_Task+0x8>
     e34:	cd b7       	in	r28, 0x3d	; 61
     e36:	de b7       	in	r29, 0x3e	; 62
     e38:	9c 83       	std	Y+4, r25	; 0x04
     e3a:	8b 83       	std	Y+3, r24	; 0x03
	/*de_bouncing Flag to make sure key is pressed*/
	uint8 Debouncing = 0;
     e3c:	19 82       	std	Y+1, r1	; 0x01

	/*comparing value to check if key is pressed*/
	uint8 OldPressedValue = 0;
     e3e:	1a 82       	std	Y+2, r1	; 0x02

	while(1)
	{
		/*Start of pressing on button*/
		if(Debouncing == 0 && KeyPad_getPressedKey()!=10)
     e40:	89 81       	ldd	r24, Y+1	; 0x01
     e42:	88 23       	and	r24, r24
     e44:	79 f4       	brne	.+30     	; 0xe64 <KeyPad_Task+0x38>
     e46:	0e 94 24 0d 	call	0x1a48	; 0x1a48 <KeyPad_getPressedKey>
     e4a:	8a 30       	cpi	r24, 0x0A	; 10
     e4c:	59 f0       	breq	.+22     	; 0xe64 <KeyPad_Task+0x38>
		{
			OldPressedValue =  KeyPad_getPressedKey();
     e4e:	0e 94 24 0d 	call	0x1a48	; 0x1a48 <KeyPad_getPressedKey>
     e52:	8a 83       	std	Y+2, r24	; 0x02
			Debouncing++;
     e54:	89 81       	ldd	r24, Y+1	; 0x01
     e56:	8f 5f       	subi	r24, 0xFF	; 255
     e58:	89 83       	std	Y+1, r24	; 0x01
			vTaskDelay(10);
     e5a:	8a e0       	ldi	r24, 0x0A	; 10
     e5c:	90 e0       	ldi	r25, 0x00	; 0
     e5e:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
     e62:	ee cf       	rjmp	.-36     	; 0xe40 <KeyPad_Task+0x14>
		}
		/*Check on de_bouncing*/
		else if(Debouncing == 1)
     e64:	89 81       	ldd	r24, Y+1	; 0x01
     e66:	81 30       	cpi	r24, 0x01	; 1
     e68:	99 f5       	brne	.+102    	; 0xed0 <KeyPad_Task+0xa4>
		{
			if(OldPressedValue == KeyPad_getPressedKey())
     e6a:	0e 94 24 0d 	call	0x1a48	; 0x1a48 <KeyPad_getPressedKey>
     e6e:	98 2f       	mov	r25, r24
     e70:	8a 81       	ldd	r24, Y+2	; 0x02
     e72:	98 17       	cp	r25, r24
     e74:	29 f5       	brne	.+74     	; 0xec0 <KeyPad_Task+0x94>
			{
				/*send pressed key to LCD & UART*/
				xQueueSend(Queue_Keypad_Task , &OldPressedValue , 5);
     e76:	80 91 ec 00 	lds	r24, 0x00EC
     e7a:	90 91 ed 00 	lds	r25, 0x00ED
     e7e:	9e 01       	movw	r18, r28
     e80:	2e 5f       	subi	r18, 0xFE	; 254
     e82:	3f 4f       	sbci	r19, 0xFF	; 255
     e84:	b9 01       	movw	r22, r18
     e86:	45 e0       	ldi	r20, 0x05	; 5
     e88:	50 e0       	ldi	r21, 0x00	; 0
     e8a:	20 e0       	ldi	r18, 0x00	; 0
     e8c:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <xQueueGenericSend>
				xQueueSend(Queue_Keypad_Task , &OldPressedValue , 5);
     e90:	80 91 ec 00 	lds	r24, 0x00EC
     e94:	90 91 ed 00 	lds	r25, 0x00ED
     e98:	9e 01       	movw	r18, r28
     e9a:	2e 5f       	subi	r18, 0xFE	; 254
     e9c:	3f 4f       	sbci	r19, 0xFF	; 255
     e9e:	b9 01       	movw	r22, r18
     ea0:	45 e0       	ldi	r20, 0x05	; 5
     ea2:	50 e0       	ldi	r21, 0x00	; 0
     ea4:	20 e0       	ldi	r18, 0x00	; 0
     ea6:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <xQueueGenericSend>
     eaa:	04 c0       	rjmp	.+8      	; 0xeb4 <KeyPad_Task+0x88>
				while(OldPressedValue == KeyPad_getPressedKey())
				{
					vTaskDelay(50);
     eac:	82 e3       	ldi	r24, 0x32	; 50
     eae:	90 e0       	ldi	r25, 0x00	; 0
     eb0:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
			if(OldPressedValue == KeyPad_getPressedKey())
			{
				/*send pressed key to LCD & UART*/
				xQueueSend(Queue_Keypad_Task , &OldPressedValue , 5);
				xQueueSend(Queue_Keypad_Task , &OldPressedValue , 5);
				while(OldPressedValue == KeyPad_getPressedKey())
     eb4:	0e 94 24 0d 	call	0x1a48	; 0x1a48 <KeyPad_getPressedKey>
     eb8:	98 2f       	mov	r25, r24
     eba:	8a 81       	ldd	r24, Y+2	; 0x02
     ebc:	98 17       	cp	r25, r24
     ebe:	b1 f3       	breq	.-20     	; 0xeac <KeyPad_Task+0x80>
			}
			else
			{
				/*Do Nothing*/
			}
			Debouncing++;
     ec0:	89 81       	ldd	r24, Y+1	; 0x01
     ec2:	8f 5f       	subi	r24, 0xFF	; 255
     ec4:	89 83       	std	Y+1, r24	; 0x01
			vTaskDelay(50);
     ec6:	82 e3       	ldi	r24, 0x32	; 50
     ec8:	90 e0       	ldi	r25, 0x00	; 0
     eca:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
     ece:	b8 cf       	rjmp	.-144    	; 0xe40 <KeyPad_Task+0x14>
		}
		else
		{
			Debouncing = 0;
     ed0:	19 82       	std	Y+1, r1	; 0x01
			vTaskDelay(50);
     ed2:	82 e3       	ldi	r24, 0x32	; 50
     ed4:	90 e0       	ldi	r25, 0x00	; 0
     ed6:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
     eda:	b2 cf       	rjmp	.-156    	; 0xe40 <KeyPad_Task+0x14>

00000edc <LCD_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_Task(void * a_Task_ptr)
{
     edc:	df 93       	push	r29
     ede:	cf 93       	push	r28
     ee0:	cd b7       	in	r28, 0x3d	; 61
     ee2:	de b7       	in	r29, 0x3e	; 62
     ee4:	c3 54       	subi	r28, 0x43	; 67
     ee6:	d0 40       	sbci	r29, 0x00	; 0
     ee8:	0f b6       	in	r0, 0x3f	; 63
     eea:	f8 94       	cli
     eec:	de bf       	out	0x3e, r29	; 62
     eee:	0f be       	out	0x3f, r0	; 63
     ef0:	cd bf       	out	0x3d, r28	; 61
     ef2:	9c ab       	std	Y+52, r25	; 0x34
     ef4:	8b ab       	std	Y+51, r24	; 0x33
	vTaskDelay(100);
     ef6:	84 e6       	ldi	r24, 0x64	; 100
     ef8:	90 e0       	ldi	r25, 0x00	; 0
     efa:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
	/*received data from Push Button Task to display button state on LCD*/
	uint8 PushButton_Task_Data = 0;
     efe:	1b 82       	std	Y+3, r1	; 0x03

	/*received message from ADC Task to display button state on LCD*/
	uint8 Keypad_Task_Data = 0;
     f00:	1c 82       	std	Y+4, r1	; 0x04

	/*received message from UART Task to display button state on LCD*/
	uint8 UART_Task_Data = 0;
     f02:	1d 82       	std	Y+5, r1	; 0x05

	/*dummy & TenPowerDigit & DigitCounter buffers to convert integer number to string*/
	uint8 Keypad_ReadFlag = 0;
     f04:	1a 82       	std	Y+2, r1	; 0x02
	uint8 ReceivedTimeCounter = 0;
     f06:	19 82       	std	Y+1, r1	; 0x01

	/*LCD strings*/
	uint8 Send_String[] = "Send Data= ";
     f08:	ce 01       	movw	r24, r28
     f0a:	06 96       	adiw	r24, 0x06	; 6
     f0c:	9e ab       	std	Y+54, r25	; 0x36
     f0e:	8d ab       	std	Y+53, r24	; 0x35
     f10:	ec e9       	ldi	r30, 0x9C	; 156
     f12:	f0 e0       	ldi	r31, 0x00	; 0
     f14:	f8 af       	std	Y+56, r31	; 0x38
     f16:	ef ab       	std	Y+55, r30	; 0x37
     f18:	fc e0       	ldi	r31, 0x0C	; 12
     f1a:	f9 af       	std	Y+57, r31	; 0x39
     f1c:	ef a9       	ldd	r30, Y+55	; 0x37
     f1e:	f8 ad       	ldd	r31, Y+56	; 0x38
     f20:	00 80       	ld	r0, Z
     f22:	8f a9       	ldd	r24, Y+55	; 0x37
     f24:	98 ad       	ldd	r25, Y+56	; 0x38
     f26:	01 96       	adiw	r24, 0x01	; 1
     f28:	98 af       	std	Y+56, r25	; 0x38
     f2a:	8f ab       	std	Y+55, r24	; 0x37
     f2c:	ed a9       	ldd	r30, Y+53	; 0x35
     f2e:	fe a9       	ldd	r31, Y+54	; 0x36
     f30:	00 82       	st	Z, r0
     f32:	8d a9       	ldd	r24, Y+53	; 0x35
     f34:	9e a9       	ldd	r25, Y+54	; 0x36
     f36:	01 96       	adiw	r24, 0x01	; 1
     f38:	9e ab       	std	Y+54, r25	; 0x36
     f3a:	8d ab       	std	Y+53, r24	; 0x35
     f3c:	99 ad       	ldd	r25, Y+57	; 0x39
     f3e:	91 50       	subi	r25, 0x01	; 1
     f40:	99 af       	std	Y+57, r25	; 0x39
     f42:	e9 ad       	ldd	r30, Y+57	; 0x39
     f44:	ee 23       	and	r30, r30
     f46:	51 f7       	brne	.-44     	; 0xf1c <LCD_Task+0x40>
	uint8 Received_String[] = "Received Data= ";
     f48:	ce 01       	movw	r24, r28
     f4a:	42 96       	adiw	r24, 0x12	; 18
     f4c:	9b af       	std	Y+59, r25	; 0x3b
     f4e:	8a af       	std	Y+58, r24	; 0x3a
     f50:	e8 ea       	ldi	r30, 0xA8	; 168
     f52:	f0 e0       	ldi	r31, 0x00	; 0
     f54:	fd af       	std	Y+61, r31	; 0x3d
     f56:	ec af       	std	Y+60, r30	; 0x3c
     f58:	f0 e1       	ldi	r31, 0x10	; 16
     f5a:	fe af       	std	Y+62, r31	; 0x3e
     f5c:	ec ad       	ldd	r30, Y+60	; 0x3c
     f5e:	fd ad       	ldd	r31, Y+61	; 0x3d
     f60:	00 80       	ld	r0, Z
     f62:	8c ad       	ldd	r24, Y+60	; 0x3c
     f64:	9d ad       	ldd	r25, Y+61	; 0x3d
     f66:	01 96       	adiw	r24, 0x01	; 1
     f68:	9d af       	std	Y+61, r25	; 0x3d
     f6a:	8c af       	std	Y+60, r24	; 0x3c
     f6c:	ea ad       	ldd	r30, Y+58	; 0x3a
     f6e:	fb ad       	ldd	r31, Y+59	; 0x3b
     f70:	00 82       	st	Z, r0
     f72:	8a ad       	ldd	r24, Y+58	; 0x3a
     f74:	9b ad       	ldd	r25, Y+59	; 0x3b
     f76:	01 96       	adiw	r24, 0x01	; 1
     f78:	9b af       	std	Y+59, r25	; 0x3b
     f7a:	8a af       	std	Y+58, r24	; 0x3a
     f7c:	9e ad       	ldd	r25, Y+62	; 0x3e
     f7e:	91 50       	subi	r25, 0x01	; 1
     f80:	9e af       	std	Y+62, r25	; 0x3e
     f82:	ee ad       	ldd	r30, Y+62	; 0x3e
     f84:	ee 23       	and	r30, r30
     f86:	51 f7       	brne	.-44     	; 0xf5c <LCD_Task+0x80>
	uint8 Spaces_String[] = "                ";
     f88:	ce 01       	movw	r24, r28
     f8a:	82 96       	adiw	r24, 0x22	; 34
     f8c:	21 96       	adiw	r28, 0x01	; 1
     f8e:	9f af       	std	Y+63, r25	; 0x3f
     f90:	8e af       	std	Y+62, r24	; 0x3e
     f92:	21 97       	sbiw	r28, 0x01	; 1
     f94:	e8 eb       	ldi	r30, 0xB8	; 184
     f96:	f0 e0       	ldi	r31, 0x00	; 0
     f98:	23 96       	adiw	r28, 0x03	; 3
     f9a:	ff af       	std	Y+63, r31	; 0x3f
     f9c:	ee af       	std	Y+62, r30	; 0x3e
     f9e:	23 97       	sbiw	r28, 0x03	; 3
     fa0:	f1 e1       	ldi	r31, 0x11	; 17
     fa2:	24 96       	adiw	r28, 0x04	; 4
     fa4:	ff af       	std	Y+63, r31	; 0x3f
     fa6:	24 97       	sbiw	r28, 0x04	; 4
     fa8:	23 96       	adiw	r28, 0x03	; 3
     faa:	ee ad       	ldd	r30, Y+62	; 0x3e
     fac:	ff ad       	ldd	r31, Y+63	; 0x3f
     fae:	23 97       	sbiw	r28, 0x03	; 3
     fb0:	00 80       	ld	r0, Z
     fb2:	23 96       	adiw	r28, 0x03	; 3
     fb4:	8e ad       	ldd	r24, Y+62	; 0x3e
     fb6:	9f ad       	ldd	r25, Y+63	; 0x3f
     fb8:	23 97       	sbiw	r28, 0x03	; 3
     fba:	01 96       	adiw	r24, 0x01	; 1
     fbc:	23 96       	adiw	r28, 0x03	; 3
     fbe:	9f af       	std	Y+63, r25	; 0x3f
     fc0:	8e af       	std	Y+62, r24	; 0x3e
     fc2:	23 97       	sbiw	r28, 0x03	; 3
     fc4:	21 96       	adiw	r28, 0x01	; 1
     fc6:	ee ad       	ldd	r30, Y+62	; 0x3e
     fc8:	ff ad       	ldd	r31, Y+63	; 0x3f
     fca:	21 97       	sbiw	r28, 0x01	; 1
     fcc:	00 82       	st	Z, r0
     fce:	21 96       	adiw	r28, 0x01	; 1
     fd0:	8e ad       	ldd	r24, Y+62	; 0x3e
     fd2:	9f ad       	ldd	r25, Y+63	; 0x3f
     fd4:	21 97       	sbiw	r28, 0x01	; 1
     fd6:	01 96       	adiw	r24, 0x01	; 1
     fd8:	21 96       	adiw	r28, 0x01	; 1
     fda:	9f af       	std	Y+63, r25	; 0x3f
     fdc:	8e af       	std	Y+62, r24	; 0x3e
     fde:	21 97       	sbiw	r28, 0x01	; 1
     fe0:	24 96       	adiw	r28, 0x04	; 4
     fe2:	9f ad       	ldd	r25, Y+63	; 0x3f
     fe4:	24 97       	sbiw	r28, 0x04	; 4
     fe6:	91 50       	subi	r25, 0x01	; 1
     fe8:	24 96       	adiw	r28, 0x04	; 4
     fea:	9f af       	std	Y+63, r25	; 0x3f
     fec:	24 97       	sbiw	r28, 0x04	; 4
     fee:	24 96       	adiw	r28, 0x04	; 4
     ff0:	ef ad       	ldd	r30, Y+63	; 0x3f
     ff2:	24 97       	sbiw	r28, 0x04	; 4
     ff4:	ee 23       	and	r30, r30
     ff6:	c1 f6       	brne	.-80     	; 0xfa8 <LCD_Task+0xcc>
	while(1)
	{
		/*receive messages from other tasks by queues*/
		xQueueReceive(Queue_PushButton , &PushButton_Task_Data , 10);
     ff8:	80 91 e8 00 	lds	r24, 0x00E8
     ffc:	90 91 e9 00 	lds	r25, 0x00E9
    1000:	9e 01       	movw	r18, r28
    1002:	2d 5f       	subi	r18, 0xFD	; 253
    1004:	3f 4f       	sbci	r19, 0xFF	; 255
    1006:	b9 01       	movw	r22, r18
    1008:	4a e0       	ldi	r20, 0x0A	; 10
    100a:	50 e0       	ldi	r21, 0x00	; 0
    100c:	0e 94 3e 16 	call	0x2c7c	; 0x2c7c <xQueueReceive>
		xQueueReceive(Queue_ReceivedUART_Task, &UART_Task_Data , 10);
    1010:	80 91 ea 00 	lds	r24, 0x00EA
    1014:	90 91 eb 00 	lds	r25, 0x00EB
    1018:	9e 01       	movw	r18, r28
    101a:	2b 5f       	subi	r18, 0xFB	; 251
    101c:	3f 4f       	sbci	r19, 0xFF	; 255
    101e:	b9 01       	movw	r22, r18
    1020:	4a e0       	ldi	r20, 0x0A	; 10
    1022:	50 e0       	ldi	r21, 0x00	; 0
    1024:	0e 94 3e 16 	call	0x2c7c	; 0x2c7c <xQueueReceive>


		/*Clear Send String row if Push button is pressed*/
		if(PushButton_Task_Data == 1)
    1028:	8b 81       	ldd	r24, Y+3	; 0x03
    102a:	81 30       	cpi	r24, 0x01	; 1
    102c:	51 f4       	brne	.+20     	; 0x1042 <LCD_Task+0x166>
		{
			LCD_displayStringRowColumn(0 , 0 , Spaces_String);
    102e:	9e 01       	movw	r18, r28
    1030:	2e 5d       	subi	r18, 0xDE	; 222
    1032:	3f 4f       	sbci	r19, 0xFF	; 255
    1034:	80 e0       	ldi	r24, 0x00	; 0
    1036:	60 e0       	ldi	r22, 0x00	; 0
    1038:	a9 01       	movw	r20, r18
    103a:	0e 94 64 0f 	call	0x1ec8	; 0x1ec8 <LCD_displayStringRowColumn>
			Keypad_ReadFlag = 0;
    103e:	1a 82       	std	Y+2, r1	; 0x02
			PushButton_Task_Data = 0;
    1040:	1b 82       	std	Y+3, r1	; 0x03
		}
		/*display key value that will be sent*/
		if(Keypad_ReadFlag == 0)
    1042:	8a 81       	ldd	r24, Y+2	; 0x02
    1044:	88 23       	and	r24, r24
    1046:	11 f5       	brne	.+68     	; 0x108c <LCD_Task+0x1b0>
		{
			xQueueReceive(Queue_Keypad_Task , &Keypad_Task_Data , 5);
    1048:	80 91 ec 00 	lds	r24, 0x00EC
    104c:	90 91 ed 00 	lds	r25, 0x00ED
    1050:	9e 01       	movw	r18, r28
    1052:	2c 5f       	subi	r18, 0xFC	; 252
    1054:	3f 4f       	sbci	r19, 0xFF	; 255
    1056:	b9 01       	movw	r22, r18
    1058:	45 e0       	ldi	r20, 0x05	; 5
    105a:	50 e0       	ldi	r21, 0x00	; 0
    105c:	0e 94 3e 16 	call	0x2c7c	; 0x2c7c <xQueueReceive>
			if((Keypad_Task_Data >= 1) && (Keypad_Task_Data <= 9))
    1060:	8c 81       	ldd	r24, Y+4	; 0x04
    1062:	88 23       	and	r24, r24
    1064:	99 f0       	breq	.+38     	; 0x108c <LCD_Task+0x1b0>
    1066:	8c 81       	ldd	r24, Y+4	; 0x04
    1068:	8a 30       	cpi	r24, 0x0A	; 10
    106a:	80 f4       	brcc	.+32     	; 0x108c <LCD_Task+0x1b0>
			{
				LCD_displayStringRowColumn(0 , 0 , Send_String);
    106c:	9e 01       	movw	r18, r28
    106e:	2a 5f       	subi	r18, 0xFA	; 250
    1070:	3f 4f       	sbci	r19, 0xFF	; 255
    1072:	80 e0       	ldi	r24, 0x00	; 0
    1074:	60 e0       	ldi	r22, 0x00	; 0
    1076:	a9 01       	movw	r20, r18
    1078:	0e 94 64 0f 	call	0x1ec8	; 0x1ec8 <LCD_displayStringRowColumn>
				LCD_displayCharacter(Keypad_Task_Data + 48);
    107c:	8c 81       	ldd	r24, Y+4	; 0x04
    107e:	80 5d       	subi	r24, 0xD0	; 208
    1080:	0e 94 8c 0e 	call	0x1d18	; 0x1d18 <LCD_displayCharacter>
				Keypad_Task_Data = 10;
    1084:	8a e0       	ldi	r24, 0x0A	; 10
    1086:	8c 83       	std	Y+4, r24	; 0x04
				Keypad_ReadFlag = 1;
    1088:	81 e0       	ldi	r24, 0x01	; 1
    108a:	8a 83       	std	Y+2, r24	; 0x02
			}
		}

		/*display Value that will be received by UART*/
		if(UART_Task_Data != 0x00)
    108c:	8d 81       	ldd	r24, Y+5	; 0x05
    108e:	88 23       	and	r24, r24
    1090:	81 f0       	breq	.+32     	; 0x10b2 <LCD_Task+0x1d6>
		{
			LCD_displayStringRowColumn(1 , 0 , Received_String);
    1092:	9e 01       	movw	r18, r28
    1094:	2e 5e       	subi	r18, 0xEE	; 238
    1096:	3f 4f       	sbci	r19, 0xFF	; 255
    1098:	81 e0       	ldi	r24, 0x01	; 1
    109a:	60 e0       	ldi	r22, 0x00	; 0
    109c:	a9 01       	movw	r20, r18
    109e:	0e 94 64 0f 	call	0x1ec8	; 0x1ec8 <LCD_displayStringRowColumn>
			LCD_displayCharacter(UART_Task_Data + 48);
    10a2:	8d 81       	ldd	r24, Y+5	; 0x05
    10a4:	80 5d       	subi	r24, 0xD0	; 208
    10a6:	0e 94 8c 0e 	call	0x1d18	; 0x1d18 <LCD_displayCharacter>
			UART_Task_Data = 0x00;
    10aa:	1d 82       	std	Y+5, r1	; 0x05
			ReceivedTimeCounter++;
    10ac:	89 81       	ldd	r24, Y+1	; 0x01
    10ae:	8f 5f       	subi	r24, 0xFF	; 255
    10b0:	89 83       	std	Y+1, r24	; 0x01
		}
		if(ReceivedTimeCounter != 0)
    10b2:	89 81       	ldd	r24, Y+1	; 0x01
    10b4:	88 23       	and	r24, r24
    10b6:	81 f0       	breq	.+32     	; 0x10d8 <LCD_Task+0x1fc>
		{
			if(ReceivedTimeCounter < 40)
    10b8:	89 81       	ldd	r24, Y+1	; 0x01
    10ba:	88 32       	cpi	r24, 0x28	; 40
    10bc:	20 f4       	brcc	.+8      	; 0x10c6 <LCD_Task+0x1ea>
			{
				ReceivedTimeCounter++;
    10be:	89 81       	ldd	r24, Y+1	; 0x01
    10c0:	8f 5f       	subi	r24, 0xFF	; 255
    10c2:	89 83       	std	Y+1, r24	; 0x01
    10c4:	09 c0       	rjmp	.+18     	; 0x10d8 <LCD_Task+0x1fc>
			}
			else
			{
				/*Clear Received Data row */
				ReceivedTimeCounter = 0;
    10c6:	19 82       	std	Y+1, r1	; 0x01
				LCD_displayStringRowColumn(1 , 0 , Spaces_String);
    10c8:	9e 01       	movw	r18, r28
    10ca:	2e 5d       	subi	r18, 0xDE	; 222
    10cc:	3f 4f       	sbci	r19, 0xFF	; 255
    10ce:	81 e0       	ldi	r24, 0x01	; 1
    10d0:	60 e0       	ldi	r22, 0x00	; 0
    10d2:	a9 01       	movw	r20, r18
    10d4:	0e 94 64 0f 	call	0x1ec8	; 0x1ec8 <LCD_displayStringRowColumn>
			}
		}
		vTaskDelay(50);
    10d8:	82 e3       	ldi	r24, 0x32	; 50
    10da:	90 e0       	ldi	r25, 0x00	; 0
    10dc:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
    10e0:	8b cf       	rjmp	.-234    	; 0xff8 <LCD_Task+0x11c>

000010e2 <UART_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void UART_Task(void * a_Task_ptr)
{
    10e2:	df 93       	push	r29
    10e4:	cf 93       	push	r28
    10e6:	00 d0       	rcall	.+0      	; 0x10e8 <UART_Task+0x6>
    10e8:	00 d0       	rcall	.+0      	; 0x10ea <UART_Task+0x8>
    10ea:	0f 92       	push	r0
    10ec:	cd b7       	in	r28, 0x3d	; 61
    10ee:	de b7       	in	r29, 0x3e	; 62
    10f0:	9d 83       	std	Y+5, r25	; 0x05
    10f2:	8c 83       	std	Y+4, r24	; 0x04
	/*Parameter that can get queues values*/
	vTaskDelay(100);
    10f4:	84 e6       	ldi	r24, 0x64	; 100
    10f6:	90 e0       	ldi	r25, 0x00	; 0
    10f8:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
	uint8 UART_ReceivedData = 0;
    10fc:	19 82       	std	Y+1, r1	; 0x01
	uint8 PushButton_PressedCheck = 0;
    10fe:	1a 82       	std	Y+2, r1	; 0x02
	uint8 UART_SendData = 0;
    1100:	1b 82       	std	Y+3, r1	; 0x03
	while(1)
	{
		xQueueReceive(Queue_PushButton , &PushButton_PressedCheck , 10);
    1102:	80 91 e8 00 	lds	r24, 0x00E8
    1106:	90 91 e9 00 	lds	r25, 0x00E9
    110a:	9e 01       	movw	r18, r28
    110c:	2e 5f       	subi	r18, 0xFE	; 254
    110e:	3f 4f       	sbci	r19, 0xFF	; 255
    1110:	b9 01       	movw	r22, r18
    1112:	4a e0       	ldi	r20, 0x0A	; 10
    1114:	50 e0       	ldi	r21, 0x00	; 0
    1116:	0e 94 3e 16 	call	0x2c7c	; 0x2c7c <xQueueReceive>
		/*receive data from UART*/
		UART_ReceivedData = USART_DataRegister;
    111a:	ec e2       	ldi	r30, 0x2C	; 44
    111c:	f0 e0       	ldi	r31, 0x00	; 0
    111e:	80 81       	ld	r24, Z
    1120:	89 83       	std	Y+1, r24	; 0x01
		if(UART_ReceivedData != 0x00)
    1122:	89 81       	ldd	r24, Y+1	; 0x01
    1124:	88 23       	and	r24, r24
    1126:	d1 f0       	breq	.+52     	; 0x115c <UART_Task+0x7a>
		{
			/* Data is sent to LCD by Queue*/
			xQueueSend(Queue_ReceivedUART_Task , &UART_ReceivedData , 5);
    1128:	80 91 ea 00 	lds	r24, 0x00EA
    112c:	90 91 eb 00 	lds	r25, 0x00EB
    1130:	9e 01       	movw	r18, r28
    1132:	2f 5f       	subi	r18, 0xFF	; 255
    1134:	3f 4f       	sbci	r19, 0xFF	; 255
    1136:	b9 01       	movw	r22, r18
    1138:	45 e0       	ldi	r20, 0x05	; 5
    113a:	50 e0       	ldi	r21, 0x00	; 0
    113c:	20 e0       	ldi	r18, 0x00	; 0
    113e:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <xQueueGenericSend>
			xQueueSend(Queue_ReceivedUART_Task , &UART_ReceivedData , 5);
    1142:	80 91 ea 00 	lds	r24, 0x00EA
    1146:	90 91 eb 00 	lds	r25, 0x00EB
    114a:	9e 01       	movw	r18, r28
    114c:	2f 5f       	subi	r18, 0xFF	; 255
    114e:	3f 4f       	sbci	r19, 0xFF	; 255
    1150:	b9 01       	movw	r22, r18
    1152:	45 e0       	ldi	r20, 0x05	; 5
    1154:	50 e0       	ldi	r21, 0x00	; 0
    1156:	20 e0       	ldi	r18, 0x00	; 0
    1158:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <xQueueGenericSend>
		{
			/*Do Nothing*/
		}

		/*check if UART can send data*/
		if(PushButton_PressedCheck == 1)
    115c:	8a 81       	ldd	r24, Y+2	; 0x02
    115e:	81 30       	cpi	r24, 0x01	; 1
    1160:	91 f4       	brne	.+36     	; 0x1186 <UART_Task+0xa4>
		{
			xQueueReceive(Queue_Keypad_Task , &UART_SendData , 5);
    1162:	80 91 ec 00 	lds	r24, 0x00EC
    1166:	90 91 ed 00 	lds	r25, 0x00ED
    116a:	9e 01       	movw	r18, r28
    116c:	2d 5f       	subi	r18, 0xFD	; 253
    116e:	3f 4f       	sbci	r19, 0xFF	; 255
    1170:	b9 01       	movw	r22, r18
    1172:	45 e0       	ldi	r20, 0x05	; 5
    1174:	50 e0       	ldi	r21, 0x00	; 0
    1176:	0e 94 3e 16 	call	0x2c7c	; 0x2c7c <xQueueReceive>
			/*send data by UART*/
			USART_DataRegister = UART_SendData;
    117a:	ec e2       	ldi	r30, 0x2C	; 44
    117c:	f0 e0       	ldi	r31, 0x00	; 0
    117e:	8b 81       	ldd	r24, Y+3	; 0x03
    1180:	80 83       	st	Z, r24
			UART_SendData = 0;
    1182:	1b 82       	std	Y+3, r1	; 0x03
			PushButton_PressedCheck = 0;
    1184:	1a 82       	std	Y+2, r1	; 0x02
		}
		else
		{
			/*Do Nothing*/
		}
		vTaskDelay(50);
    1186:	82 e3       	ldi	r24, 0x32	; 50
    1188:	90 e0       	ldi	r25, 0x00	; 0
    118a:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
    118e:	b9 cf       	rjmp	.-142    	; 0x1102 <UART_Task+0x20>

00001190 <LED_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LED_Task(void * a_Task_ptr)
{
    1190:	df 93       	push	r29
    1192:	cf 93       	push	r28
    1194:	00 d0       	rcall	.+0      	; 0x1196 <LED_Task+0x6>
    1196:	00 d0       	rcall	.+0      	; 0x1198 <LED_Task+0x8>
    1198:	00 d0       	rcall	.+0      	; 0x119a <LED_Task+0xa>
    119a:	cd b7       	in	r28, 0x3d	; 61
    119c:	de b7       	in	r29, 0x3e	; 62
    119e:	9e 83       	std	Y+6, r25	; 0x06
    11a0:	8d 83       	std	Y+5, r24	; 0x05
	/*Parameter that receive queues values*/
	uint8 PushButton_Check = 0;
    11a2:	1b 82       	std	Y+3, r1	; 0x03
	uint8 ReceivedMessage_Check = 0;
    11a4:	1c 82       	std	Y+4, r1	; 0x04
	uint8 SendLED_Counter = 0;
    11a6:	1a 82       	std	Y+2, r1	; 0x02
	uint8 ReceivedLED_Counter = 0;
    11a8:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		if(SendLED_Counter == 0)
    11aa:	8a 81       	ldd	r24, Y+2	; 0x02
    11ac:	88 23       	and	r24, r24
    11ae:	61 f4       	brne	.+24     	; 0x11c8 <LED_Task+0x38>
		{
			xQueueReceive(Queue_PushButton , &PushButton_Check , 10);
    11b0:	80 91 e8 00 	lds	r24, 0x00E8
    11b4:	90 91 e9 00 	lds	r25, 0x00E9
    11b8:	9e 01       	movw	r18, r28
    11ba:	2d 5f       	subi	r18, 0xFD	; 253
    11bc:	3f 4f       	sbci	r19, 0xFF	; 255
    11be:	b9 01       	movw	r22, r18
    11c0:	4a e0       	ldi	r20, 0x0A	; 10
    11c2:	50 e0       	ldi	r21, 0x00	; 0
    11c4:	0e 94 3e 16 	call	0x2c7c	; 0x2c7c <xQueueReceive>
		}
		if(ReceivedLED_Counter == 0)
    11c8:	89 81       	ldd	r24, Y+1	; 0x01
    11ca:	88 23       	and	r24, r24
    11cc:	61 f4       	brne	.+24     	; 0x11e6 <LED_Task+0x56>
		{
			xQueueReceive(Queue_ReceivedUART_Task , &ReceivedMessage_Check , 10);
    11ce:	80 91 ea 00 	lds	r24, 0x00EA
    11d2:	90 91 eb 00 	lds	r25, 0x00EB
    11d6:	9e 01       	movw	r18, r28
    11d8:	2c 5f       	subi	r18, 0xFC	; 252
    11da:	3f 4f       	sbci	r19, 0xFF	; 255
    11dc:	b9 01       	movw	r22, r18
    11de:	4a e0       	ldi	r20, 0x0A	; 10
    11e0:	50 e0       	ldi	r21, 0x00	; 0
    11e2:	0e 94 3e 16 	call	0x2c7c	; 0x2c7c <xQueueReceive>
		}
		/* check if any message is sent*/
		if (PushButton_Check == 1)
    11e6:	8b 81       	ldd	r24, Y+3	; 0x03
    11e8:	81 30       	cpi	r24, 0x01	; 1
    11ea:	41 f4       	brne	.+16     	; 0x11fc <LED_Task+0x6c>
		{
			/*LED ON*/
			DIO_WritePin(DIO_PIN13 , HIGH);
    11ec:	8d e0       	ldi	r24, 0x0D	; 13
    11ee:	61 e0       	ldi	r22, 0x01	; 1
    11f0:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
			SendLED_Counter++;
    11f4:	8a 81       	ldd	r24, Y+2	; 0x02
    11f6:	8f 5f       	subi	r24, 0xFF	; 255
    11f8:	8a 83       	std	Y+2, r24	; 0x02
			PushButton_Check = 0;
    11fa:	1b 82       	std	Y+3, r1	; 0x03
		}

		/*to make LED off after specific time*/
		if(SendLED_Counter != 0)
    11fc:	8a 81       	ldd	r24, Y+2	; 0x02
    11fe:	88 23       	and	r24, r24
    1200:	61 f0       	breq	.+24     	; 0x121a <LED_Task+0x8a>
		{
			if(SendLED_Counter < 3)
    1202:	8a 81       	ldd	r24, Y+2	; 0x02
    1204:	83 30       	cpi	r24, 0x03	; 3
    1206:	20 f4       	brcc	.+8      	; 0x1210 <LED_Task+0x80>
			{
				SendLED_Counter++;
    1208:	8a 81       	ldd	r24, Y+2	; 0x02
    120a:	8f 5f       	subi	r24, 0xFF	; 255
    120c:	8a 83       	std	Y+2, r24	; 0x02
    120e:	05 c0       	rjmp	.+10     	; 0x121a <LED_Task+0x8a>
			}
			else
			{
				/*LED OFF*/
				DIO_WritePin(DIO_PIN13 , LOW);
    1210:	8d e0       	ldi	r24, 0x0D	; 13
    1212:	60 e0       	ldi	r22, 0x00	; 0
    1214:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
				SendLED_Counter = 0;
    1218:	1a 82       	std	Y+2, r1	; 0x02
			}
		}

		/*check if Data is received*/
		if(ReceivedMessage_Check != 0x00)
    121a:	8c 81       	ldd	r24, Y+4	; 0x04
    121c:	88 23       	and	r24, r24
    121e:	41 f0       	breq	.+16     	; 0x1230 <LED_Task+0xa0>
		{
			/*LED ON*/
			DIO_WritePin(DIO_PIN12 , HIGH);
    1220:	8c e0       	ldi	r24, 0x0C	; 12
    1222:	61 e0       	ldi	r22, 0x01	; 1
    1224:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
			ReceivedLED_Counter++;
    1228:	89 81       	ldd	r24, Y+1	; 0x01
    122a:	8f 5f       	subi	r24, 0xFF	; 255
    122c:	89 83       	std	Y+1, r24	; 0x01
			ReceivedMessage_Check = 0x00;
    122e:	1c 82       	std	Y+4, r1	; 0x04
		}

		/*to make LED off after specific time*/
		if(ReceivedLED_Counter != 0)
    1230:	89 81       	ldd	r24, Y+1	; 0x01
    1232:	88 23       	and	r24, r24
    1234:	61 f0       	breq	.+24     	; 0x124e <LED_Task+0xbe>
		{
			if(ReceivedLED_Counter < 6)
    1236:	89 81       	ldd	r24, Y+1	; 0x01
    1238:	86 30       	cpi	r24, 0x06	; 6
    123a:	20 f4       	brcc	.+8      	; 0x1244 <LED_Task+0xb4>
			{
				ReceivedLED_Counter++;
    123c:	89 81       	ldd	r24, Y+1	; 0x01
    123e:	8f 5f       	subi	r24, 0xFF	; 255
    1240:	89 83       	std	Y+1, r24	; 0x01
    1242:	05 c0       	rjmp	.+10     	; 0x124e <LED_Task+0xbe>
			}
			else
			{
				/*LED OFF*/
				DIO_WritePin(DIO_PIN12 , LOW);
    1244:	8c e0       	ldi	r24, 0x0C	; 12
    1246:	60 e0       	ldi	r22, 0x00	; 0
    1248:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
				ReceivedLED_Counter = 0;
    124c:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		vTaskDelay(50);
    124e:	82 e3       	ldi	r24, 0x32	; 50
    1250:	90 e0       	ldi	r25, 0x00	; 0
    1252:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
    1256:	a9 cf       	rjmp	.-174    	; 0x11aa <LED_Task+0x1a>

00001258 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
    1258:	df 93       	push	r29
    125a:	cf 93       	push	r28
    125c:	00 d0       	rcall	.+0      	; 0x125e <xEventGroupCreate+0x6>
    125e:	cd b7       	in	r28, 0x3d	; 61
    1260:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    1262:	8b e0       	ldi	r24, 0x0B	; 11
    1264:	90 e0       	ldi	r25, 0x00	; 0
    1266:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <pvPortMalloc>
    126a:	9a 83       	std	Y+2, r25	; 0x02
    126c:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
    126e:	89 81       	ldd	r24, Y+1	; 0x01
    1270:	9a 81       	ldd	r25, Y+2	; 0x02
    1272:	00 97       	sbiw	r24, 0x00	; 0
    1274:	49 f0       	breq	.+18     	; 0x1288 <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
    1276:	e9 81       	ldd	r30, Y+1	; 0x01
    1278:	fa 81       	ldd	r31, Y+2	; 0x02
    127a:	11 82       	std	Z+1, r1	; 0x01
    127c:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    127e:	89 81       	ldd	r24, Y+1	; 0x01
    1280:	9a 81       	ldd	r25, Y+2	; 0x02
    1282:	02 96       	adiw	r24, 0x02	; 2
    1284:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
    1288:	89 81       	ldd	r24, Y+1	; 0x01
    128a:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    128c:	0f 90       	pop	r0
    128e:	0f 90       	pop	r0
    1290:	cf 91       	pop	r28
    1292:	df 91       	pop	r29
    1294:	08 95       	ret

00001296 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    1296:	df 93       	push	r29
    1298:	cf 93       	push	r28
    129a:	cd b7       	in	r28, 0x3d	; 61
    129c:	de b7       	in	r29, 0x3e	; 62
    129e:	60 97       	sbiw	r28, 0x10	; 16
    12a0:	0f b6       	in	r0, 0x3f	; 63
    12a2:	f8 94       	cli
    12a4:	de bf       	out	0x3e, r29	; 62
    12a6:	0f be       	out	0x3f, r0	; 63
    12a8:	cd bf       	out	0x3d, r28	; 61
    12aa:	9a 87       	std	Y+10, r25	; 0x0a
    12ac:	89 87       	std	Y+9, r24	; 0x09
    12ae:	7c 87       	std	Y+12, r23	; 0x0c
    12b0:	6b 87       	std	Y+11, r22	; 0x0b
    12b2:	5e 87       	std	Y+14, r21	; 0x0e
    12b4:	4d 87       	std	Y+13, r20	; 0x0d
    12b6:	38 8b       	std	Y+16, r19	; 0x10
    12b8:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
    12ba:	89 85       	ldd	r24, Y+9	; 0x09
    12bc:	9a 85       	ldd	r25, Y+10	; 0x0a
    12be:	9c 83       	std	Y+4, r25	; 0x04
    12c0:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    12c2:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    12c4:	0e 94 78 26 	call	0x4cf0	; 0x4cf0 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    12c8:	eb 81       	ldd	r30, Y+3	; 0x03
    12ca:	fc 81       	ldd	r31, Y+4	; 0x04
    12cc:	80 81       	ld	r24, Z
    12ce:	91 81       	ldd	r25, Z+1	; 0x01
    12d0:	98 87       	std	Y+8, r25	; 0x08
    12d2:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    12d4:	89 85       	ldd	r24, Y+9	; 0x09
    12d6:	9a 85       	ldd	r25, Y+10	; 0x0a
    12d8:	2b 85       	ldd	r18, Y+11	; 0x0b
    12da:	3c 85       	ldd	r19, Y+12	; 0x0c
    12dc:	b9 01       	movw	r22, r18
    12de:	0e 94 22 0b 	call	0x1644	; 0x1644 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    12e2:	2f 81       	ldd	r18, Y+7	; 0x07
    12e4:	38 85       	ldd	r19, Y+8	; 0x08
    12e6:	8b 85       	ldd	r24, Y+11	; 0x0b
    12e8:	9c 85       	ldd	r25, Y+12	; 0x0c
    12ea:	28 2b       	or	r18, r24
    12ec:	39 2b       	or	r19, r25
    12ee:	8d 85       	ldd	r24, Y+13	; 0x0d
    12f0:	9e 85       	ldd	r25, Y+14	; 0x0e
    12f2:	28 23       	and	r18, r24
    12f4:	39 23       	and	r19, r25
    12f6:	8d 85       	ldd	r24, Y+13	; 0x0d
    12f8:	9e 85       	ldd	r25, Y+14	; 0x0e
    12fa:	28 17       	cp	r18, r24
    12fc:	39 07       	cpc	r19, r25
    12fe:	c9 f4       	brne	.+50     	; 0x1332 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    1300:	2f 81       	ldd	r18, Y+7	; 0x07
    1302:	38 85       	ldd	r19, Y+8	; 0x08
    1304:	8b 85       	ldd	r24, Y+11	; 0x0b
    1306:	9c 85       	ldd	r25, Y+12	; 0x0c
    1308:	82 2b       	or	r24, r18
    130a:	93 2b       	or	r25, r19
    130c:	9e 83       	std	Y+6, r25	; 0x06
    130e:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1310:	eb 81       	ldd	r30, Y+3	; 0x03
    1312:	fc 81       	ldd	r31, Y+4	; 0x04
    1314:	20 81       	ld	r18, Z
    1316:	31 81       	ldd	r19, Z+1	; 0x01
    1318:	8d 85       	ldd	r24, Y+13	; 0x0d
    131a:	9e 85       	ldd	r25, Y+14	; 0x0e
    131c:	80 95       	com	r24
    131e:	90 95       	com	r25
    1320:	82 23       	and	r24, r18
    1322:	93 23       	and	r25, r19
    1324:	eb 81       	ldd	r30, Y+3	; 0x03
    1326:	fc 81       	ldd	r31, Y+4	; 0x04
    1328:	91 83       	std	Z+1, r25	; 0x01
    132a:	80 83       	st	Z, r24

			xTicksToWait = 0;
    132c:	18 8a       	std	Y+16, r1	; 0x10
    132e:	1f 86       	std	Y+15, r1	; 0x0f
    1330:	1e c0       	rjmp	.+60     	; 0x136e <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    1332:	8f 85       	ldd	r24, Y+15	; 0x0f
    1334:	98 89       	ldd	r25, Y+16	; 0x10
    1336:	00 97       	sbiw	r24, 0x00	; 0
    1338:	91 f0       	breq	.+36     	; 0x135e <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    133a:	8b 81       	ldd	r24, Y+3	; 0x03
    133c:	9c 81       	ldd	r25, Y+4	; 0x04
    133e:	bc 01       	movw	r22, r24
    1340:	6e 5f       	subi	r22, 0xFE	; 254
    1342:	7f 4f       	sbci	r23, 0xFF	; 255
    1344:	8d 85       	ldd	r24, Y+13	; 0x0d
    1346:	9e 85       	ldd	r25, Y+14	; 0x0e
    1348:	9c 01       	movw	r18, r24
    134a:	35 60       	ori	r19, 0x05	; 5
    134c:	4f 85       	ldd	r20, Y+15	; 0x0f
    134e:	58 89       	ldd	r21, Y+16	; 0x10
    1350:	cb 01       	movw	r24, r22
    1352:	b9 01       	movw	r22, r18
    1354:	0e 94 e8 28 	call	0x51d0	; 0x51d0 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    1358:	1e 82       	std	Y+6, r1	; 0x06
    135a:	1d 82       	std	Y+5, r1	; 0x05
    135c:	08 c0       	rjmp	.+16     	; 0x136e <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    135e:	eb 81       	ldd	r30, Y+3	; 0x03
    1360:	fc 81       	ldd	r31, Y+4	; 0x04
    1362:	80 81       	ld	r24, Z
    1364:	91 81       	ldd	r25, Z+1	; 0x01
    1366:	9e 83       	std	Y+6, r25	; 0x06
    1368:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
    136a:	81 e0       	ldi	r24, 0x01	; 1
    136c:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    136e:	0e 94 84 26 	call	0x4d08	; 0x4d08 <xTaskResumeAll>
    1372:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
    1374:	8f 85       	ldd	r24, Y+15	; 0x0f
    1376:	98 89       	ldd	r25, Y+16	; 0x10
    1378:	00 97       	sbiw	r24, 0x00	; 0
    137a:	09 f4       	brne	.+2      	; 0x137e <xEventGroupSync+0xe8>
    137c:	3a c0       	rjmp	.+116    	; 0x13f2 <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
    137e:	8a 81       	ldd	r24, Y+2	; 0x02
    1380:	88 23       	and	r24, r24
    1382:	11 f4       	brne	.+4      	; 0x1388 <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
    1384:	0e 94 c2 12 	call	0x2584	; 0x2584 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    1388:	0e 94 5b 2b 	call	0x56b6	; 0x56b6 <uxTaskResetEventItemValue>
    138c:	9e 83       	std	Y+6, r25	; 0x06
    138e:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1390:	8d 81       	ldd	r24, Y+5	; 0x05
    1392:	9e 81       	ldd	r25, Y+6	; 0x06
    1394:	80 70       	andi	r24, 0x00	; 0
    1396:	92 70       	andi	r25, 0x02	; 2
    1398:	00 97       	sbiw	r24, 0x00	; 0
    139a:	31 f5       	brne	.+76     	; 0x13e8 <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    139c:	0f b6       	in	r0, 0x3f	; 63
    139e:	f8 94       	cli
    13a0:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    13a2:	eb 81       	ldd	r30, Y+3	; 0x03
    13a4:	fc 81       	ldd	r31, Y+4	; 0x04
    13a6:	80 81       	ld	r24, Z
    13a8:	91 81       	ldd	r25, Z+1	; 0x01
    13aa:	9e 83       	std	Y+6, r25	; 0x06
    13ac:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    13ae:	2d 81       	ldd	r18, Y+5	; 0x05
    13b0:	3e 81       	ldd	r19, Y+6	; 0x06
    13b2:	8d 85       	ldd	r24, Y+13	; 0x0d
    13b4:	9e 85       	ldd	r25, Y+14	; 0x0e
    13b6:	28 23       	and	r18, r24
    13b8:	39 23       	and	r19, r25
    13ba:	8d 85       	ldd	r24, Y+13	; 0x0d
    13bc:	9e 85       	ldd	r25, Y+14	; 0x0e
    13be:	28 17       	cp	r18, r24
    13c0:	39 07       	cpc	r19, r25
    13c2:	71 f4       	brne	.+28     	; 0x13e0 <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    13c4:	eb 81       	ldd	r30, Y+3	; 0x03
    13c6:	fc 81       	ldd	r31, Y+4	; 0x04
    13c8:	20 81       	ld	r18, Z
    13ca:	31 81       	ldd	r19, Z+1	; 0x01
    13cc:	8d 85       	ldd	r24, Y+13	; 0x0d
    13ce:	9e 85       	ldd	r25, Y+14	; 0x0e
    13d0:	80 95       	com	r24
    13d2:	90 95       	com	r25
    13d4:	82 23       	and	r24, r18
    13d6:	93 23       	and	r25, r19
    13d8:	eb 81       	ldd	r30, Y+3	; 0x03
    13da:	fc 81       	ldd	r31, Y+4	; 0x04
    13dc:	91 83       	std	Z+1, r25	; 0x01
    13de:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    13e0:	0f 90       	pop	r0
    13e2:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    13e4:	81 e0       	ldi	r24, 0x01	; 1
    13e6:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    13e8:	8d 81       	ldd	r24, Y+5	; 0x05
    13ea:	9e 81       	ldd	r25, Y+6	; 0x06
    13ec:	90 70       	andi	r25, 0x00	; 0
    13ee:	9e 83       	std	Y+6, r25	; 0x06
    13f0:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    13f2:	8d 81       	ldd	r24, Y+5	; 0x05
    13f4:	9e 81       	ldd	r25, Y+6	; 0x06
}
    13f6:	60 96       	adiw	r28, 0x10	; 16
    13f8:	0f b6       	in	r0, 0x3f	; 63
    13fa:	f8 94       	cli
    13fc:	de bf       	out	0x3e, r29	; 62
    13fe:	0f be       	out	0x3f, r0	; 63
    1400:	cd bf       	out	0x3d, r28	; 61
    1402:	cf 91       	pop	r28
    1404:	df 91       	pop	r29
    1406:	08 95       	ret

00001408 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    1408:	0f 93       	push	r16
    140a:	1f 93       	push	r17
    140c:	df 93       	push	r29
    140e:	cf 93       	push	r28
    1410:	cd b7       	in	r28, 0x3d	; 61
    1412:	de b7       	in	r29, 0x3e	; 62
    1414:	63 97       	sbiw	r28, 0x13	; 19
    1416:	0f b6       	in	r0, 0x3f	; 63
    1418:	f8 94       	cli
    141a:	de bf       	out	0x3e, r29	; 62
    141c:	0f be       	out	0x3f, r0	; 63
    141e:	cd bf       	out	0x3d, r28	; 61
    1420:	9d 87       	std	Y+13, r25	; 0x0d
    1422:	8c 87       	std	Y+12, r24	; 0x0c
    1424:	7f 87       	std	Y+15, r23	; 0x0f
    1426:	6e 87       	std	Y+14, r22	; 0x0e
    1428:	48 8b       	std	Y+16, r20	; 0x10
    142a:	29 8b       	std	Y+17, r18	; 0x11
    142c:	1b 8b       	std	Y+19, r17	; 0x13
    142e:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
    1430:	8c 85       	ldd	r24, Y+12	; 0x0c
    1432:	9d 85       	ldd	r25, Y+13	; 0x0d
    1434:	9b 87       	std	Y+11, r25	; 0x0b
    1436:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
    1438:	1f 82       	std	Y+7, r1	; 0x07
    143a:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    143c:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    143e:	0e 94 78 26 	call	0x4cf0	; 0x4cf0 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    1442:	ea 85       	ldd	r30, Y+10	; 0x0a
    1444:	fb 85       	ldd	r31, Y+11	; 0x0b
    1446:	80 81       	ld	r24, Z
    1448:	91 81       	ldd	r25, Z+1	; 0x01
    144a:	9a 83       	std	Y+2, r25	; 0x02
    144c:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    144e:	89 81       	ldd	r24, Y+1	; 0x01
    1450:	9a 81       	ldd	r25, Y+2	; 0x02
    1452:	2e 85       	ldd	r18, Y+14	; 0x0e
    1454:	3f 85       	ldd	r19, Y+15	; 0x0f
    1456:	b9 01       	movw	r22, r18
    1458:	49 89       	ldd	r20, Y+17	; 0x11
    145a:	0e 94 3f 0c 	call	0x187e	; 0x187e <prvTestWaitCondition>
    145e:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
    1460:	8d 81       	ldd	r24, Y+5	; 0x05
    1462:	88 23       	and	r24, r24
    1464:	c1 f0       	breq	.+48     	; 0x1496 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    1466:	89 81       	ldd	r24, Y+1	; 0x01
    1468:	9a 81       	ldd	r25, Y+2	; 0x02
    146a:	99 87       	std	Y+9, r25	; 0x09
    146c:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
    146e:	1b 8a       	std	Y+19, r1	; 0x13
    1470:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    1472:	88 89       	ldd	r24, Y+16	; 0x10
    1474:	88 23       	and	r24, r24
    1476:	e9 f1       	breq	.+122    	; 0x14f2 <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1478:	ea 85       	ldd	r30, Y+10	; 0x0a
    147a:	fb 85       	ldd	r31, Y+11	; 0x0b
    147c:	20 81       	ld	r18, Z
    147e:	31 81       	ldd	r19, Z+1	; 0x01
    1480:	8e 85       	ldd	r24, Y+14	; 0x0e
    1482:	9f 85       	ldd	r25, Y+15	; 0x0f
    1484:	80 95       	com	r24
    1486:	90 95       	com	r25
    1488:	82 23       	and	r24, r18
    148a:	93 23       	and	r25, r19
    148c:	ea 85       	ldd	r30, Y+10	; 0x0a
    148e:	fb 85       	ldd	r31, Y+11	; 0x0b
    1490:	91 83       	std	Z+1, r25	; 0x01
    1492:	80 83       	st	Z, r24
    1494:	2e c0       	rjmp	.+92     	; 0x14f2 <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    1496:	8a 89       	ldd	r24, Y+18	; 0x12
    1498:	9b 89       	ldd	r25, Y+19	; 0x13
    149a:	00 97       	sbiw	r24, 0x00	; 0
    149c:	39 f4       	brne	.+14     	; 0x14ac <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    149e:	89 81       	ldd	r24, Y+1	; 0x01
    14a0:	9a 81       	ldd	r25, Y+2	; 0x02
    14a2:	99 87       	std	Y+9, r25	; 0x09
    14a4:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
    14a6:	81 e0       	ldi	r24, 0x01	; 1
    14a8:	8b 83       	std	Y+3, r24	; 0x03
    14aa:	23 c0       	rjmp	.+70     	; 0x14f2 <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    14ac:	88 89       	ldd	r24, Y+16	; 0x10
    14ae:	88 23       	and	r24, r24
    14b0:	29 f0       	breq	.+10     	; 0x14bc <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    14b2:	8e 81       	ldd	r24, Y+6	; 0x06
    14b4:	9f 81       	ldd	r25, Y+7	; 0x07
    14b6:	91 60       	ori	r25, 0x01	; 1
    14b8:	9f 83       	std	Y+7, r25	; 0x07
    14ba:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    14bc:	89 89       	ldd	r24, Y+17	; 0x11
    14be:	88 23       	and	r24, r24
    14c0:	29 f0       	breq	.+10     	; 0x14cc <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    14c2:	8e 81       	ldd	r24, Y+6	; 0x06
    14c4:	9f 81       	ldd	r25, Y+7	; 0x07
    14c6:	94 60       	ori	r25, 0x04	; 4
    14c8:	9f 83       	std	Y+7, r25	; 0x07
    14ca:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    14cc:	8a 85       	ldd	r24, Y+10	; 0x0a
    14ce:	9b 85       	ldd	r25, Y+11	; 0x0b
    14d0:	bc 01       	movw	r22, r24
    14d2:	6e 5f       	subi	r22, 0xFE	; 254
    14d4:	7f 4f       	sbci	r23, 0xFF	; 255
    14d6:	2e 85       	ldd	r18, Y+14	; 0x0e
    14d8:	3f 85       	ldd	r19, Y+15	; 0x0f
    14da:	8e 81       	ldd	r24, Y+6	; 0x06
    14dc:	9f 81       	ldd	r25, Y+7	; 0x07
    14de:	28 2b       	or	r18, r24
    14e0:	39 2b       	or	r19, r25
    14e2:	4a 89       	ldd	r20, Y+18	; 0x12
    14e4:	5b 89       	ldd	r21, Y+19	; 0x13
    14e6:	cb 01       	movw	r24, r22
    14e8:	b9 01       	movw	r22, r18
    14ea:	0e 94 e8 28 	call	0x51d0	; 0x51d0 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    14ee:	19 86       	std	Y+9, r1	; 0x09
    14f0:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    14f2:	0e 94 84 26 	call	0x4d08	; 0x4d08 <xTaskResumeAll>
    14f6:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
    14f8:	8a 89       	ldd	r24, Y+18	; 0x12
    14fa:	9b 89       	ldd	r25, Y+19	; 0x13
    14fc:	00 97       	sbiw	r24, 0x00	; 0
    14fe:	09 f4       	brne	.+2      	; 0x1502 <xEventGroupWaitBits+0xfa>
    1500:	3c c0       	rjmp	.+120    	; 0x157a <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
    1502:	8c 81       	ldd	r24, Y+4	; 0x04
    1504:	88 23       	and	r24, r24
    1506:	11 f4       	brne	.+4      	; 0x150c <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
    1508:	0e 94 c2 12 	call	0x2584	; 0x2584 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    150c:	0e 94 5b 2b 	call	0x56b6	; 0x56b6 <uxTaskResetEventItemValue>
    1510:	99 87       	std	Y+9, r25	; 0x09
    1512:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1514:	88 85       	ldd	r24, Y+8	; 0x08
    1516:	99 85       	ldd	r25, Y+9	; 0x09
    1518:	80 70       	andi	r24, 0x00	; 0
    151a:	92 70       	andi	r25, 0x02	; 2
    151c:	00 97       	sbiw	r24, 0x00	; 0
    151e:	41 f5       	brne	.+80     	; 0x1570 <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
    1520:	0f b6       	in	r0, 0x3f	; 63
    1522:	f8 94       	cli
    1524:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    1526:	ea 85       	ldd	r30, Y+10	; 0x0a
    1528:	fb 85       	ldd	r31, Y+11	; 0x0b
    152a:	80 81       	ld	r24, Z
    152c:	91 81       	ldd	r25, Z+1	; 0x01
    152e:	99 87       	std	Y+9, r25	; 0x09
    1530:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    1532:	88 85       	ldd	r24, Y+8	; 0x08
    1534:	99 85       	ldd	r25, Y+9	; 0x09
    1536:	2e 85       	ldd	r18, Y+14	; 0x0e
    1538:	3f 85       	ldd	r19, Y+15	; 0x0f
    153a:	b9 01       	movw	r22, r18
    153c:	49 89       	ldd	r20, Y+17	; 0x11
    153e:	0e 94 3f 0c 	call	0x187e	; 0x187e <prvTestWaitCondition>
    1542:	88 23       	and	r24, r24
    1544:	89 f0       	breq	.+34     	; 0x1568 <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
    1546:	88 89       	ldd	r24, Y+16	; 0x10
    1548:	88 23       	and	r24, r24
    154a:	71 f0       	breq	.+28     	; 0x1568 <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    154c:	ea 85       	ldd	r30, Y+10	; 0x0a
    154e:	fb 85       	ldd	r31, Y+11	; 0x0b
    1550:	20 81       	ld	r18, Z
    1552:	31 81       	ldd	r19, Z+1	; 0x01
    1554:	8e 85       	ldd	r24, Y+14	; 0x0e
    1556:	9f 85       	ldd	r25, Y+15	; 0x0f
    1558:	80 95       	com	r24
    155a:	90 95       	com	r25
    155c:	82 23       	and	r24, r18
    155e:	93 23       	and	r25, r19
    1560:	ea 85       	ldd	r30, Y+10	; 0x0a
    1562:	fb 85       	ldd	r31, Y+11	; 0x0b
    1564:	91 83       	std	Z+1, r25	; 0x01
    1566:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
    1568:	81 e0       	ldi	r24, 0x01	; 1
    156a:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
    156c:	0f 90       	pop	r0
    156e:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1570:	88 85       	ldd	r24, Y+8	; 0x08
    1572:	99 85       	ldd	r25, Y+9	; 0x09
    1574:	90 70       	andi	r25, 0x00	; 0
    1576:	99 87       	std	Y+9, r25	; 0x09
    1578:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    157a:	88 85       	ldd	r24, Y+8	; 0x08
    157c:	99 85       	ldd	r25, Y+9	; 0x09
}
    157e:	63 96       	adiw	r28, 0x13	; 19
    1580:	0f b6       	in	r0, 0x3f	; 63
    1582:	f8 94       	cli
    1584:	de bf       	out	0x3e, r29	; 62
    1586:	0f be       	out	0x3f, r0	; 63
    1588:	cd bf       	out	0x3d, r28	; 61
    158a:	cf 91       	pop	r28
    158c:	df 91       	pop	r29
    158e:	1f 91       	pop	r17
    1590:	0f 91       	pop	r16
    1592:	08 95       	ret

00001594 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    1594:	df 93       	push	r29
    1596:	cf 93       	push	r28
    1598:	cd b7       	in	r28, 0x3d	; 61
    159a:	de b7       	in	r29, 0x3e	; 62
    159c:	28 97       	sbiw	r28, 0x08	; 8
    159e:	0f b6       	in	r0, 0x3f	; 63
    15a0:	f8 94       	cli
    15a2:	de bf       	out	0x3e, r29	; 62
    15a4:	0f be       	out	0x3f, r0	; 63
    15a6:	cd bf       	out	0x3d, r28	; 61
    15a8:	9e 83       	std	Y+6, r25	; 0x06
    15aa:	8d 83       	std	Y+5, r24	; 0x05
    15ac:	78 87       	std	Y+8, r23	; 0x08
    15ae:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
    15b0:	8d 81       	ldd	r24, Y+5	; 0x05
    15b2:	9e 81       	ldd	r25, Y+6	; 0x06
    15b4:	9c 83       	std	Y+4, r25	; 0x04
    15b6:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    15b8:	0f b6       	in	r0, 0x3f	; 63
    15ba:	f8 94       	cli
    15bc:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    15be:	eb 81       	ldd	r30, Y+3	; 0x03
    15c0:	fc 81       	ldd	r31, Y+4	; 0x04
    15c2:	80 81       	ld	r24, Z
    15c4:	91 81       	ldd	r25, Z+1	; 0x01
    15c6:	9a 83       	std	Y+2, r25	; 0x02
    15c8:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    15ca:	eb 81       	ldd	r30, Y+3	; 0x03
    15cc:	fc 81       	ldd	r31, Y+4	; 0x04
    15ce:	20 81       	ld	r18, Z
    15d0:	31 81       	ldd	r19, Z+1	; 0x01
    15d2:	8f 81       	ldd	r24, Y+7	; 0x07
    15d4:	98 85       	ldd	r25, Y+8	; 0x08
    15d6:	80 95       	com	r24
    15d8:	90 95       	com	r25
    15da:	82 23       	and	r24, r18
    15dc:	93 23       	and	r25, r19
    15de:	eb 81       	ldd	r30, Y+3	; 0x03
    15e0:	fc 81       	ldd	r31, Y+4	; 0x04
    15e2:	91 83       	std	Z+1, r25	; 0x01
    15e4:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
    15e6:	0f 90       	pop	r0
    15e8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    15ea:	89 81       	ldd	r24, Y+1	; 0x01
    15ec:	9a 81       	ldd	r25, Y+2	; 0x02
}
    15ee:	28 96       	adiw	r28, 0x08	; 8
    15f0:	0f b6       	in	r0, 0x3f	; 63
    15f2:	f8 94       	cli
    15f4:	de bf       	out	0x3e, r29	; 62
    15f6:	0f be       	out	0x3f, r0	; 63
    15f8:	cd bf       	out	0x3d, r28	; 61
    15fa:	cf 91       	pop	r28
    15fc:	df 91       	pop	r29
    15fe:	08 95       	ret

00001600 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    1600:	df 93       	push	r29
    1602:	cf 93       	push	r28
    1604:	cd b7       	in	r28, 0x3d	; 61
    1606:	de b7       	in	r29, 0x3e	; 62
    1608:	27 97       	sbiw	r28, 0x07	; 7
    160a:	0f b6       	in	r0, 0x3f	; 63
    160c:	f8 94       	cli
    160e:	de bf       	out	0x3e, r29	; 62
    1610:	0f be       	out	0x3f, r0	; 63
    1612:	cd bf       	out	0x3d, r28	; 61
    1614:	9f 83       	std	Y+7, r25	; 0x07
    1616:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
    1618:	8e 81       	ldd	r24, Y+6	; 0x06
    161a:	9f 81       	ldd	r25, Y+7	; 0x07
    161c:	9c 83       	std	Y+4, r25	; 0x04
    161e:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1620:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
    1622:	eb 81       	ldd	r30, Y+3	; 0x03
    1624:	fc 81       	ldd	r31, Y+4	; 0x04
    1626:	80 81       	ld	r24, Z
    1628:	91 81       	ldd	r25, Z+1	; 0x01
    162a:	9a 83       	std	Y+2, r25	; 0x02
    162c:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    162e:	89 81       	ldd	r24, Y+1	; 0x01
    1630:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    1632:	27 96       	adiw	r28, 0x07	; 7
    1634:	0f b6       	in	r0, 0x3f	; 63
    1636:	f8 94       	cli
    1638:	de bf       	out	0x3e, r29	; 62
    163a:	0f be       	out	0x3f, r0	; 63
    163c:	cd bf       	out	0x3d, r28	; 61
    163e:	cf 91       	pop	r28
    1640:	df 91       	pop	r29
    1642:	08 95       	ret

00001644 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    1644:	df 93       	push	r29
    1646:	cf 93       	push	r28
    1648:	cd b7       	in	r28, 0x3d	; 61
    164a:	de b7       	in	r29, 0x3e	; 62
    164c:	65 97       	sbiw	r28, 0x15	; 21
    164e:	0f b6       	in	r0, 0x3f	; 63
    1650:	f8 94       	cli
    1652:	de bf       	out	0x3e, r29	; 62
    1654:	0f be       	out	0x3f, r0	; 63
    1656:	cd bf       	out	0x3d, r28	; 61
    1658:	9b 8b       	std	Y+19, r25	; 0x13
    165a:	8a 8b       	std	Y+18, r24	; 0x12
    165c:	7d 8b       	std	Y+21, r23	; 0x15
    165e:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    1660:	19 86       	std	Y+9, r1	; 0x09
    1662:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
    1664:	8a 89       	ldd	r24, Y+18	; 0x12
    1666:	9b 89       	ldd	r25, Y+19	; 0x13
    1668:	9b 83       	std	Y+3, r25	; 0x03
    166a:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
    166c:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    166e:	8a 81       	ldd	r24, Y+2	; 0x02
    1670:	9b 81       	ldd	r25, Y+3	; 0x03
    1672:	02 96       	adiw	r24, 0x02	; 2
    1674:	9b 87       	std	Y+11, r25	; 0x0b
    1676:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1678:	8a 85       	ldd	r24, Y+10	; 0x0a
    167a:	9b 85       	ldd	r25, Y+11	; 0x0b
    167c:	03 96       	adiw	r24, 0x03	; 3
    167e:	9d 87       	std	Y+13, r25	; 0x0d
    1680:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
    1682:	0e 94 78 26 	call	0x4cf0	; 0x4cf0 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    1686:	ea 85       	ldd	r30, Y+10	; 0x0a
    1688:	fb 85       	ldd	r31, Y+11	; 0x0b
    168a:	85 81       	ldd	r24, Z+5	; 0x05
    168c:	96 81       	ldd	r25, Z+6	; 0x06
    168e:	99 8b       	std	Y+17, r25	; 0x11
    1690:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    1692:	ea 81       	ldd	r30, Y+2	; 0x02
    1694:	fb 81       	ldd	r31, Y+3	; 0x03
    1696:	20 81       	ld	r18, Z
    1698:	31 81       	ldd	r19, Z+1	; 0x01
    169a:	8c 89       	ldd	r24, Y+20	; 0x14
    169c:	9d 89       	ldd	r25, Y+21	; 0x15
    169e:	82 2b       	or	r24, r18
    16a0:	93 2b       	or	r25, r19
    16a2:	ea 81       	ldd	r30, Y+2	; 0x02
    16a4:	fb 81       	ldd	r31, Y+3	; 0x03
    16a6:	91 83       	std	Z+1, r25	; 0x01
    16a8:	80 83       	st	Z, r24
    16aa:	59 c0       	rjmp	.+178    	; 0x175e <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
    16ac:	e8 89       	ldd	r30, Y+16	; 0x10
    16ae:	f9 89       	ldd	r31, Y+17	; 0x11
    16b0:	82 81       	ldd	r24, Z+2	; 0x02
    16b2:	93 81       	ldd	r25, Z+3	; 0x03
    16b4:	9f 87       	std	Y+15, r25	; 0x0f
    16b6:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    16b8:	e8 89       	ldd	r30, Y+16	; 0x10
    16ba:	f9 89       	ldd	r31, Y+17	; 0x11
    16bc:	80 81       	ld	r24, Z
    16be:	91 81       	ldd	r25, Z+1	; 0x01
    16c0:	9f 83       	std	Y+7, r25	; 0x07
    16c2:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
    16c4:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    16c6:	8e 81       	ldd	r24, Y+6	; 0x06
    16c8:	9f 81       	ldd	r25, Y+7	; 0x07
    16ca:	80 70       	andi	r24, 0x00	; 0
    16cc:	9d 83       	std	Y+5, r25	; 0x05
    16ce:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    16d0:	8e 81       	ldd	r24, Y+6	; 0x06
    16d2:	9f 81       	ldd	r25, Y+7	; 0x07
    16d4:	90 70       	andi	r25, 0x00	; 0
    16d6:	9f 83       	std	Y+7, r25	; 0x07
    16d8:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    16da:	8c 81       	ldd	r24, Y+4	; 0x04
    16dc:	9d 81       	ldd	r25, Y+5	; 0x05
    16de:	80 70       	andi	r24, 0x00	; 0
    16e0:	94 70       	andi	r25, 0x04	; 4
    16e2:	00 97       	sbiw	r24, 0x00	; 0
    16e4:	69 f4       	brne	.+26     	; 0x1700 <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    16e6:	ea 81       	ldd	r30, Y+2	; 0x02
    16e8:	fb 81       	ldd	r31, Y+3	; 0x03
    16ea:	20 81       	ld	r18, Z
    16ec:	31 81       	ldd	r19, Z+1	; 0x01
    16ee:	8e 81       	ldd	r24, Y+6	; 0x06
    16f0:	9f 81       	ldd	r25, Y+7	; 0x07
    16f2:	82 23       	and	r24, r18
    16f4:	93 23       	and	r25, r19
    16f6:	00 97       	sbiw	r24, 0x00	; 0
    16f8:	91 f0       	breq	.+36     	; 0x171e <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
    16fa:	81 e0       	ldi	r24, 0x01	; 1
    16fc:	89 83       	std	Y+1, r24	; 0x01
    16fe:	0f c0       	rjmp	.+30     	; 0x171e <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    1700:	ea 81       	ldd	r30, Y+2	; 0x02
    1702:	fb 81       	ldd	r31, Y+3	; 0x03
    1704:	20 81       	ld	r18, Z
    1706:	31 81       	ldd	r19, Z+1	; 0x01
    1708:	8e 81       	ldd	r24, Y+6	; 0x06
    170a:	9f 81       	ldd	r25, Y+7	; 0x07
    170c:	28 23       	and	r18, r24
    170e:	39 23       	and	r19, r25
    1710:	8e 81       	ldd	r24, Y+6	; 0x06
    1712:	9f 81       	ldd	r25, Y+7	; 0x07
    1714:	28 17       	cp	r18, r24
    1716:	39 07       	cpc	r19, r25
    1718:	11 f4       	brne	.+4      	; 0x171e <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    171a:	81 e0       	ldi	r24, 0x01	; 1
    171c:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    171e:	89 81       	ldd	r24, Y+1	; 0x01
    1720:	88 23       	and	r24, r24
    1722:	c9 f0       	breq	.+50     	; 0x1756 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    1724:	8c 81       	ldd	r24, Y+4	; 0x04
    1726:	9d 81       	ldd	r25, Y+5	; 0x05
    1728:	80 70       	andi	r24, 0x00	; 0
    172a:	91 70       	andi	r25, 0x01	; 1
    172c:	00 97       	sbiw	r24, 0x00	; 0
    172e:	41 f0       	breq	.+16     	; 0x1740 <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    1730:	88 85       	ldd	r24, Y+8	; 0x08
    1732:	99 85       	ldd	r25, Y+9	; 0x09
    1734:	2e 81       	ldd	r18, Y+6	; 0x06
    1736:	3f 81       	ldd	r19, Y+7	; 0x07
    1738:	82 2b       	or	r24, r18
    173a:	93 2b       	or	r25, r19
    173c:	99 87       	std	Y+9, r25	; 0x09
    173e:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    1740:	ea 81       	ldd	r30, Y+2	; 0x02
    1742:	fb 81       	ldd	r31, Y+3	; 0x03
    1744:	80 81       	ld	r24, Z
    1746:	91 81       	ldd	r25, Z+1	; 0x01
    1748:	9c 01       	movw	r18, r24
    174a:	32 60       	ori	r19, 0x02	; 2
    174c:	88 89       	ldd	r24, Y+16	; 0x10
    174e:	99 89       	ldd	r25, Y+17	; 0x11
    1750:	b9 01       	movw	r22, r18
    1752:	0e 94 83 29 	call	0x5306	; 0x5306 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    1756:	8e 85       	ldd	r24, Y+14	; 0x0e
    1758:	9f 85       	ldd	r25, Y+15	; 0x0f
    175a:	99 8b       	std	Y+17, r25	; 0x11
    175c:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    175e:	28 89       	ldd	r18, Y+16	; 0x10
    1760:	39 89       	ldd	r19, Y+17	; 0x11
    1762:	8c 85       	ldd	r24, Y+12	; 0x0c
    1764:	9d 85       	ldd	r25, Y+13	; 0x0d
    1766:	28 17       	cp	r18, r24
    1768:	39 07       	cpc	r19, r25
    176a:	09 f0       	breq	.+2      	; 0x176e <xEventGroupSetBits+0x12a>
    176c:	9f cf       	rjmp	.-194    	; 0x16ac <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    176e:	ea 81       	ldd	r30, Y+2	; 0x02
    1770:	fb 81       	ldd	r31, Y+3	; 0x03
    1772:	20 81       	ld	r18, Z
    1774:	31 81       	ldd	r19, Z+1	; 0x01
    1776:	88 85       	ldd	r24, Y+8	; 0x08
    1778:	99 85       	ldd	r25, Y+9	; 0x09
    177a:	80 95       	com	r24
    177c:	90 95       	com	r25
    177e:	82 23       	and	r24, r18
    1780:	93 23       	and	r25, r19
    1782:	ea 81       	ldd	r30, Y+2	; 0x02
    1784:	fb 81       	ldd	r31, Y+3	; 0x03
    1786:	91 83       	std	Z+1, r25	; 0x01
    1788:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
    178a:	0e 94 84 26 	call	0x4d08	; 0x4d08 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    178e:	ea 81       	ldd	r30, Y+2	; 0x02
    1790:	fb 81       	ldd	r31, Y+3	; 0x03
    1792:	80 81       	ld	r24, Z
    1794:	91 81       	ldd	r25, Z+1	; 0x01
}
    1796:	65 96       	adiw	r28, 0x15	; 21
    1798:	0f b6       	in	r0, 0x3f	; 63
    179a:	f8 94       	cli
    179c:	de bf       	out	0x3e, r29	; 62
    179e:	0f be       	out	0x3f, r0	; 63
    17a0:	cd bf       	out	0x3d, r28	; 61
    17a2:	cf 91       	pop	r28
    17a4:	df 91       	pop	r29
    17a6:	08 95       	ret

000017a8 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    17a8:	df 93       	push	r29
    17aa:	cf 93       	push	r28
    17ac:	00 d0       	rcall	.+0      	; 0x17ae <vEventGroupDelete+0x6>
    17ae:	00 d0       	rcall	.+0      	; 0x17b0 <vEventGroupDelete+0x8>
    17b0:	00 d0       	rcall	.+0      	; 0x17b2 <vEventGroupDelete+0xa>
    17b2:	cd b7       	in	r28, 0x3d	; 61
    17b4:	de b7       	in	r29, 0x3e	; 62
    17b6:	9e 83       	std	Y+6, r25	; 0x06
    17b8:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
    17ba:	8d 81       	ldd	r24, Y+5	; 0x05
    17bc:	9e 81       	ldd	r25, Y+6	; 0x06
    17be:	9c 83       	std	Y+4, r25	; 0x04
    17c0:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    17c2:	8b 81       	ldd	r24, Y+3	; 0x03
    17c4:	9c 81       	ldd	r25, Y+4	; 0x04
    17c6:	02 96       	adiw	r24, 0x02	; 2
    17c8:	9a 83       	std	Y+2, r25	; 0x02
    17ca:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
    17cc:	0e 94 78 26 	call	0x4cf0	; 0x4cf0 <vTaskSuspendAll>
    17d0:	08 c0       	rjmp	.+16     	; 0x17e2 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    17d2:	e9 81       	ldd	r30, Y+1	; 0x01
    17d4:	fa 81       	ldd	r31, Y+2	; 0x02
    17d6:	85 81       	ldd	r24, Z+5	; 0x05
    17d8:	96 81       	ldd	r25, Z+6	; 0x06
    17da:	60 e0       	ldi	r22, 0x00	; 0
    17dc:	72 e0       	ldi	r23, 0x02	; 2
    17de:	0e 94 83 29 	call	0x5306	; 0x5306 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    17e2:	e9 81       	ldd	r30, Y+1	; 0x01
    17e4:	fa 81       	ldd	r31, Y+2	; 0x02
    17e6:	80 81       	ld	r24, Z
    17e8:	88 23       	and	r24, r24
    17ea:	99 f7       	brne	.-26     	; 0x17d2 <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
    17ec:	8b 81       	ldd	r24, Y+3	; 0x03
    17ee:	9c 81       	ldd	r25, Y+4	; 0x04
    17f0:	0e 94 c7 0c 	call	0x198e	; 0x198e <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
    17f4:	0e 94 84 26 	call	0x4d08	; 0x4d08 <xTaskResumeAll>
}
    17f8:	26 96       	adiw	r28, 0x06	; 6
    17fa:	0f b6       	in	r0, 0x3f	; 63
    17fc:	f8 94       	cli
    17fe:	de bf       	out	0x3e, r29	; 62
    1800:	0f be       	out	0x3f, r0	; 63
    1802:	cd bf       	out	0x3d, r28	; 61
    1804:	cf 91       	pop	r28
    1806:	df 91       	pop	r29
    1808:	08 95       	ret

0000180a <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    180a:	df 93       	push	r29
    180c:	cf 93       	push	r28
    180e:	00 d0       	rcall	.+0      	; 0x1810 <vEventGroupSetBitsCallback+0x6>
    1810:	00 d0       	rcall	.+0      	; 0x1812 <vEventGroupSetBitsCallback+0x8>
    1812:	00 d0       	rcall	.+0      	; 0x1814 <vEventGroupSetBitsCallback+0xa>
    1814:	cd b7       	in	r28, 0x3d	; 61
    1816:	de b7       	in	r29, 0x3e	; 62
    1818:	9a 83       	std	Y+2, r25	; 0x02
    181a:	89 83       	std	Y+1, r24	; 0x01
    181c:	4b 83       	std	Y+3, r20	; 0x03
    181e:	5c 83       	std	Y+4, r21	; 0x04
    1820:	6d 83       	std	Y+5, r22	; 0x05
    1822:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1824:	89 81       	ldd	r24, Y+1	; 0x01
    1826:	9a 81       	ldd	r25, Y+2	; 0x02
    1828:	2b 81       	ldd	r18, Y+3	; 0x03
    182a:	3c 81       	ldd	r19, Y+4	; 0x04
    182c:	b9 01       	movw	r22, r18
    182e:	0e 94 22 0b 	call	0x1644	; 0x1644 <xEventGroupSetBits>
}
    1832:	26 96       	adiw	r28, 0x06	; 6
    1834:	0f b6       	in	r0, 0x3f	; 63
    1836:	f8 94       	cli
    1838:	de bf       	out	0x3e, r29	; 62
    183a:	0f be       	out	0x3f, r0	; 63
    183c:	cd bf       	out	0x3d, r28	; 61
    183e:	cf 91       	pop	r28
    1840:	df 91       	pop	r29
    1842:	08 95       	ret

00001844 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    1844:	df 93       	push	r29
    1846:	cf 93       	push	r28
    1848:	00 d0       	rcall	.+0      	; 0x184a <vEventGroupClearBitsCallback+0x6>
    184a:	00 d0       	rcall	.+0      	; 0x184c <vEventGroupClearBitsCallback+0x8>
    184c:	00 d0       	rcall	.+0      	; 0x184e <vEventGroupClearBitsCallback+0xa>
    184e:	cd b7       	in	r28, 0x3d	; 61
    1850:	de b7       	in	r29, 0x3e	; 62
    1852:	9a 83       	std	Y+2, r25	; 0x02
    1854:	89 83       	std	Y+1, r24	; 0x01
    1856:	4b 83       	std	Y+3, r20	; 0x03
    1858:	5c 83       	std	Y+4, r21	; 0x04
    185a:	6d 83       	std	Y+5, r22	; 0x05
    185c:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    185e:	89 81       	ldd	r24, Y+1	; 0x01
    1860:	9a 81       	ldd	r25, Y+2	; 0x02
    1862:	2b 81       	ldd	r18, Y+3	; 0x03
    1864:	3c 81       	ldd	r19, Y+4	; 0x04
    1866:	b9 01       	movw	r22, r18
    1868:	0e 94 ca 0a 	call	0x1594	; 0x1594 <xEventGroupClearBits>
}
    186c:	26 96       	adiw	r28, 0x06	; 6
    186e:	0f b6       	in	r0, 0x3f	; 63
    1870:	f8 94       	cli
    1872:	de bf       	out	0x3e, r29	; 62
    1874:	0f be       	out	0x3f, r0	; 63
    1876:	cd bf       	out	0x3d, r28	; 61
    1878:	cf 91       	pop	r28
    187a:	df 91       	pop	r29
    187c:	08 95       	ret

0000187e <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    187e:	df 93       	push	r29
    1880:	cf 93       	push	r28
    1882:	00 d0       	rcall	.+0      	; 0x1884 <prvTestWaitCondition+0x6>
    1884:	00 d0       	rcall	.+0      	; 0x1886 <prvTestWaitCondition+0x8>
    1886:	00 d0       	rcall	.+0      	; 0x1888 <prvTestWaitCondition+0xa>
    1888:	cd b7       	in	r28, 0x3d	; 61
    188a:	de b7       	in	r29, 0x3e	; 62
    188c:	9b 83       	std	Y+3, r25	; 0x03
    188e:	8a 83       	std	Y+2, r24	; 0x02
    1890:	7d 83       	std	Y+5, r23	; 0x05
    1892:	6c 83       	std	Y+4, r22	; 0x04
    1894:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    1896:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    1898:	8e 81       	ldd	r24, Y+6	; 0x06
    189a:	88 23       	and	r24, r24
    189c:	59 f4       	brne	.+22     	; 0x18b4 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    189e:	8a 81       	ldd	r24, Y+2	; 0x02
    18a0:	9b 81       	ldd	r25, Y+3	; 0x03
    18a2:	2c 81       	ldd	r18, Y+4	; 0x04
    18a4:	3d 81       	ldd	r19, Y+5	; 0x05
    18a6:	82 23       	and	r24, r18
    18a8:	93 23       	and	r25, r19
    18aa:	00 97       	sbiw	r24, 0x00	; 0
    18ac:	81 f0       	breq	.+32     	; 0x18ce <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    18ae:	81 e0       	ldi	r24, 0x01	; 1
    18b0:	89 83       	std	Y+1, r24	; 0x01
    18b2:	0d c0       	rjmp	.+26     	; 0x18ce <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    18b4:	2a 81       	ldd	r18, Y+2	; 0x02
    18b6:	3b 81       	ldd	r19, Y+3	; 0x03
    18b8:	8c 81       	ldd	r24, Y+4	; 0x04
    18ba:	9d 81       	ldd	r25, Y+5	; 0x05
    18bc:	28 23       	and	r18, r24
    18be:	39 23       	and	r19, r25
    18c0:	8c 81       	ldd	r24, Y+4	; 0x04
    18c2:	9d 81       	ldd	r25, Y+5	; 0x05
    18c4:	28 17       	cp	r18, r24
    18c6:	39 07       	cpc	r19, r25
    18c8:	11 f4       	brne	.+4      	; 0x18ce <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    18ca:	81 e0       	ldi	r24, 0x01	; 1
    18cc:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    18ce:	89 81       	ldd	r24, Y+1	; 0x01
}
    18d0:	26 96       	adiw	r28, 0x06	; 6
    18d2:	0f b6       	in	r0, 0x3f	; 63
    18d4:	f8 94       	cli
    18d6:	de bf       	out	0x3e, r29	; 62
    18d8:	0f be       	out	0x3f, r0	; 63
    18da:	cd bf       	out	0x3d, r28	; 61
    18dc:	cf 91       	pop	r28
    18de:	df 91       	pop	r29
    18e0:	08 95       	ret

000018e2 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    18e2:	df 93       	push	r29
    18e4:	cf 93       	push	r28
    18e6:	00 d0       	rcall	.+0      	; 0x18e8 <pvPortMalloc+0x6>
    18e8:	00 d0       	rcall	.+0      	; 0x18ea <pvPortMalloc+0x8>
    18ea:	cd b7       	in	r28, 0x3d	; 61
    18ec:	de b7       	in	r29, 0x3e	; 62
    18ee:	9c 83       	std	Y+4, r25	; 0x04
    18f0:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    18f2:	1a 82       	std	Y+2, r1	; 0x02
    18f4:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    18f6:	0e 94 78 26 	call	0x4cf0	; 0x4cf0 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    18fa:	80 91 f0 00 	lds	r24, 0x00F0
    18fe:	90 91 f1 00 	lds	r25, 0x00F1
    1902:	00 97       	sbiw	r24, 0x00	; 0
    1904:	31 f4       	brne	.+12     	; 0x1912 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1906:	83 ef       	ldi	r24, 0xF3	; 243
    1908:	90 e0       	ldi	r25, 0x00	; 0
    190a:	90 93 f1 00 	sts	0x00F1, r25
    190e:	80 93 f0 00 	sts	0x00F0, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1912:	80 91 ee 00 	lds	r24, 0x00EE
    1916:	90 91 ef 00 	lds	r25, 0x00EF
    191a:	2b 81       	ldd	r18, Y+3	; 0x03
    191c:	3c 81       	ldd	r19, Y+4	; 0x04
    191e:	82 0f       	add	r24, r18
    1920:	93 1f       	adc	r25, r19
    1922:	25 e0       	ldi	r18, 0x05	; 5
    1924:	8b 3d       	cpi	r24, 0xDB	; 219
    1926:	92 07       	cpc	r25, r18
    1928:	38 f5       	brcc	.+78     	; 0x1978 <pvPortMalloc+0x96>
    192a:	20 91 ee 00 	lds	r18, 0x00EE
    192e:	30 91 ef 00 	lds	r19, 0x00EF
    1932:	8b 81       	ldd	r24, Y+3	; 0x03
    1934:	9c 81       	ldd	r25, Y+4	; 0x04
    1936:	28 0f       	add	r18, r24
    1938:	39 1f       	adc	r19, r25
    193a:	80 91 ee 00 	lds	r24, 0x00EE
    193e:	90 91 ef 00 	lds	r25, 0x00EF
    1942:	82 17       	cp	r24, r18
    1944:	93 07       	cpc	r25, r19
    1946:	c0 f4       	brcc	.+48     	; 0x1978 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1948:	20 91 f0 00 	lds	r18, 0x00F0
    194c:	30 91 f1 00 	lds	r19, 0x00F1
    1950:	80 91 ee 00 	lds	r24, 0x00EE
    1954:	90 91 ef 00 	lds	r25, 0x00EF
    1958:	82 0f       	add	r24, r18
    195a:	93 1f       	adc	r25, r19
    195c:	9a 83       	std	Y+2, r25	; 0x02
    195e:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    1960:	20 91 ee 00 	lds	r18, 0x00EE
    1964:	30 91 ef 00 	lds	r19, 0x00EF
    1968:	8b 81       	ldd	r24, Y+3	; 0x03
    196a:	9c 81       	ldd	r25, Y+4	; 0x04
    196c:	82 0f       	add	r24, r18
    196e:	93 1f       	adc	r25, r19
    1970:	90 93 ef 00 	sts	0x00EF, r25
    1974:	80 93 ee 00 	sts	0x00EE, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1978:	0e 94 84 26 	call	0x4d08	; 0x4d08 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    197c:	89 81       	ldd	r24, Y+1	; 0x01
    197e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1980:	0f 90       	pop	r0
    1982:	0f 90       	pop	r0
    1984:	0f 90       	pop	r0
    1986:	0f 90       	pop	r0
    1988:	cf 91       	pop	r28
    198a:	df 91       	pop	r29
    198c:	08 95       	ret

0000198e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    198e:	df 93       	push	r29
    1990:	cf 93       	push	r28
    1992:	00 d0       	rcall	.+0      	; 0x1994 <vPortFree+0x6>
    1994:	cd b7       	in	r28, 0x3d	; 61
    1996:	de b7       	in	r29, 0x3e	; 62
    1998:	9a 83       	std	Y+2, r25	; 0x02
    199a:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    199c:	0f 90       	pop	r0
    199e:	0f 90       	pop	r0
    19a0:	cf 91       	pop	r28
    19a2:	df 91       	pop	r29
    19a4:	08 95       	ret

000019a6 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    19a6:	df 93       	push	r29
    19a8:	cf 93       	push	r28
    19aa:	cd b7       	in	r28, 0x3d	; 61
    19ac:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    19ae:	10 92 ef 00 	sts	0x00EF, r1
    19b2:	10 92 ee 00 	sts	0x00EE, r1
}
    19b6:	cf 91       	pop	r28
    19b8:	df 91       	pop	r29
    19ba:	08 95       	ret

000019bc <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    19bc:	df 93       	push	r29
    19be:	cf 93       	push	r28
    19c0:	cd b7       	in	r28, 0x3d	; 61
    19c2:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    19c4:	20 91 ee 00 	lds	r18, 0x00EE
    19c8:	30 91 ef 00 	lds	r19, 0x00EF
    19cc:	8b ed       	ldi	r24, 0xDB	; 219
    19ce:	95 e0       	ldi	r25, 0x05	; 5
    19d0:	82 1b       	sub	r24, r18
    19d2:	93 0b       	sbc	r25, r19
}
    19d4:	cf 91       	pop	r28
    19d6:	df 91       	pop	r29
    19d8:	08 95       	ret

000019da <KeyPad_Init>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void KeyPad_Init(void)
{
    19da:	df 93       	push	r29
    19dc:	cf 93       	push	r28
    19de:	cd b7       	in	r28, 0x3d	; 61
    19e0:	de b7       	in	r29, 0x3e	; 62
	/*set Pins Of KeyPad*/
	DIO_SetPinDirection(DIO_PIN18,INPUT);
    19e2:	82 e1       	ldi	r24, 0x12	; 18
    19e4:	60 e0       	ldi	r22, 0x00	; 0
    19e6:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
	DIO_SetPinDirection(DIO_PIN19,INPUT);
    19ea:	83 e1       	ldi	r24, 0x13	; 19
    19ec:	60 e0       	ldi	r22, 0x00	; 0
    19ee:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
	DIO_SetPinDirection(DIO_PIN20,INPUT);
    19f2:	84 e1       	ldi	r24, 0x14	; 20
    19f4:	60 e0       	ldi	r22, 0x00	; 0
    19f6:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
	DIO_SetPinDirection(DIO_PIN21,OUTPUT);
    19fa:	85 e1       	ldi	r24, 0x15	; 21
    19fc:	61 e0       	ldi	r22, 0x01	; 1
    19fe:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
	DIO_SetPinDirection(DIO_PIN22,OUTPUT);
    1a02:	86 e1       	ldi	r24, 0x16	; 22
    1a04:	61 e0       	ldi	r22, 0x01	; 1
    1a06:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
	DIO_SetPinDirection(DIO_PIN23,OUTPUT);
    1a0a:	87 e1       	ldi	r24, 0x17	; 23
    1a0c:	61 e0       	ldi	r22, 0x01	; 1
    1a0e:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
	DIO_WritePin(DIO_PIN18,HIGH);
    1a12:	82 e1       	ldi	r24, 0x12	; 18
    1a14:	61 e0       	ldi	r22, 0x01	; 1
    1a16:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
	DIO_WritePin(DIO_PIN19,HIGH);
    1a1a:	83 e1       	ldi	r24, 0x13	; 19
    1a1c:	61 e0       	ldi	r22, 0x01	; 1
    1a1e:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
	DIO_WritePin(DIO_PIN20,HIGH);
    1a22:	84 e1       	ldi	r24, 0x14	; 20
    1a24:	61 e0       	ldi	r22, 0x01	; 1
    1a26:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
	DIO_WritePin(DIO_PIN21,LOW);
    1a2a:	85 e1       	ldi	r24, 0x15	; 21
    1a2c:	60 e0       	ldi	r22, 0x00	; 0
    1a2e:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
	DIO_WritePin(DIO_PIN22,LOW);
    1a32:	86 e1       	ldi	r24, 0x16	; 22
    1a34:	60 e0       	ldi	r22, 0x00	; 0
    1a36:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
	DIO_WritePin(DIO_PIN23,LOW);
    1a3a:	87 e1       	ldi	r24, 0x17	; 23
    1a3c:	60 e0       	ldi	r22, 0x00	; 0
    1a3e:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
}
    1a42:	cf 91       	pop	r28
    1a44:	df 91       	pop	r29
    1a46:	08 95       	ret

00001a48 <KeyPad_getPressedKey>:
 * Outputs:			NULL
 *
 * Return:			pressed key (uint8)
 *******************************************************************************/
uint8 KeyPad_getPressedKey(void)
{
    1a48:	df 93       	push	r29
    1a4a:	cf 93       	push	r28
    1a4c:	00 d0       	rcall	.+0      	; 0x1a4e <KeyPad_getPressedKey+0x6>
    1a4e:	00 d0       	rcall	.+0      	; 0x1a50 <KeyPad_getPressedKey+0x8>
    1a50:	cd b7       	in	r28, 0x3d	; 61
    1a52:	de b7       	in	r29, 0x3e	; 62
	/*return value*/
	uint8 ReturnVal=10;
    1a54:	8a e0       	ldi	r24, 0x0A	; 10
    1a56:	8b 83       	std	Y+3, r24	; 0x03

	/*variables use to loop pn rows and column*/
	uint8 row,col;

	/*Loop to check if Key is pressed to return its value*/
	for(col=0;col<N_COL;col++)
    1a58:	19 82       	std	Y+1, r1	; 0x01
    1a5a:	42 c0       	rjmp	.+132    	; 0x1ae0 <KeyPad_getPressedKey+0x98>
	{
		KEYPAD_PORT_DIR = (0b00100000<<col);
    1a5c:	e4 e3       	ldi	r30, 0x34	; 52
    1a5e:	f0 e0       	ldi	r31, 0x00	; 0
    1a60:	89 81       	ldd	r24, Y+1	; 0x01
    1a62:	28 2f       	mov	r18, r24
    1a64:	30 e0       	ldi	r19, 0x00	; 0
    1a66:	80 e2       	ldi	r24, 0x20	; 32
    1a68:	90 e0       	ldi	r25, 0x00	; 0
    1a6a:	02 c0       	rjmp	.+4      	; 0x1a70 <KeyPad_getPressedKey+0x28>
    1a6c:	88 0f       	add	r24, r24
    1a6e:	99 1f       	adc	r25, r25
    1a70:	2a 95       	dec	r18
    1a72:	e2 f7       	brpl	.-8      	; 0x1a6c <KeyPad_getPressedKey+0x24>
    1a74:	80 83       	st	Z, r24
		KEYPAD_PORT_OUT = (~(0b00100000<<col));
    1a76:	e5 e3       	ldi	r30, 0x35	; 53
    1a78:	f0 e0       	ldi	r31, 0x00	; 0
    1a7a:	89 81       	ldd	r24, Y+1	; 0x01
    1a7c:	28 2f       	mov	r18, r24
    1a7e:	30 e0       	ldi	r19, 0x00	; 0
    1a80:	80 e2       	ldi	r24, 0x20	; 32
    1a82:	90 e0       	ldi	r25, 0x00	; 0
    1a84:	02 2e       	mov	r0, r18
    1a86:	02 c0       	rjmp	.+4      	; 0x1a8c <KeyPad_getPressedKey+0x44>
    1a88:	88 0f       	add	r24, r24
    1a8a:	99 1f       	adc	r25, r25
    1a8c:	0a 94       	dec	r0
    1a8e:	e2 f7       	brpl	.-8      	; 0x1a88 <KeyPad_getPressedKey+0x40>
    1a90:	80 95       	com	r24
    1a92:	80 83       	st	Z, r24

		for(row=START_ROW;row<END_ROW;row++)
    1a94:	82 e0       	ldi	r24, 0x02	; 2
    1a96:	8a 83       	std	Y+2, r24	; 0x02
    1a98:	1d c0       	rjmp	.+58     	; 0x1ad4 <KeyPad_getPressedKey+0x8c>
		{
			if(GET_BIT(KEYPAD_PORT_IN,row) == 0)
    1a9a:	e3 e3       	ldi	r30, 0x33	; 51
    1a9c:	f0 e0       	ldi	r31, 0x00	; 0
    1a9e:	80 81       	ld	r24, Z
    1aa0:	28 2f       	mov	r18, r24
    1aa2:	30 e0       	ldi	r19, 0x00	; 0
    1aa4:	8a 81       	ldd	r24, Y+2	; 0x02
    1aa6:	88 2f       	mov	r24, r24
    1aa8:	90 e0       	ldi	r25, 0x00	; 0
    1aaa:	a9 01       	movw	r20, r18
    1aac:	02 c0       	rjmp	.+4      	; 0x1ab2 <KeyPad_getPressedKey+0x6a>
    1aae:	55 95       	asr	r21
    1ab0:	47 95       	ror	r20
    1ab2:	8a 95       	dec	r24
    1ab4:	e2 f7       	brpl	.-8      	; 0x1aae <KeyPad_getPressedKey+0x66>
    1ab6:	ca 01       	movw	r24, r20
    1ab8:	81 70       	andi	r24, 0x01	; 1
    1aba:	90 70       	andi	r25, 0x00	; 0
    1abc:	00 97       	sbiw	r24, 0x00	; 0
    1abe:	39 f4       	brne	.+14     	; 0x1ace <KeyPad_getPressedKey+0x86>
				/*check on Configurations Mode*/
#if(N_COL ==3)
#if(N_ROW == 3)

				/*return value of pressed Key*/
				return  KeyPad_3x3_switch(row-START_ROW,col);
    1ac0:	8a 81       	ldd	r24, Y+2	; 0x02
    1ac2:	82 50       	subi	r24, 0x02	; 2
    1ac4:	69 81       	ldd	r22, Y+1	; 0x01
    1ac6:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <KeyPad_3x3_switch>
    1aca:	8c 83       	std	Y+4, r24	; 0x04
    1acc:	0f c0       	rjmp	.+30     	; 0x1aec <KeyPad_getPressedKey+0xa4>
	for(col=0;col<N_COL;col++)
	{
		KEYPAD_PORT_DIR = (0b00100000<<col);
		KEYPAD_PORT_OUT = (~(0b00100000<<col));

		for(row=START_ROW;row<END_ROW;row++)
    1ace:	8a 81       	ldd	r24, Y+2	; 0x02
    1ad0:	8f 5f       	subi	r24, 0xFF	; 255
    1ad2:	8a 83       	std	Y+2, r24	; 0x02
    1ad4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ad6:	85 30       	cpi	r24, 0x05	; 5
    1ad8:	00 f3       	brcs	.-64     	; 0x1a9a <KeyPad_getPressedKey+0x52>

	/*variables use to loop pn rows and column*/
	uint8 row,col;

	/*Loop to check if Key is pressed to return its value*/
	for(col=0;col<N_COL;col++)
    1ada:	89 81       	ldd	r24, Y+1	; 0x01
    1adc:	8f 5f       	subi	r24, 0xFF	; 255
    1ade:	89 83       	std	Y+1, r24	; 0x01
    1ae0:	89 81       	ldd	r24, Y+1	; 0x01
    1ae2:	83 30       	cpi	r24, 0x03	; 3
    1ae4:	08 f4       	brcc	.+2      	; 0x1ae8 <KeyPad_getPressedKey+0xa0>
    1ae6:	ba cf       	rjmp	.-140    	; 0x1a5c <KeyPad_getPressedKey+0x14>
				return KeyPad_4x4_switch(row-START_ROW,col);
#endif
			}
		}
	}
	return ReturnVal;
    1ae8:	5b 81       	ldd	r21, Y+3	; 0x03
    1aea:	5c 83       	std	Y+4, r21	; 0x04
    1aec:	8c 81       	ldd	r24, Y+4	; 0x04
}
    1aee:	0f 90       	pop	r0
    1af0:	0f 90       	pop	r0
    1af2:	0f 90       	pop	r0
    1af4:	0f 90       	pop	r0
    1af6:	cf 91       	pop	r28
    1af8:	df 91       	pop	r29
    1afa:	08 95       	ret

00001afc <KeyPad_3x3_switch>:
 * Outputs:			NULL
 *
 * Return:			value of Pressed Key (uint8)
 *******************************************************************************/
static uint8 KeyPad_3x3_switch(uint8 row, uint8 col)
{
    1afc:	df 93       	push	r29
    1afe:	cf 93       	push	r28
    1b00:	cd b7       	in	r28, 0x3d	; 61
    1b02:	de b7       	in	r29, 0x3e	; 62
    1b04:	2b 97       	sbiw	r28, 0x0b	; 11
    1b06:	0f b6       	in	r0, 0x3f	; 63
    1b08:	f8 94       	cli
    1b0a:	de bf       	out	0x3e, r29	; 62
    1b0c:	0f be       	out	0x3f, r0	; 63
    1b0e:	cd bf       	out	0x3d, r28	; 61
    1b10:	8a 83       	std	Y+2, r24	; 0x02
    1b12:	6b 83       	std	Y+3, r22	; 0x03
	/*variable of return value*/
	uint8 ReturnVal = 0;
    1b14:	19 82       	std	Y+1, r1	; 0x01

	/*determine row of pressed key*/
	switch(row)
    1b16:	8a 81       	ldd	r24, Y+2	; 0x02
    1b18:	28 2f       	mov	r18, r24
    1b1a:	30 e0       	ldi	r19, 0x00	; 0
    1b1c:	3b 87       	std	Y+11, r19	; 0x0b
    1b1e:	2a 87       	std	Y+10, r18	; 0x0a
    1b20:	8a 85       	ldd	r24, Y+10	; 0x0a
    1b22:	9b 85       	ldd	r25, Y+11	; 0x0b
    1b24:	81 30       	cpi	r24, 0x01	; 1
    1b26:	91 05       	cpc	r25, r1
    1b28:	41 f1       	breq	.+80     	; 0x1b7a <KeyPad_3x3_switch+0x7e>
    1b2a:	2a 85       	ldd	r18, Y+10	; 0x0a
    1b2c:	3b 85       	ldd	r19, Y+11	; 0x0b
    1b2e:	22 30       	cpi	r18, 0x02	; 2
    1b30:	31 05       	cpc	r19, r1
    1b32:	09 f4       	brne	.+2      	; 0x1b36 <KeyPad_3x3_switch+0x3a>
    1b34:	3e c0       	rjmp	.+124    	; 0x1bb2 <KeyPad_3x3_switch+0xb6>
    1b36:	8a 85       	ldd	r24, Y+10	; 0x0a
    1b38:	9b 85       	ldd	r25, Y+11	; 0x0b
    1b3a:	00 97       	sbiw	r24, 0x00	; 0
    1b3c:	09 f0       	breq	.+2      	; 0x1b40 <KeyPad_3x3_switch+0x44>
    1b3e:	54 c0       	rjmp	.+168    	; 0x1be8 <KeyPad_3x3_switch+0xec>
	{
	case 0:
		/*determine column of pressed key*/
		switch(col)
    1b40:	8b 81       	ldd	r24, Y+3	; 0x03
    1b42:	28 2f       	mov	r18, r24
    1b44:	30 e0       	ldi	r19, 0x00	; 0
    1b46:	39 87       	std	Y+9, r19	; 0x09
    1b48:	28 87       	std	Y+8, r18	; 0x08
    1b4a:	88 85       	ldd	r24, Y+8	; 0x08
    1b4c:	99 85       	ldd	r25, Y+9	; 0x09
    1b4e:	81 30       	cpi	r24, 0x01	; 1
    1b50:	91 05       	cpc	r25, r1
    1b52:	69 f0       	breq	.+26     	; 0x1b6e <KeyPad_3x3_switch+0x72>
    1b54:	28 85       	ldd	r18, Y+8	; 0x08
    1b56:	39 85       	ldd	r19, Y+9	; 0x09
    1b58:	22 30       	cpi	r18, 0x02	; 2
    1b5a:	31 05       	cpc	r19, r1
    1b5c:	59 f0       	breq	.+22     	; 0x1b74 <KeyPad_3x3_switch+0x78>
    1b5e:	88 85       	ldd	r24, Y+8	; 0x08
    1b60:	99 85       	ldd	r25, Y+9	; 0x09
    1b62:	00 97       	sbiw	r24, 0x00	; 0
    1b64:	09 f0       	breq	.+2      	; 0x1b68 <KeyPad_3x3_switch+0x6c>
    1b66:	40 c0       	rjmp	.+128    	; 0x1be8 <KeyPad_3x3_switch+0xec>
		{
		case 0: ReturnVal = R1C1;
    1b68:	81 e0       	ldi	r24, 0x01	; 1
    1b6a:	89 83       	std	Y+1, r24	; 0x01
    1b6c:	3d c0       	rjmp	.+122    	; 0x1be8 <KeyPad_3x3_switch+0xec>
			break;
		case 1: ReturnVal = R1C2;
    1b6e:	82 e0       	ldi	r24, 0x02	; 2
    1b70:	89 83       	std	Y+1, r24	; 0x01
    1b72:	3a c0       	rjmp	.+116    	; 0x1be8 <KeyPad_3x3_switch+0xec>
			break;
		case 2: ReturnVal = R1C3;
    1b74:	83 e0       	ldi	r24, 0x03	; 3
    1b76:	89 83       	std	Y+1, r24	; 0x01
    1b78:	37 c0       	rjmp	.+110    	; 0x1be8 <KeyPad_3x3_switch+0xec>
		}
		break;

	case 1:
		/*determine column of pressed key*/
		switch(col)
    1b7a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b7c:	28 2f       	mov	r18, r24
    1b7e:	30 e0       	ldi	r19, 0x00	; 0
    1b80:	3f 83       	std	Y+7, r19	; 0x07
    1b82:	2e 83       	std	Y+6, r18	; 0x06
    1b84:	8e 81       	ldd	r24, Y+6	; 0x06
    1b86:	9f 81       	ldd	r25, Y+7	; 0x07
    1b88:	81 30       	cpi	r24, 0x01	; 1
    1b8a:	91 05       	cpc	r25, r1
    1b8c:	61 f0       	breq	.+24     	; 0x1ba6 <KeyPad_3x3_switch+0xaa>
    1b8e:	2e 81       	ldd	r18, Y+6	; 0x06
    1b90:	3f 81       	ldd	r19, Y+7	; 0x07
    1b92:	22 30       	cpi	r18, 0x02	; 2
    1b94:	31 05       	cpc	r19, r1
    1b96:	51 f0       	breq	.+20     	; 0x1bac <KeyPad_3x3_switch+0xb0>
    1b98:	8e 81       	ldd	r24, Y+6	; 0x06
    1b9a:	9f 81       	ldd	r25, Y+7	; 0x07
    1b9c:	00 97       	sbiw	r24, 0x00	; 0
    1b9e:	21 f5       	brne	.+72     	; 0x1be8 <KeyPad_3x3_switch+0xec>
		{
		case 0: ReturnVal = R2C1;
    1ba0:	84 e0       	ldi	r24, 0x04	; 4
    1ba2:	89 83       	std	Y+1, r24	; 0x01
    1ba4:	21 c0       	rjmp	.+66     	; 0x1be8 <KeyPad_3x3_switch+0xec>
			break;
		case 1: ReturnVal = R2C2;
    1ba6:	85 e0       	ldi	r24, 0x05	; 5
    1ba8:	89 83       	std	Y+1, r24	; 0x01
    1baa:	1e c0       	rjmp	.+60     	; 0x1be8 <KeyPad_3x3_switch+0xec>
			break;
		case 2: ReturnVal = R2C3;
    1bac:	86 e0       	ldi	r24, 0x06	; 6
    1bae:	89 83       	std	Y+1, r24	; 0x01
    1bb0:	1b c0       	rjmp	.+54     	; 0x1be8 <KeyPad_3x3_switch+0xec>
			break;
		}
			break;
	case 2:
		/*determine column of pressed key*/
		switch(col)
    1bb2:	8b 81       	ldd	r24, Y+3	; 0x03
    1bb4:	28 2f       	mov	r18, r24
    1bb6:	30 e0       	ldi	r19, 0x00	; 0
    1bb8:	3d 83       	std	Y+5, r19	; 0x05
    1bba:	2c 83       	std	Y+4, r18	; 0x04
    1bbc:	8c 81       	ldd	r24, Y+4	; 0x04
    1bbe:	9d 81       	ldd	r25, Y+5	; 0x05
    1bc0:	81 30       	cpi	r24, 0x01	; 1
    1bc2:	91 05       	cpc	r25, r1
    1bc4:	61 f0       	breq	.+24     	; 0x1bde <KeyPad_3x3_switch+0xe2>
    1bc6:	2c 81       	ldd	r18, Y+4	; 0x04
    1bc8:	3d 81       	ldd	r19, Y+5	; 0x05
    1bca:	22 30       	cpi	r18, 0x02	; 2
    1bcc:	31 05       	cpc	r19, r1
    1bce:	51 f0       	breq	.+20     	; 0x1be4 <KeyPad_3x3_switch+0xe8>
    1bd0:	8c 81       	ldd	r24, Y+4	; 0x04
    1bd2:	9d 81       	ldd	r25, Y+5	; 0x05
    1bd4:	00 97       	sbiw	r24, 0x00	; 0
    1bd6:	41 f4       	brne	.+16     	; 0x1be8 <KeyPad_3x3_switch+0xec>
		{
		case 0: ReturnVal = R3C1;
    1bd8:	87 e0       	ldi	r24, 0x07	; 7
    1bda:	89 83       	std	Y+1, r24	; 0x01
    1bdc:	05 c0       	rjmp	.+10     	; 0x1be8 <KeyPad_3x3_switch+0xec>
			break;
		case 1: ReturnVal = R3C2;
    1bde:	88 e0       	ldi	r24, 0x08	; 8
    1be0:	89 83       	std	Y+1, r24	; 0x01
    1be2:	02 c0       	rjmp	.+4      	; 0x1be8 <KeyPad_3x3_switch+0xec>
			break;
		case 2: ReturnVal = R3C3;
    1be4:	89 e0       	ldi	r24, 0x09	; 9
    1be6:	89 83       	std	Y+1, r24	; 0x01
		}
		break;
	}

	/*return value of pressed key*/
	return ReturnVal;
    1be8:	89 81       	ldd	r24, Y+1	; 0x01
}
    1bea:	2b 96       	adiw	r28, 0x0b	; 11
    1bec:	0f b6       	in	r0, 0x3f	; 63
    1bee:	f8 94       	cli
    1bf0:	de bf       	out	0x3e, r29	; 62
    1bf2:	0f be       	out	0x3f, r0	; 63
    1bf4:	cd bf       	out	0x3d, r28	; 61
    1bf6:	cf 91       	pop	r28
    1bf8:	df 91       	pop	r29
    1bfa:	08 95       	ret

00001bfc <LCD_init>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_init(void)
{
    1bfc:	df 93       	push	r29
    1bfe:	cf 93       	push	r28
    1c00:	cd b7       	in	r28, 0x3d	; 61
    1c02:	de b7       	in	r29, 0x3e	; 62

	LCD_CTRL_PORT_DIR |= (1<<E) | (1<<RS) | (1<<RW); /* Configure the control pins(E,RS,RW) as output pins */
    1c04:	aa e3       	ldi	r26, 0x3A	; 58
    1c06:	b0 e0       	ldi	r27, 0x00	; 0
    1c08:	ea e3       	ldi	r30, 0x3A	; 58
    1c0a:	f0 e0       	ldi	r31, 0x00	; 0
    1c0c:	80 81       	ld	r24, Z
    1c0e:	8e 60       	ori	r24, 0x0E	; 14
    1c10:	8c 93       	st	X, r24

#if (DATA_BITS_MODE == 4)
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT_DIR |= 0xF0; /* Configure the highest 4 bits of the data port as output pins */
    1c12:	aa e3       	ldi	r26, 0x3A	; 58
    1c14:	b0 e0       	ldi	r27, 0x00	; 0
    1c16:	ea e3       	ldi	r30, 0x3A	; 58
    1c18:	f0 e0       	ldi	r31, 0x00	; 0
    1c1a:	80 81       	ld	r24, Z
    1c1c:	80 6f       	ori	r24, 0xF0	; 240
    1c1e:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT_DIR |= 0x0F; /* Configure the lowest 4 bits of the data port as output pins */
#endif

	LCD_sendCommand(FOUR_BITS_DATA_MODE); /* initialize LCD in 4-bit mode */
    1c20:	82 e0       	ldi	r24, 0x02	; 2
    1c22:	0e 94 1f 0e 	call	0x1c3e	; 0x1c3e <LCD_sendCommand>

	LCD_sendCommand(TWO_LINE_LCD_Four_BIT_MODE); /* use 2-line lcd + 4-bit Data Mode + 5*7 dot display Mode */
    1c26:	88 e2       	ldi	r24, 0x28	; 40
    1c28:	0e 94 1f 0e 	call	0x1c3e	; 0x1c3e <LCD_sendCommand>
#elif (DATA_BITS_MODE == 8)
	LCD_DATA_PORT_DIR = 0xFF; /* Configure the data port as output port */
	LCD_sendCommand(TWO_LINE_LCD_Eight_BIT_MODE); /* use 2-line lcd + 8-bit Data Mode + 5*7 dot display Mode */
#endif

	LCD_sendCommand(CURSOR_OFF); /* cursor off */
    1c2c:	8c e0       	ldi	r24, 0x0C	; 12
    1c2e:	0e 94 1f 0e 	call	0x1c3e	; 0x1c3e <LCD_sendCommand>
	LCD_sendCommand(CLEAR_COMMAND); /* clear LCD at the beginning */
    1c32:	81 e0       	ldi	r24, 0x01	; 1
    1c34:	0e 94 1f 0e 	call	0x1c3e	; 0x1c3e <LCD_sendCommand>

}
    1c38:	cf 91       	pop	r28
    1c3a:	df 91       	pop	r29
    1c3c:	08 95       	ret

00001c3e <LCD_sendCommand>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_sendCommand(uint8 command)
{
    1c3e:	df 93       	push	r29
    1c40:	cf 93       	push	r28
    1c42:	0f 92       	push	r0
    1c44:	cd b7       	in	r28, 0x3d	; 61
    1c46:	de b7       	in	r29, 0x3e	; 62
    1c48:	89 83       	std	Y+1, r24	; 0x01
	CLEAR_BIT(LCD_CTRL_PORT,RS); /* Instruction Mode RS=0 */
    1c4a:	ab e3       	ldi	r26, 0x3B	; 59
    1c4c:	b0 e0       	ldi	r27, 0x00	; 0
    1c4e:	eb e3       	ldi	r30, 0x3B	; 59
    1c50:	f0 e0       	ldi	r31, 0x00	; 0
    1c52:	80 81       	ld	r24, Z
    1c54:	8d 7f       	andi	r24, 0xFD	; 253
    1c56:	8c 93       	st	X, r24
	CLEAR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
    1c58:	ab e3       	ldi	r26, 0x3B	; 59
    1c5a:	b0 e0       	ldi	r27, 0x00	; 0
    1c5c:	eb e3       	ldi	r30, 0x3B	; 59
    1c5e:	f0 e0       	ldi	r31, 0x00	; 0
    1c60:	80 81       	ld	r24, Z
    1c62:	8b 7f       	andi	r24, 0xFB	; 251
    1c64:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tas = 50ns */
    1c66:	81 e0       	ldi	r24, 0x01	; 1
    1c68:	90 e0       	ldi	r25, 0x00	; 0
    1c6a:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    1c6e:	ab e3       	ldi	r26, 0x3B	; 59
    1c70:	b0 e0       	ldi	r27, 0x00	; 0
    1c72:	eb e3       	ldi	r30, 0x3B	; 59
    1c74:	f0 e0       	ldi	r31, 0x00	; 0
    1c76:	80 81       	ld	r24, Z
    1c78:	88 60       	ori	r24, 0x08	; 8
    1c7a:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    1c7c:	81 e0       	ldi	r24, 0x01	; 1
    1c7e:	90 e0       	ldi	r25, 0x00	; 0
    1c80:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
#if (DATA_BITS_MODE == 4)
	/* out the highest 4 bits of the required command to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (command & 0xF0);
    1c84:	ab e3       	ldi	r26, 0x3B	; 59
    1c86:	b0 e0       	ldi	r27, 0x00	; 0
    1c88:	eb e3       	ldi	r30, 0x3B	; 59
    1c8a:	f0 e0       	ldi	r31, 0x00	; 0
    1c8c:	80 81       	ld	r24, Z
    1c8e:	98 2f       	mov	r25, r24
    1c90:	9f 70       	andi	r25, 0x0F	; 15
    1c92:	89 81       	ldd	r24, Y+1	; 0x01
    1c94:	80 7f       	andi	r24, 0xF0	; 240
    1c96:	89 2b       	or	r24, r25
    1c98:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | ((command & 0xF0) >> 4);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    1c9a:	81 e0       	ldi	r24, 0x01	; 1
    1c9c:	90 e0       	ldi	r25, 0x00	; 0
    1c9e:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    1ca2:	ab e3       	ldi	r26, 0x3B	; 59
    1ca4:	b0 e0       	ldi	r27, 0x00	; 0
    1ca6:	eb e3       	ldi	r30, 0x3B	; 59
    1ca8:	f0 e0       	ldi	r31, 0x00	; 0
    1caa:	80 81       	ld	r24, Z
    1cac:	87 7f       	andi	r24, 0xF7	; 247
    1cae:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    1cb0:	81 e0       	ldi	r24, 0x01	; 1
    1cb2:	90 e0       	ldi	r25, 0x00	; 0
    1cb4:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    1cb8:	ab e3       	ldi	r26, 0x3B	; 59
    1cba:	b0 e0       	ldi	r27, 0x00	; 0
    1cbc:	eb e3       	ldi	r30, 0x3B	; 59
    1cbe:	f0 e0       	ldi	r31, 0x00	; 0
    1cc0:	80 81       	ld	r24, Z
    1cc2:	88 60       	ori	r24, 0x08	; 8
    1cc4:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    1cc6:	81 e0       	ldi	r24, 0x01	; 1
    1cc8:	90 e0       	ldi	r25, 0x00	; 0
    1cca:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>

	/* out the lowest 4 bits of the required command to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | ((command & 0x0F) << 4);
    1cce:	ab e3       	ldi	r26, 0x3B	; 59
    1cd0:	b0 e0       	ldi	r27, 0x00	; 0
    1cd2:	eb e3       	ldi	r30, 0x3B	; 59
    1cd4:	f0 e0       	ldi	r31, 0x00	; 0
    1cd6:	80 81       	ld	r24, Z
    1cd8:	28 2f       	mov	r18, r24
    1cda:	2f 70       	andi	r18, 0x0F	; 15
    1cdc:	89 81       	ldd	r24, Y+1	; 0x01
    1cde:	88 2f       	mov	r24, r24
    1ce0:	90 e0       	ldi	r25, 0x00	; 0
    1ce2:	82 95       	swap	r24
    1ce4:	92 95       	swap	r25
    1ce6:	90 7f       	andi	r25, 0xF0	; 240
    1ce8:	98 27       	eor	r25, r24
    1cea:	80 7f       	andi	r24, 0xF0	; 240
    1cec:	98 27       	eor	r25, r24
    1cee:	82 2b       	or	r24, r18
    1cf0:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (command & 0x0F);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    1cf2:	81 e0       	ldi	r24, 0x01	; 1
    1cf4:	90 e0       	ldi	r25, 0x00	; 0
    1cf6:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    1cfa:	ab e3       	ldi	r26, 0x3B	; 59
    1cfc:	b0 e0       	ldi	r27, 0x00	; 0
    1cfe:	eb e3       	ldi	r30, 0x3B	; 59
    1d00:	f0 e0       	ldi	r31, 0x00	; 0
    1d02:	80 81       	ld	r24, Z
    1d04:	87 7f       	andi	r24, 0xF7	; 247
    1d06:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    1d08:	81 e0       	ldi	r24, 0x01	; 1
    1d0a:	90 e0       	ldi	r25, 0x00	; 0
    1d0c:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
	LCD_DATA_PORT = command; /* out the required command to the data bus D0 --> D7 */
	_delay_us(600); /* delay for processing Tdsw = 100ns */
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
	_delay_us(600); /* delay for processing Th = 13ns */
#endif
}
    1d10:	0f 90       	pop	r0
    1d12:	cf 91       	pop	r28
    1d14:	df 91       	pop	r29
    1d16:	08 95       	ret

00001d18 <LCD_displayCharacter>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayCharacter(uint8 data)
{
    1d18:	df 93       	push	r29
    1d1a:	cf 93       	push	r28
    1d1c:	0f 92       	push	r0
    1d1e:	cd b7       	in	r28, 0x3d	; 61
    1d20:	de b7       	in	r29, 0x3e	; 62
    1d22:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(LCD_CTRL_PORT,RS); /* Data Mode RS=1 */
    1d24:	ab e3       	ldi	r26, 0x3B	; 59
    1d26:	b0 e0       	ldi	r27, 0x00	; 0
    1d28:	eb e3       	ldi	r30, 0x3B	; 59
    1d2a:	f0 e0       	ldi	r31, 0x00	; 0
    1d2c:	80 81       	ld	r24, Z
    1d2e:	82 60       	ori	r24, 0x02	; 2
    1d30:	8c 93       	st	X, r24
	CLEAR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
    1d32:	ab e3       	ldi	r26, 0x3B	; 59
    1d34:	b0 e0       	ldi	r27, 0x00	; 0
    1d36:	eb e3       	ldi	r30, 0x3B	; 59
    1d38:	f0 e0       	ldi	r31, 0x00	; 0
    1d3a:	80 81       	ld	r24, Z
    1d3c:	8b 7f       	andi	r24, 0xFB	; 251
    1d3e:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tas = 50ns */
    1d40:	81 e0       	ldi	r24, 0x01	; 1
    1d42:	90 e0       	ldi	r25, 0x00	; 0
    1d44:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    1d48:	ab e3       	ldi	r26, 0x3B	; 59
    1d4a:	b0 e0       	ldi	r27, 0x00	; 0
    1d4c:	eb e3       	ldi	r30, 0x3B	; 59
    1d4e:	f0 e0       	ldi	r31, 0x00	; 0
    1d50:	80 81       	ld	r24, Z
    1d52:	88 60       	ori	r24, 0x08	; 8
    1d54:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    1d56:	81 e0       	ldi	r24, 0x01	; 1
    1d58:	90 e0       	ldi	r25, 0x00	; 0
    1d5a:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
#if (DATA_BITS_MODE == 4)
	/* out the highest 4 bits of the required data to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (data & 0xF0);
    1d5e:	ab e3       	ldi	r26, 0x3B	; 59
    1d60:	b0 e0       	ldi	r27, 0x00	; 0
    1d62:	eb e3       	ldi	r30, 0x3B	; 59
    1d64:	f0 e0       	ldi	r31, 0x00	; 0
    1d66:	80 81       	ld	r24, Z
    1d68:	98 2f       	mov	r25, r24
    1d6a:	9f 70       	andi	r25, 0x0F	; 15
    1d6c:	89 81       	ldd	r24, Y+1	; 0x01
    1d6e:	80 7f       	andi	r24, 0xF0	; 240
    1d70:	89 2b       	or	r24, r25
    1d72:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | ((data & 0xF0) >> 4);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    1d74:	81 e0       	ldi	r24, 0x01	; 1
    1d76:	90 e0       	ldi	r25, 0x00	; 0
    1d78:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    1d7c:	ab e3       	ldi	r26, 0x3B	; 59
    1d7e:	b0 e0       	ldi	r27, 0x00	; 0
    1d80:	eb e3       	ldi	r30, 0x3B	; 59
    1d82:	f0 e0       	ldi	r31, 0x00	; 0
    1d84:	80 81       	ld	r24, Z
    1d86:	87 7f       	andi	r24, 0xF7	; 247
    1d88:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    1d8a:	81 e0       	ldi	r24, 0x01	; 1
    1d8c:	90 e0       	ldi	r25, 0x00	; 0
    1d8e:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    1d92:	ab e3       	ldi	r26, 0x3B	; 59
    1d94:	b0 e0       	ldi	r27, 0x00	; 0
    1d96:	eb e3       	ldi	r30, 0x3B	; 59
    1d98:	f0 e0       	ldi	r31, 0x00	; 0
    1d9a:	80 81       	ld	r24, Z
    1d9c:	88 60       	ori	r24, 0x08	; 8
    1d9e:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    1da0:	81 e0       	ldi	r24, 0x01	; 1
    1da2:	90 e0       	ldi	r25, 0x00	; 0
    1da4:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>

	/* out the lowest 4 bits of the required data to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | ((data & 0x0F) << 4);
    1da8:	ab e3       	ldi	r26, 0x3B	; 59
    1daa:	b0 e0       	ldi	r27, 0x00	; 0
    1dac:	eb e3       	ldi	r30, 0x3B	; 59
    1dae:	f0 e0       	ldi	r31, 0x00	; 0
    1db0:	80 81       	ld	r24, Z
    1db2:	28 2f       	mov	r18, r24
    1db4:	2f 70       	andi	r18, 0x0F	; 15
    1db6:	89 81       	ldd	r24, Y+1	; 0x01
    1db8:	88 2f       	mov	r24, r24
    1dba:	90 e0       	ldi	r25, 0x00	; 0
    1dbc:	82 95       	swap	r24
    1dbe:	92 95       	swap	r25
    1dc0:	90 7f       	andi	r25, 0xF0	; 240
    1dc2:	98 27       	eor	r25, r24
    1dc4:	80 7f       	andi	r24, 0xF0	; 240
    1dc6:	98 27       	eor	r25, r24
    1dc8:	82 2b       	or	r24, r18
    1dca:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (data & 0x0F);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    1dcc:	81 e0       	ldi	r24, 0x01	; 1
    1dce:	90 e0       	ldi	r25, 0x00	; 0
    1dd0:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    1dd4:	ab e3       	ldi	r26, 0x3B	; 59
    1dd6:	b0 e0       	ldi	r27, 0x00	; 0
    1dd8:	eb e3       	ldi	r30, 0x3B	; 59
    1dda:	f0 e0       	ldi	r31, 0x00	; 0
    1ddc:	80 81       	ld	r24, Z
    1dde:	87 7f       	andi	r24, 0xF7	; 247
    1de0:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    1de2:	81 e0       	ldi	r24, 0x01	; 1
    1de4:	90 e0       	ldi	r25, 0x00	; 0
    1de6:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskDelay>
	LCD_DATA_PORT = command; /* out the required command to the data bus D0 --> D7 */
	_delay_us(600); /* delay for processing Tdsw = 100ns */
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
	_delay_us(600); /* delay for processing Th = 13ns */
#endif
}
    1dea:	0f 90       	pop	r0
    1dec:	cf 91       	pop	r28
    1dee:	df 91       	pop	r29
    1df0:	08 95       	ret

00001df2 <LCD_displayString>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayString(const uint8 *Str)
{
    1df2:	df 93       	push	r29
    1df4:	cf 93       	push	r28
    1df6:	00 d0       	rcall	.+0      	; 0x1df8 <LCD_displayString+0x6>
    1df8:	0f 92       	push	r0
    1dfa:	cd b7       	in	r28, 0x3d	; 61
    1dfc:	de b7       	in	r29, 0x3e	; 62
    1dfe:	9b 83       	std	Y+3, r25	; 0x03
    1e00:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    1e02:	19 82       	std	Y+1, r1	; 0x01
    1e04:	0e c0       	rjmp	.+28     	; 0x1e22 <LCD_displayString+0x30>
	/*use loop to send string byte by byte to display on LCD*/
	while(Str[i] != '\0')
	{
		LCD_displayCharacter(Str[i]);
    1e06:	89 81       	ldd	r24, Y+1	; 0x01
    1e08:	28 2f       	mov	r18, r24
    1e0a:	30 e0       	ldi	r19, 0x00	; 0
    1e0c:	8a 81       	ldd	r24, Y+2	; 0x02
    1e0e:	9b 81       	ldd	r25, Y+3	; 0x03
    1e10:	fc 01       	movw	r30, r24
    1e12:	e2 0f       	add	r30, r18
    1e14:	f3 1f       	adc	r31, r19
    1e16:	80 81       	ld	r24, Z
    1e18:	0e 94 8c 0e 	call	0x1d18	; 0x1d18 <LCD_displayCharacter>
		i++;
    1e1c:	89 81       	ldd	r24, Y+1	; 0x01
    1e1e:	8f 5f       	subi	r24, 0xFF	; 255
    1e20:	89 83       	std	Y+1, r24	; 0x01
 *******************************************************************************/
void LCD_displayString(const uint8 *Str)
{
	uint8 i = 0;
	/*use loop to send string byte by byte to display on LCD*/
	while(Str[i] != '\0')
    1e22:	89 81       	ldd	r24, Y+1	; 0x01
    1e24:	28 2f       	mov	r18, r24
    1e26:	30 e0       	ldi	r19, 0x00	; 0
    1e28:	8a 81       	ldd	r24, Y+2	; 0x02
    1e2a:	9b 81       	ldd	r25, Y+3	; 0x03
    1e2c:	fc 01       	movw	r30, r24
    1e2e:	e2 0f       	add	r30, r18
    1e30:	f3 1f       	adc	r31, r19
    1e32:	80 81       	ld	r24, Z
    1e34:	88 23       	and	r24, r24
    1e36:	39 f7       	brne	.-50     	; 0x1e06 <LCD_displayString+0x14>
	{
		LCD_displayCharacter(*Str);
		Str++;
	}		
	 *********************************************************/
}
    1e38:	0f 90       	pop	r0
    1e3a:	0f 90       	pop	r0
    1e3c:	0f 90       	pop	r0
    1e3e:	cf 91       	pop	r28
    1e40:	df 91       	pop	r29
    1e42:	08 95       	ret

00001e44 <LCD_goToRowColumn>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_goToRowColumn(uint8 row,uint8 col)
{
    1e44:	df 93       	push	r29
    1e46:	cf 93       	push	r28
    1e48:	00 d0       	rcall	.+0      	; 0x1e4a <LCD_goToRowColumn+0x6>
    1e4a:	00 d0       	rcall	.+0      	; 0x1e4c <LCD_goToRowColumn+0x8>
    1e4c:	0f 92       	push	r0
    1e4e:	cd b7       	in	r28, 0x3d	; 61
    1e50:	de b7       	in	r29, 0x3e	; 62
    1e52:	8a 83       	std	Y+2, r24	; 0x02
    1e54:	6b 83       	std	Y+3, r22	; 0x03
	uint8 Address;

	/* first of all calculate the required address */
	switch(row)
    1e56:	8a 81       	ldd	r24, Y+2	; 0x02
    1e58:	28 2f       	mov	r18, r24
    1e5a:	30 e0       	ldi	r19, 0x00	; 0
    1e5c:	3d 83       	std	Y+5, r19	; 0x05
    1e5e:	2c 83       	std	Y+4, r18	; 0x04
    1e60:	8c 81       	ldd	r24, Y+4	; 0x04
    1e62:	9d 81       	ldd	r25, Y+5	; 0x05
    1e64:	81 30       	cpi	r24, 0x01	; 1
    1e66:	91 05       	cpc	r25, r1
    1e68:	c1 f0       	breq	.+48     	; 0x1e9a <LCD_goToRowColumn+0x56>
    1e6a:	2c 81       	ldd	r18, Y+4	; 0x04
    1e6c:	3d 81       	ldd	r19, Y+5	; 0x05
    1e6e:	22 30       	cpi	r18, 0x02	; 2
    1e70:	31 05       	cpc	r19, r1
    1e72:	2c f4       	brge	.+10     	; 0x1e7e <LCD_goToRowColumn+0x3a>
    1e74:	8c 81       	ldd	r24, Y+4	; 0x04
    1e76:	9d 81       	ldd	r25, Y+5	; 0x05
    1e78:	00 97       	sbiw	r24, 0x00	; 0
    1e7a:	61 f0       	breq	.+24     	; 0x1e94 <LCD_goToRowColumn+0x50>
    1e7c:	19 c0       	rjmp	.+50     	; 0x1eb0 <LCD_goToRowColumn+0x6c>
    1e7e:	2c 81       	ldd	r18, Y+4	; 0x04
    1e80:	3d 81       	ldd	r19, Y+5	; 0x05
    1e82:	22 30       	cpi	r18, 0x02	; 2
    1e84:	31 05       	cpc	r19, r1
    1e86:	69 f0       	breq	.+26     	; 0x1ea2 <LCD_goToRowColumn+0x5e>
    1e88:	8c 81       	ldd	r24, Y+4	; 0x04
    1e8a:	9d 81       	ldd	r25, Y+5	; 0x05
    1e8c:	83 30       	cpi	r24, 0x03	; 3
    1e8e:	91 05       	cpc	r25, r1
    1e90:	61 f0       	breq	.+24     	; 0x1eaa <LCD_goToRowColumn+0x66>
    1e92:	0e c0       	rjmp	.+28     	; 0x1eb0 <LCD_goToRowColumn+0x6c>
	{
	case 0:
		Address=col;
    1e94:	8b 81       	ldd	r24, Y+3	; 0x03
    1e96:	89 83       	std	Y+1, r24	; 0x01
    1e98:	0b c0       	rjmp	.+22     	; 0x1eb0 <LCD_goToRowColumn+0x6c>
		break;
	case 1:
		Address=col+0x40;
    1e9a:	8b 81       	ldd	r24, Y+3	; 0x03
    1e9c:	80 5c       	subi	r24, 0xC0	; 192
    1e9e:	89 83       	std	Y+1, r24	; 0x01
    1ea0:	07 c0       	rjmp	.+14     	; 0x1eb0 <LCD_goToRowColumn+0x6c>
		break;
	case 2:
		Address=col+0x10;
    1ea2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ea4:	80 5f       	subi	r24, 0xF0	; 240
    1ea6:	89 83       	std	Y+1, r24	; 0x01
    1ea8:	03 c0       	rjmp	.+6      	; 0x1eb0 <LCD_goToRowColumn+0x6c>
		break;
	case 3:
		Address=col+0x50;
    1eaa:	8b 81       	ldd	r24, Y+3	; 0x03
    1eac:	80 5b       	subi	r24, 0xB0	; 176
    1eae:	89 83       	std	Y+1, r24	; 0x01
		break;
	}					
	/* to write to a specific address in the LCD 
	 * we need to apply the corresponding command 0b10000000+Address */
	LCD_sendCommand(Address | SET_CURSOR_LOCATION); 
    1eb0:	89 81       	ldd	r24, Y+1	; 0x01
    1eb2:	80 68       	ori	r24, 0x80	; 128
    1eb4:	0e 94 1f 0e 	call	0x1c3e	; 0x1c3e <LCD_sendCommand>
}
    1eb8:	0f 90       	pop	r0
    1eba:	0f 90       	pop	r0
    1ebc:	0f 90       	pop	r0
    1ebe:	0f 90       	pop	r0
    1ec0:	0f 90       	pop	r0
    1ec2:	cf 91       	pop	r28
    1ec4:	df 91       	pop	r29
    1ec6:	08 95       	ret

00001ec8 <LCD_displayStringRowColumn>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayStringRowColumn(uint8 row,uint8 col,const uint8 *Str)
{
    1ec8:	df 93       	push	r29
    1eca:	cf 93       	push	r28
    1ecc:	00 d0       	rcall	.+0      	; 0x1ece <LCD_displayStringRowColumn+0x6>
    1ece:	00 d0       	rcall	.+0      	; 0x1ed0 <LCD_displayStringRowColumn+0x8>
    1ed0:	cd b7       	in	r28, 0x3d	; 61
    1ed2:	de b7       	in	r29, 0x3e	; 62
    1ed4:	89 83       	std	Y+1, r24	; 0x01
    1ed6:	6a 83       	std	Y+2, r22	; 0x02
    1ed8:	5c 83       	std	Y+4, r21	; 0x04
    1eda:	4b 83       	std	Y+3, r20	; 0x03
	LCD_goToRowColumn(row,col); /* go to to the required LCD position */
    1edc:	89 81       	ldd	r24, Y+1	; 0x01
    1ede:	6a 81       	ldd	r22, Y+2	; 0x02
    1ee0:	0e 94 22 0f 	call	0x1e44	; 0x1e44 <LCD_goToRowColumn>
	LCD_displayString(Str); /* display the string */
    1ee4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ee6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ee8:	0e 94 f9 0e 	call	0x1df2	; 0x1df2 <LCD_displayString>
}
    1eec:	0f 90       	pop	r0
    1eee:	0f 90       	pop	r0
    1ef0:	0f 90       	pop	r0
    1ef2:	0f 90       	pop	r0
    1ef4:	cf 91       	pop	r28
    1ef6:	df 91       	pop	r29
    1ef8:	08 95       	ret

00001efa <LCD_clearScreen>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_clearScreen(void)
{
    1efa:	df 93       	push	r29
    1efc:	cf 93       	push	r28
    1efe:	cd b7       	in	r28, 0x3d	; 61
    1f00:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(CLEAR_COMMAND); //clear display 
    1f02:	81 e0       	ldi	r24, 0x01	; 1
    1f04:	0e 94 1f 0e 	call	0x1c3e	; 0x1c3e <LCD_sendCommand>
}
    1f08:	cf 91       	pop	r28
    1f0a:	df 91       	pop	r29
    1f0c:	08 95       	ret

00001f0e <LCD_intgerToString>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_intgerToString(uint32 data)
{
    1f0e:	df 93       	push	r29
    1f10:	cf 93       	push	r28
    1f12:	cd b7       	in	r28, 0x3d	; 61
    1f14:	de b7       	in	r29, 0x3e	; 62
    1f16:	64 97       	sbiw	r28, 0x14	; 20
    1f18:	0f b6       	in	r0, 0x3f	; 63
    1f1a:	f8 94       	cli
    1f1c:	de bf       	out	0x3e, r29	; 62
    1f1e:	0f be       	out	0x3f, r0	; 63
    1f20:	cd bf       	out	0x3d, r28	; 61
    1f22:	69 8b       	std	Y+17, r22	; 0x11
    1f24:	7a 8b       	std	Y+18, r23	; 0x12
    1f26:	8b 8b       	std	Y+19, r24	; 0x13
    1f28:	9c 8b       	std	Y+20, r25	; 0x14
   char buff[16]; /* String to hold the ascii result */
   itoa(data,buff,10); /* 10 for decimal */
    1f2a:	89 89       	ldd	r24, Y+17	; 0x11
    1f2c:	9a 89       	ldd	r25, Y+18	; 0x12
    1f2e:	ab 89       	ldd	r26, Y+19	; 0x13
    1f30:	bc 89       	ldd	r27, Y+20	; 0x14
    1f32:	bc 01       	movw	r22, r24
    1f34:	cd 01       	movw	r24, r26
    1f36:	9e 01       	movw	r18, r28
    1f38:	2f 5f       	subi	r18, 0xFF	; 255
    1f3a:	3f 4f       	sbci	r19, 0xFF	; 255
    1f3c:	a9 01       	movw	r20, r18
    1f3e:	2a e0       	ldi	r18, 0x0A	; 10
    1f40:	30 e0       	ldi	r19, 0x00	; 0
    1f42:	0e 94 b6 2f 	call	0x5f6c	; 0x5f6c <itoa>
   LCD_displayString(buff);
    1f46:	ce 01       	movw	r24, r28
    1f48:	01 96       	adiw	r24, 0x01	; 1
    1f4a:	0e 94 f9 0e 	call	0x1df2	; 0x1df2 <LCD_displayString>
}
    1f4e:	64 96       	adiw	r28, 0x14	; 20
    1f50:	0f b6       	in	r0, 0x3f	; 63
    1f52:	f8 94       	cli
    1f54:	de bf       	out	0x3e, r29	; 62
    1f56:	0f be       	out	0x3f, r0	; 63
    1f58:	cd bf       	out	0x3d, r28	; 61
    1f5a:	cf 91       	pop	r28
    1f5c:	df 91       	pop	r29
    1f5e:	08 95       	ret

00001f60 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1f60:	df 93       	push	r29
    1f62:	cf 93       	push	r28
    1f64:	00 d0       	rcall	.+0      	; 0x1f66 <vListInitialise+0x6>
    1f66:	cd b7       	in	r28, 0x3d	; 61
    1f68:	de b7       	in	r29, 0x3e	; 62
    1f6a:	9a 83       	std	Y+2, r25	; 0x02
    1f6c:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1f6e:	89 81       	ldd	r24, Y+1	; 0x01
    1f70:	9a 81       	ldd	r25, Y+2	; 0x02
    1f72:	03 96       	adiw	r24, 0x03	; 3
    1f74:	e9 81       	ldd	r30, Y+1	; 0x01
    1f76:	fa 81       	ldd	r31, Y+2	; 0x02
    1f78:	92 83       	std	Z+2, r25	; 0x02
    1f7a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1f7c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f7e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f80:	8f ef       	ldi	r24, 0xFF	; 255
    1f82:	9f ef       	ldi	r25, 0xFF	; 255
    1f84:	94 83       	std	Z+4, r25	; 0x04
    1f86:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1f88:	89 81       	ldd	r24, Y+1	; 0x01
    1f8a:	9a 81       	ldd	r25, Y+2	; 0x02
    1f8c:	03 96       	adiw	r24, 0x03	; 3
    1f8e:	e9 81       	ldd	r30, Y+1	; 0x01
    1f90:	fa 81       	ldd	r31, Y+2	; 0x02
    1f92:	96 83       	std	Z+6, r25	; 0x06
    1f94:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1f96:	89 81       	ldd	r24, Y+1	; 0x01
    1f98:	9a 81       	ldd	r25, Y+2	; 0x02
    1f9a:	03 96       	adiw	r24, 0x03	; 3
    1f9c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f9e:	fa 81       	ldd	r31, Y+2	; 0x02
    1fa0:	90 87       	std	Z+8, r25	; 0x08
    1fa2:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1fa4:	e9 81       	ldd	r30, Y+1	; 0x01
    1fa6:	fa 81       	ldd	r31, Y+2	; 0x02
    1fa8:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    1faa:	0f 90       	pop	r0
    1fac:	0f 90       	pop	r0
    1fae:	cf 91       	pop	r28
    1fb0:	df 91       	pop	r29
    1fb2:	08 95       	ret

00001fb4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1fb4:	df 93       	push	r29
    1fb6:	cf 93       	push	r28
    1fb8:	00 d0       	rcall	.+0      	; 0x1fba <vListInitialiseItem+0x6>
    1fba:	cd b7       	in	r28, 0x3d	; 61
    1fbc:	de b7       	in	r29, 0x3e	; 62
    1fbe:	9a 83       	std	Y+2, r25	; 0x02
    1fc0:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    1fc2:	e9 81       	ldd	r30, Y+1	; 0x01
    1fc4:	fa 81       	ldd	r31, Y+2	; 0x02
    1fc6:	11 86       	std	Z+9, r1	; 0x09
    1fc8:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    1fca:	0f 90       	pop	r0
    1fcc:	0f 90       	pop	r0
    1fce:	cf 91       	pop	r28
    1fd0:	df 91       	pop	r29
    1fd2:	08 95       	ret

00001fd4 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1fd4:	df 93       	push	r29
    1fd6:	cf 93       	push	r28
    1fd8:	00 d0       	rcall	.+0      	; 0x1fda <vListInsertEnd+0x6>
    1fda:	00 d0       	rcall	.+0      	; 0x1fdc <vListInsertEnd+0x8>
    1fdc:	00 d0       	rcall	.+0      	; 0x1fde <vListInsertEnd+0xa>
    1fde:	cd b7       	in	r28, 0x3d	; 61
    1fe0:	de b7       	in	r29, 0x3e	; 62
    1fe2:	9c 83       	std	Y+4, r25	; 0x04
    1fe4:	8b 83       	std	Y+3, r24	; 0x03
    1fe6:	7e 83       	std	Y+6, r23	; 0x06
    1fe8:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    1fea:	eb 81       	ldd	r30, Y+3	; 0x03
    1fec:	fc 81       	ldd	r31, Y+4	; 0x04
    1fee:	81 81       	ldd	r24, Z+1	; 0x01
    1ff0:	92 81       	ldd	r25, Z+2	; 0x02
    1ff2:	9a 83       	std	Y+2, r25	; 0x02
    1ff4:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1ff6:	ed 81       	ldd	r30, Y+5	; 0x05
    1ff8:	fe 81       	ldd	r31, Y+6	; 0x06
    1ffa:	89 81       	ldd	r24, Y+1	; 0x01
    1ffc:	9a 81       	ldd	r25, Y+2	; 0x02
    1ffe:	93 83       	std	Z+3, r25	; 0x03
    2000:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2002:	e9 81       	ldd	r30, Y+1	; 0x01
    2004:	fa 81       	ldd	r31, Y+2	; 0x02
    2006:	84 81       	ldd	r24, Z+4	; 0x04
    2008:	95 81       	ldd	r25, Z+5	; 0x05
    200a:	ed 81       	ldd	r30, Y+5	; 0x05
    200c:	fe 81       	ldd	r31, Y+6	; 0x06
    200e:	95 83       	std	Z+5, r25	; 0x05
    2010:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    2012:	e9 81       	ldd	r30, Y+1	; 0x01
    2014:	fa 81       	ldd	r31, Y+2	; 0x02
    2016:	04 80       	ldd	r0, Z+4	; 0x04
    2018:	f5 81       	ldd	r31, Z+5	; 0x05
    201a:	e0 2d       	mov	r30, r0
    201c:	8d 81       	ldd	r24, Y+5	; 0x05
    201e:	9e 81       	ldd	r25, Y+6	; 0x06
    2020:	93 83       	std	Z+3, r25	; 0x03
    2022:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    2024:	e9 81       	ldd	r30, Y+1	; 0x01
    2026:	fa 81       	ldd	r31, Y+2	; 0x02
    2028:	8d 81       	ldd	r24, Y+5	; 0x05
    202a:	9e 81       	ldd	r25, Y+6	; 0x06
    202c:	95 83       	std	Z+5, r25	; 0x05
    202e:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    2030:	ed 81       	ldd	r30, Y+5	; 0x05
    2032:	fe 81       	ldd	r31, Y+6	; 0x06
    2034:	8b 81       	ldd	r24, Y+3	; 0x03
    2036:	9c 81       	ldd	r25, Y+4	; 0x04
    2038:	91 87       	std	Z+9, r25	; 0x09
    203a:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    203c:	eb 81       	ldd	r30, Y+3	; 0x03
    203e:	fc 81       	ldd	r31, Y+4	; 0x04
    2040:	80 81       	ld	r24, Z
    2042:	8f 5f       	subi	r24, 0xFF	; 255
    2044:	eb 81       	ldd	r30, Y+3	; 0x03
    2046:	fc 81       	ldd	r31, Y+4	; 0x04
    2048:	80 83       	st	Z, r24
}
    204a:	26 96       	adiw	r28, 0x06	; 6
    204c:	0f b6       	in	r0, 0x3f	; 63
    204e:	f8 94       	cli
    2050:	de bf       	out	0x3e, r29	; 62
    2052:	0f be       	out	0x3f, r0	; 63
    2054:	cd bf       	out	0x3d, r28	; 61
    2056:	cf 91       	pop	r28
    2058:	df 91       	pop	r29
    205a:	08 95       	ret

0000205c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    205c:	df 93       	push	r29
    205e:	cf 93       	push	r28
    2060:	cd b7       	in	r28, 0x3d	; 61
    2062:	de b7       	in	r29, 0x3e	; 62
    2064:	28 97       	sbiw	r28, 0x08	; 8
    2066:	0f b6       	in	r0, 0x3f	; 63
    2068:	f8 94       	cli
    206a:	de bf       	out	0x3e, r29	; 62
    206c:	0f be       	out	0x3f, r0	; 63
    206e:	cd bf       	out	0x3d, r28	; 61
    2070:	9e 83       	std	Y+6, r25	; 0x06
    2072:	8d 83       	std	Y+5, r24	; 0x05
    2074:	78 87       	std	Y+8, r23	; 0x08
    2076:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    2078:	ef 81       	ldd	r30, Y+7	; 0x07
    207a:	f8 85       	ldd	r31, Y+8	; 0x08
    207c:	80 81       	ld	r24, Z
    207e:	91 81       	ldd	r25, Z+1	; 0x01
    2080:	9a 83       	std	Y+2, r25	; 0x02
    2082:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2084:	89 81       	ldd	r24, Y+1	; 0x01
    2086:	9a 81       	ldd	r25, Y+2	; 0x02
    2088:	2f ef       	ldi	r18, 0xFF	; 255
    208a:	8f 3f       	cpi	r24, 0xFF	; 255
    208c:	92 07       	cpc	r25, r18
    208e:	39 f4       	brne	.+14     	; 0x209e <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2090:	ed 81       	ldd	r30, Y+5	; 0x05
    2092:	fe 81       	ldd	r31, Y+6	; 0x06
    2094:	87 81       	ldd	r24, Z+7	; 0x07
    2096:	90 85       	ldd	r25, Z+8	; 0x08
    2098:	9c 83       	std	Y+4, r25	; 0x04
    209a:	8b 83       	std	Y+3, r24	; 0x03
    209c:	18 c0       	rjmp	.+48     	; 0x20ce <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    209e:	8d 81       	ldd	r24, Y+5	; 0x05
    20a0:	9e 81       	ldd	r25, Y+6	; 0x06
    20a2:	03 96       	adiw	r24, 0x03	; 3
    20a4:	9c 83       	std	Y+4, r25	; 0x04
    20a6:	8b 83       	std	Y+3, r24	; 0x03
    20a8:	06 c0       	rjmp	.+12     	; 0x20b6 <vListInsert+0x5a>
    20aa:	eb 81       	ldd	r30, Y+3	; 0x03
    20ac:	fc 81       	ldd	r31, Y+4	; 0x04
    20ae:	82 81       	ldd	r24, Z+2	; 0x02
    20b0:	93 81       	ldd	r25, Z+3	; 0x03
    20b2:	9c 83       	std	Y+4, r25	; 0x04
    20b4:	8b 83       	std	Y+3, r24	; 0x03
    20b6:	eb 81       	ldd	r30, Y+3	; 0x03
    20b8:	fc 81       	ldd	r31, Y+4	; 0x04
    20ba:	02 80       	ldd	r0, Z+2	; 0x02
    20bc:	f3 81       	ldd	r31, Z+3	; 0x03
    20be:	e0 2d       	mov	r30, r0
    20c0:	20 81       	ld	r18, Z
    20c2:	31 81       	ldd	r19, Z+1	; 0x01
    20c4:	89 81       	ldd	r24, Y+1	; 0x01
    20c6:	9a 81       	ldd	r25, Y+2	; 0x02
    20c8:	82 17       	cp	r24, r18
    20ca:	93 07       	cpc	r25, r19
    20cc:	70 f7       	brcc	.-36     	; 0x20aa <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    20ce:	eb 81       	ldd	r30, Y+3	; 0x03
    20d0:	fc 81       	ldd	r31, Y+4	; 0x04
    20d2:	82 81       	ldd	r24, Z+2	; 0x02
    20d4:	93 81       	ldd	r25, Z+3	; 0x03
    20d6:	ef 81       	ldd	r30, Y+7	; 0x07
    20d8:	f8 85       	ldd	r31, Y+8	; 0x08
    20da:	93 83       	std	Z+3, r25	; 0x03
    20dc:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    20de:	ef 81       	ldd	r30, Y+7	; 0x07
    20e0:	f8 85       	ldd	r31, Y+8	; 0x08
    20e2:	02 80       	ldd	r0, Z+2	; 0x02
    20e4:	f3 81       	ldd	r31, Z+3	; 0x03
    20e6:	e0 2d       	mov	r30, r0
    20e8:	8f 81       	ldd	r24, Y+7	; 0x07
    20ea:	98 85       	ldd	r25, Y+8	; 0x08
    20ec:	95 83       	std	Z+5, r25	; 0x05
    20ee:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    20f0:	ef 81       	ldd	r30, Y+7	; 0x07
    20f2:	f8 85       	ldd	r31, Y+8	; 0x08
    20f4:	8b 81       	ldd	r24, Y+3	; 0x03
    20f6:	9c 81       	ldd	r25, Y+4	; 0x04
    20f8:	95 83       	std	Z+5, r25	; 0x05
    20fa:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    20fc:	eb 81       	ldd	r30, Y+3	; 0x03
    20fe:	fc 81       	ldd	r31, Y+4	; 0x04
    2100:	8f 81       	ldd	r24, Y+7	; 0x07
    2102:	98 85       	ldd	r25, Y+8	; 0x08
    2104:	93 83       	std	Z+3, r25	; 0x03
    2106:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    2108:	ef 81       	ldd	r30, Y+7	; 0x07
    210a:	f8 85       	ldd	r31, Y+8	; 0x08
    210c:	8d 81       	ldd	r24, Y+5	; 0x05
    210e:	9e 81       	ldd	r25, Y+6	; 0x06
    2110:	91 87       	std	Z+9, r25	; 0x09
    2112:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2114:	ed 81       	ldd	r30, Y+5	; 0x05
    2116:	fe 81       	ldd	r31, Y+6	; 0x06
    2118:	80 81       	ld	r24, Z
    211a:	8f 5f       	subi	r24, 0xFF	; 255
    211c:	ed 81       	ldd	r30, Y+5	; 0x05
    211e:	fe 81       	ldd	r31, Y+6	; 0x06
    2120:	80 83       	st	Z, r24
}
    2122:	28 96       	adiw	r28, 0x08	; 8
    2124:	0f b6       	in	r0, 0x3f	; 63
    2126:	f8 94       	cli
    2128:	de bf       	out	0x3e, r29	; 62
    212a:	0f be       	out	0x3f, r0	; 63
    212c:	cd bf       	out	0x3d, r28	; 61
    212e:	cf 91       	pop	r28
    2130:	df 91       	pop	r29
    2132:	08 95       	ret

00002134 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    2134:	df 93       	push	r29
    2136:	cf 93       	push	r28
    2138:	00 d0       	rcall	.+0      	; 0x213a <uxListRemove+0x6>
    213a:	00 d0       	rcall	.+0      	; 0x213c <uxListRemove+0x8>
    213c:	cd b7       	in	r28, 0x3d	; 61
    213e:	de b7       	in	r29, 0x3e	; 62
    2140:	9c 83       	std	Y+4, r25	; 0x04
    2142:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    2144:	eb 81       	ldd	r30, Y+3	; 0x03
    2146:	fc 81       	ldd	r31, Y+4	; 0x04
    2148:	80 85       	ldd	r24, Z+8	; 0x08
    214a:	91 85       	ldd	r25, Z+9	; 0x09
    214c:	9a 83       	std	Y+2, r25	; 0x02
    214e:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2150:	eb 81       	ldd	r30, Y+3	; 0x03
    2152:	fc 81       	ldd	r31, Y+4	; 0x04
    2154:	a2 81       	ldd	r26, Z+2	; 0x02
    2156:	b3 81       	ldd	r27, Z+3	; 0x03
    2158:	eb 81       	ldd	r30, Y+3	; 0x03
    215a:	fc 81       	ldd	r31, Y+4	; 0x04
    215c:	84 81       	ldd	r24, Z+4	; 0x04
    215e:	95 81       	ldd	r25, Z+5	; 0x05
    2160:	15 96       	adiw	r26, 0x05	; 5
    2162:	9c 93       	st	X, r25
    2164:	8e 93       	st	-X, r24
    2166:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2168:	eb 81       	ldd	r30, Y+3	; 0x03
    216a:	fc 81       	ldd	r31, Y+4	; 0x04
    216c:	a4 81       	ldd	r26, Z+4	; 0x04
    216e:	b5 81       	ldd	r27, Z+5	; 0x05
    2170:	eb 81       	ldd	r30, Y+3	; 0x03
    2172:	fc 81       	ldd	r31, Y+4	; 0x04
    2174:	82 81       	ldd	r24, Z+2	; 0x02
    2176:	93 81       	ldd	r25, Z+3	; 0x03
    2178:	13 96       	adiw	r26, 0x03	; 3
    217a:	9c 93       	st	X, r25
    217c:	8e 93       	st	-X, r24
    217e:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2180:	e9 81       	ldd	r30, Y+1	; 0x01
    2182:	fa 81       	ldd	r31, Y+2	; 0x02
    2184:	21 81       	ldd	r18, Z+1	; 0x01
    2186:	32 81       	ldd	r19, Z+2	; 0x02
    2188:	8b 81       	ldd	r24, Y+3	; 0x03
    218a:	9c 81       	ldd	r25, Y+4	; 0x04
    218c:	28 17       	cp	r18, r24
    218e:	39 07       	cpc	r19, r25
    2190:	41 f4       	brne	.+16     	; 0x21a2 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2192:	eb 81       	ldd	r30, Y+3	; 0x03
    2194:	fc 81       	ldd	r31, Y+4	; 0x04
    2196:	84 81       	ldd	r24, Z+4	; 0x04
    2198:	95 81       	ldd	r25, Z+5	; 0x05
    219a:	e9 81       	ldd	r30, Y+1	; 0x01
    219c:	fa 81       	ldd	r31, Y+2	; 0x02
    219e:	92 83       	std	Z+2, r25	; 0x02
    21a0:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    21a2:	eb 81       	ldd	r30, Y+3	; 0x03
    21a4:	fc 81       	ldd	r31, Y+4	; 0x04
    21a6:	11 86       	std	Z+9, r1	; 0x09
    21a8:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    21aa:	e9 81       	ldd	r30, Y+1	; 0x01
    21ac:	fa 81       	ldd	r31, Y+2	; 0x02
    21ae:	80 81       	ld	r24, Z
    21b0:	81 50       	subi	r24, 0x01	; 1
    21b2:	e9 81       	ldd	r30, Y+1	; 0x01
    21b4:	fa 81       	ldd	r31, Y+2	; 0x02
    21b6:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    21b8:	e9 81       	ldd	r30, Y+1	; 0x01
    21ba:	fa 81       	ldd	r31, Y+2	; 0x02
    21bc:	80 81       	ld	r24, Z
}
    21be:	0f 90       	pop	r0
    21c0:	0f 90       	pop	r0
    21c2:	0f 90       	pop	r0
    21c4:	0f 90       	pop	r0
    21c6:	cf 91       	pop	r28
    21c8:	df 91       	pop	r29
    21ca:	08 95       	ret

000021cc <main>:

#include "UserTasks.h"


void main(void)
{
    21cc:	ef 92       	push	r14
    21ce:	ff 92       	push	r15
    21d0:	0f 93       	push	r16
    21d2:	df 93       	push	r29
    21d4:	cf 93       	push	r28
    21d6:	cd b7       	in	r28, 0x3d	; 61
    21d8:	de b7       	in	r29, 0x3e	; 62

	DIO_SetPinDirection(DIO_PIN12,OUTPUT);
    21da:	8c e0       	ldi	r24, 0x0C	; 12
    21dc:	61 e0       	ldi	r22, 0x01	; 1
    21de:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
	xTaskCreate(init_Task  , "Init_Task" , 150,
    21e2:	88 ef       	ldi	r24, 0xF8	; 248
    21e4:	95 e0       	ldi	r25, 0x05	; 5
    21e6:	29 ec       	ldi	r18, 0xC9	; 201
    21e8:	30 e0       	ldi	r19, 0x00	; 0
    21ea:	e6 ee       	ldi	r30, 0xE6	; 230
    21ec:	f0 e0       	ldi	r31, 0x00	; 0
    21ee:	b9 01       	movw	r22, r18
    21f0:	46 e9       	ldi	r20, 0x96	; 150
    21f2:	50 e0       	ldi	r21, 0x00	; 0
    21f4:	20 e0       	ldi	r18, 0x00	; 0
    21f6:	30 e0       	ldi	r19, 0x00	; 0
    21f8:	05 e0       	ldi	r16, 0x05	; 5
    21fa:	7f 01       	movw	r14, r30
    21fc:	0e 94 8d 22 	call	0x451a	; 0x451a <xTaskCreate>
			NULL , (5 | portPRIVILEGE_BIT) , &InitTask_Flag);


	/* Start Scheduler */

	vTaskStartScheduler();
    2200:	0e 94 3a 26 	call	0x4c74	; 0x4c74 <vTaskStartScheduler>
    2204:	ff cf       	rjmp	.-2      	; 0x2204 <main+0x38>

00002206 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    2206:	df 93       	push	r29
    2208:	cf 93       	push	r28
    220a:	cd b7       	in	r28, 0x3d	; 61
    220c:	de b7       	in	r29, 0x3e	; 62
    220e:	28 97       	sbiw	r28, 0x08	; 8
    2210:	0f b6       	in	r0, 0x3f	; 63
    2212:	f8 94       	cli
    2214:	de bf       	out	0x3e, r29	; 62
    2216:	0f be       	out	0x3f, r0	; 63
    2218:	cd bf       	out	0x3d, r28	; 61
    221a:	9c 83       	std	Y+4, r25	; 0x04
    221c:	8b 83       	std	Y+3, r24	; 0x03
    221e:	7e 83       	std	Y+6, r23	; 0x06
    2220:	6d 83       	std	Y+5, r22	; 0x05
    2222:	58 87       	std	Y+8, r21	; 0x08
    2224:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2226:	eb 81       	ldd	r30, Y+3	; 0x03
    2228:	fc 81       	ldd	r31, Y+4	; 0x04
    222a:	81 e1       	ldi	r24, 0x11	; 17
    222c:	80 83       	st	Z, r24
	pxTopOfStack--;
    222e:	8b 81       	ldd	r24, Y+3	; 0x03
    2230:	9c 81       	ldd	r25, Y+4	; 0x04
    2232:	01 97       	sbiw	r24, 0x01	; 1
    2234:	9c 83       	std	Y+4, r25	; 0x04
    2236:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    2238:	eb 81       	ldd	r30, Y+3	; 0x03
    223a:	fc 81       	ldd	r31, Y+4	; 0x04
    223c:	82 e2       	ldi	r24, 0x22	; 34
    223e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2240:	8b 81       	ldd	r24, Y+3	; 0x03
    2242:	9c 81       	ldd	r25, Y+4	; 0x04
    2244:	01 97       	sbiw	r24, 0x01	; 1
    2246:	9c 83       	std	Y+4, r25	; 0x04
    2248:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    224a:	eb 81       	ldd	r30, Y+3	; 0x03
    224c:	fc 81       	ldd	r31, Y+4	; 0x04
    224e:	83 e3       	ldi	r24, 0x33	; 51
    2250:	80 83       	st	Z, r24
	pxTopOfStack--;
    2252:	8b 81       	ldd	r24, Y+3	; 0x03
    2254:	9c 81       	ldd	r25, Y+4	; 0x04
    2256:	01 97       	sbiw	r24, 0x01	; 1
    2258:	9c 83       	std	Y+4, r25	; 0x04
    225a:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    225c:	8d 81       	ldd	r24, Y+5	; 0x05
    225e:	9e 81       	ldd	r25, Y+6	; 0x06
    2260:	9a 83       	std	Y+2, r25	; 0x02
    2262:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2264:	89 81       	ldd	r24, Y+1	; 0x01
    2266:	eb 81       	ldd	r30, Y+3	; 0x03
    2268:	fc 81       	ldd	r31, Y+4	; 0x04
    226a:	80 83       	st	Z, r24
	pxTopOfStack--;
    226c:	8b 81       	ldd	r24, Y+3	; 0x03
    226e:	9c 81       	ldd	r25, Y+4	; 0x04
    2270:	01 97       	sbiw	r24, 0x01	; 1
    2272:	9c 83       	std	Y+4, r25	; 0x04
    2274:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2276:	89 81       	ldd	r24, Y+1	; 0x01
    2278:	9a 81       	ldd	r25, Y+2	; 0x02
    227a:	89 2f       	mov	r24, r25
    227c:	99 27       	eor	r25, r25
    227e:	9a 83       	std	Y+2, r25	; 0x02
    2280:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2282:	89 81       	ldd	r24, Y+1	; 0x01
    2284:	eb 81       	ldd	r30, Y+3	; 0x03
    2286:	fc 81       	ldd	r31, Y+4	; 0x04
    2288:	80 83       	st	Z, r24
	pxTopOfStack--;
    228a:	8b 81       	ldd	r24, Y+3	; 0x03
    228c:	9c 81       	ldd	r25, Y+4	; 0x04
    228e:	01 97       	sbiw	r24, 0x01	; 1
    2290:	9c 83       	std	Y+4, r25	; 0x04
    2292:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    2294:	eb 81       	ldd	r30, Y+3	; 0x03
    2296:	fc 81       	ldd	r31, Y+4	; 0x04
    2298:	10 82       	st	Z, r1
	pxTopOfStack--;
    229a:	8b 81       	ldd	r24, Y+3	; 0x03
    229c:	9c 81       	ldd	r25, Y+4	; 0x04
    229e:	01 97       	sbiw	r24, 0x01	; 1
    22a0:	9c 83       	std	Y+4, r25	; 0x04
    22a2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    22a4:	eb 81       	ldd	r30, Y+3	; 0x03
    22a6:	fc 81       	ldd	r31, Y+4	; 0x04
    22a8:	80 e8       	ldi	r24, 0x80	; 128
    22aa:	80 83       	st	Z, r24
	pxTopOfStack--;
    22ac:	8b 81       	ldd	r24, Y+3	; 0x03
    22ae:	9c 81       	ldd	r25, Y+4	; 0x04
    22b0:	01 97       	sbiw	r24, 0x01	; 1
    22b2:	9c 83       	std	Y+4, r25	; 0x04
    22b4:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    22b6:	eb 81       	ldd	r30, Y+3	; 0x03
    22b8:	fc 81       	ldd	r31, Y+4	; 0x04
    22ba:	10 82       	st	Z, r1
	pxTopOfStack--;
    22bc:	8b 81       	ldd	r24, Y+3	; 0x03
    22be:	9c 81       	ldd	r25, Y+4	; 0x04
    22c0:	01 97       	sbiw	r24, 0x01	; 1
    22c2:	9c 83       	std	Y+4, r25	; 0x04
    22c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    22c6:	eb 81       	ldd	r30, Y+3	; 0x03
    22c8:	fc 81       	ldd	r31, Y+4	; 0x04
    22ca:	82 e0       	ldi	r24, 0x02	; 2
    22cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    22ce:	8b 81       	ldd	r24, Y+3	; 0x03
    22d0:	9c 81       	ldd	r25, Y+4	; 0x04
    22d2:	01 97       	sbiw	r24, 0x01	; 1
    22d4:	9c 83       	std	Y+4, r25	; 0x04
    22d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    22d8:	eb 81       	ldd	r30, Y+3	; 0x03
    22da:	fc 81       	ldd	r31, Y+4	; 0x04
    22dc:	83 e0       	ldi	r24, 0x03	; 3
    22de:	80 83       	st	Z, r24
	pxTopOfStack--;
    22e0:	8b 81       	ldd	r24, Y+3	; 0x03
    22e2:	9c 81       	ldd	r25, Y+4	; 0x04
    22e4:	01 97       	sbiw	r24, 0x01	; 1
    22e6:	9c 83       	std	Y+4, r25	; 0x04
    22e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    22ea:	eb 81       	ldd	r30, Y+3	; 0x03
    22ec:	fc 81       	ldd	r31, Y+4	; 0x04
    22ee:	84 e0       	ldi	r24, 0x04	; 4
    22f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    22f2:	8b 81       	ldd	r24, Y+3	; 0x03
    22f4:	9c 81       	ldd	r25, Y+4	; 0x04
    22f6:	01 97       	sbiw	r24, 0x01	; 1
    22f8:	9c 83       	std	Y+4, r25	; 0x04
    22fa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    22fc:	eb 81       	ldd	r30, Y+3	; 0x03
    22fe:	fc 81       	ldd	r31, Y+4	; 0x04
    2300:	85 e0       	ldi	r24, 0x05	; 5
    2302:	80 83       	st	Z, r24
	pxTopOfStack--;
    2304:	8b 81       	ldd	r24, Y+3	; 0x03
    2306:	9c 81       	ldd	r25, Y+4	; 0x04
    2308:	01 97       	sbiw	r24, 0x01	; 1
    230a:	9c 83       	std	Y+4, r25	; 0x04
    230c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    230e:	eb 81       	ldd	r30, Y+3	; 0x03
    2310:	fc 81       	ldd	r31, Y+4	; 0x04
    2312:	86 e0       	ldi	r24, 0x06	; 6
    2314:	80 83       	st	Z, r24
	pxTopOfStack--;
    2316:	8b 81       	ldd	r24, Y+3	; 0x03
    2318:	9c 81       	ldd	r25, Y+4	; 0x04
    231a:	01 97       	sbiw	r24, 0x01	; 1
    231c:	9c 83       	std	Y+4, r25	; 0x04
    231e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2320:	eb 81       	ldd	r30, Y+3	; 0x03
    2322:	fc 81       	ldd	r31, Y+4	; 0x04
    2324:	87 e0       	ldi	r24, 0x07	; 7
    2326:	80 83       	st	Z, r24
	pxTopOfStack--;
    2328:	8b 81       	ldd	r24, Y+3	; 0x03
    232a:	9c 81       	ldd	r25, Y+4	; 0x04
    232c:	01 97       	sbiw	r24, 0x01	; 1
    232e:	9c 83       	std	Y+4, r25	; 0x04
    2330:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2332:	eb 81       	ldd	r30, Y+3	; 0x03
    2334:	fc 81       	ldd	r31, Y+4	; 0x04
    2336:	88 e0       	ldi	r24, 0x08	; 8
    2338:	80 83       	st	Z, r24
	pxTopOfStack--;
    233a:	8b 81       	ldd	r24, Y+3	; 0x03
    233c:	9c 81       	ldd	r25, Y+4	; 0x04
    233e:	01 97       	sbiw	r24, 0x01	; 1
    2340:	9c 83       	std	Y+4, r25	; 0x04
    2342:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2344:	eb 81       	ldd	r30, Y+3	; 0x03
    2346:	fc 81       	ldd	r31, Y+4	; 0x04
    2348:	89 e0       	ldi	r24, 0x09	; 9
    234a:	80 83       	st	Z, r24
	pxTopOfStack--;
    234c:	8b 81       	ldd	r24, Y+3	; 0x03
    234e:	9c 81       	ldd	r25, Y+4	; 0x04
    2350:	01 97       	sbiw	r24, 0x01	; 1
    2352:	9c 83       	std	Y+4, r25	; 0x04
    2354:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    2356:	eb 81       	ldd	r30, Y+3	; 0x03
    2358:	fc 81       	ldd	r31, Y+4	; 0x04
    235a:	80 e1       	ldi	r24, 0x10	; 16
    235c:	80 83       	st	Z, r24
	pxTopOfStack--;
    235e:	8b 81       	ldd	r24, Y+3	; 0x03
    2360:	9c 81       	ldd	r25, Y+4	; 0x04
    2362:	01 97       	sbiw	r24, 0x01	; 1
    2364:	9c 83       	std	Y+4, r25	; 0x04
    2366:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2368:	eb 81       	ldd	r30, Y+3	; 0x03
    236a:	fc 81       	ldd	r31, Y+4	; 0x04
    236c:	81 e1       	ldi	r24, 0x11	; 17
    236e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2370:	8b 81       	ldd	r24, Y+3	; 0x03
    2372:	9c 81       	ldd	r25, Y+4	; 0x04
    2374:	01 97       	sbiw	r24, 0x01	; 1
    2376:	9c 83       	std	Y+4, r25	; 0x04
    2378:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    237a:	eb 81       	ldd	r30, Y+3	; 0x03
    237c:	fc 81       	ldd	r31, Y+4	; 0x04
    237e:	82 e1       	ldi	r24, 0x12	; 18
    2380:	80 83       	st	Z, r24
	pxTopOfStack--;
    2382:	8b 81       	ldd	r24, Y+3	; 0x03
    2384:	9c 81       	ldd	r25, Y+4	; 0x04
    2386:	01 97       	sbiw	r24, 0x01	; 1
    2388:	9c 83       	std	Y+4, r25	; 0x04
    238a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    238c:	eb 81       	ldd	r30, Y+3	; 0x03
    238e:	fc 81       	ldd	r31, Y+4	; 0x04
    2390:	83 e1       	ldi	r24, 0x13	; 19
    2392:	80 83       	st	Z, r24
	pxTopOfStack--;
    2394:	8b 81       	ldd	r24, Y+3	; 0x03
    2396:	9c 81       	ldd	r25, Y+4	; 0x04
    2398:	01 97       	sbiw	r24, 0x01	; 1
    239a:	9c 83       	std	Y+4, r25	; 0x04
    239c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    239e:	eb 81       	ldd	r30, Y+3	; 0x03
    23a0:	fc 81       	ldd	r31, Y+4	; 0x04
    23a2:	84 e1       	ldi	r24, 0x14	; 20
    23a4:	80 83       	st	Z, r24
	pxTopOfStack--;
    23a6:	8b 81       	ldd	r24, Y+3	; 0x03
    23a8:	9c 81       	ldd	r25, Y+4	; 0x04
    23aa:	01 97       	sbiw	r24, 0x01	; 1
    23ac:	9c 83       	std	Y+4, r25	; 0x04
    23ae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    23b0:	eb 81       	ldd	r30, Y+3	; 0x03
    23b2:	fc 81       	ldd	r31, Y+4	; 0x04
    23b4:	85 e1       	ldi	r24, 0x15	; 21
    23b6:	80 83       	st	Z, r24
	pxTopOfStack--;
    23b8:	8b 81       	ldd	r24, Y+3	; 0x03
    23ba:	9c 81       	ldd	r25, Y+4	; 0x04
    23bc:	01 97       	sbiw	r24, 0x01	; 1
    23be:	9c 83       	std	Y+4, r25	; 0x04
    23c0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    23c2:	eb 81       	ldd	r30, Y+3	; 0x03
    23c4:	fc 81       	ldd	r31, Y+4	; 0x04
    23c6:	86 e1       	ldi	r24, 0x16	; 22
    23c8:	80 83       	st	Z, r24
	pxTopOfStack--;
    23ca:	8b 81       	ldd	r24, Y+3	; 0x03
    23cc:	9c 81       	ldd	r25, Y+4	; 0x04
    23ce:	01 97       	sbiw	r24, 0x01	; 1
    23d0:	9c 83       	std	Y+4, r25	; 0x04
    23d2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    23d4:	eb 81       	ldd	r30, Y+3	; 0x03
    23d6:	fc 81       	ldd	r31, Y+4	; 0x04
    23d8:	87 e1       	ldi	r24, 0x17	; 23
    23da:	80 83       	st	Z, r24
	pxTopOfStack--;
    23dc:	8b 81       	ldd	r24, Y+3	; 0x03
    23de:	9c 81       	ldd	r25, Y+4	; 0x04
    23e0:	01 97       	sbiw	r24, 0x01	; 1
    23e2:	9c 83       	std	Y+4, r25	; 0x04
    23e4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    23e6:	eb 81       	ldd	r30, Y+3	; 0x03
    23e8:	fc 81       	ldd	r31, Y+4	; 0x04
    23ea:	88 e1       	ldi	r24, 0x18	; 24
    23ec:	80 83       	st	Z, r24
	pxTopOfStack--;
    23ee:	8b 81       	ldd	r24, Y+3	; 0x03
    23f0:	9c 81       	ldd	r25, Y+4	; 0x04
    23f2:	01 97       	sbiw	r24, 0x01	; 1
    23f4:	9c 83       	std	Y+4, r25	; 0x04
    23f6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    23f8:	eb 81       	ldd	r30, Y+3	; 0x03
    23fa:	fc 81       	ldd	r31, Y+4	; 0x04
    23fc:	89 e1       	ldi	r24, 0x19	; 25
    23fe:	80 83       	st	Z, r24
	pxTopOfStack--;
    2400:	8b 81       	ldd	r24, Y+3	; 0x03
    2402:	9c 81       	ldd	r25, Y+4	; 0x04
    2404:	01 97       	sbiw	r24, 0x01	; 1
    2406:	9c 83       	std	Y+4, r25	; 0x04
    2408:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    240a:	eb 81       	ldd	r30, Y+3	; 0x03
    240c:	fc 81       	ldd	r31, Y+4	; 0x04
    240e:	80 e2       	ldi	r24, 0x20	; 32
    2410:	80 83       	st	Z, r24
	pxTopOfStack--;
    2412:	8b 81       	ldd	r24, Y+3	; 0x03
    2414:	9c 81       	ldd	r25, Y+4	; 0x04
    2416:	01 97       	sbiw	r24, 0x01	; 1
    2418:	9c 83       	std	Y+4, r25	; 0x04
    241a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    241c:	eb 81       	ldd	r30, Y+3	; 0x03
    241e:	fc 81       	ldd	r31, Y+4	; 0x04
    2420:	81 e2       	ldi	r24, 0x21	; 33
    2422:	80 83       	st	Z, r24
	pxTopOfStack--;
    2424:	8b 81       	ldd	r24, Y+3	; 0x03
    2426:	9c 81       	ldd	r25, Y+4	; 0x04
    2428:	01 97       	sbiw	r24, 0x01	; 1
    242a:	9c 83       	std	Y+4, r25	; 0x04
    242c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    242e:	eb 81       	ldd	r30, Y+3	; 0x03
    2430:	fc 81       	ldd	r31, Y+4	; 0x04
    2432:	82 e2       	ldi	r24, 0x22	; 34
    2434:	80 83       	st	Z, r24
	pxTopOfStack--;
    2436:	8b 81       	ldd	r24, Y+3	; 0x03
    2438:	9c 81       	ldd	r25, Y+4	; 0x04
    243a:	01 97       	sbiw	r24, 0x01	; 1
    243c:	9c 83       	std	Y+4, r25	; 0x04
    243e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2440:	eb 81       	ldd	r30, Y+3	; 0x03
    2442:	fc 81       	ldd	r31, Y+4	; 0x04
    2444:	83 e2       	ldi	r24, 0x23	; 35
    2446:	80 83       	st	Z, r24
	pxTopOfStack--;
    2448:	8b 81       	ldd	r24, Y+3	; 0x03
    244a:	9c 81       	ldd	r25, Y+4	; 0x04
    244c:	01 97       	sbiw	r24, 0x01	; 1
    244e:	9c 83       	std	Y+4, r25	; 0x04
    2450:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    2452:	8f 81       	ldd	r24, Y+7	; 0x07
    2454:	98 85       	ldd	r25, Y+8	; 0x08
    2456:	9a 83       	std	Y+2, r25	; 0x02
    2458:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    245a:	89 81       	ldd	r24, Y+1	; 0x01
    245c:	eb 81       	ldd	r30, Y+3	; 0x03
    245e:	fc 81       	ldd	r31, Y+4	; 0x04
    2460:	80 83       	st	Z, r24
	pxTopOfStack--;
    2462:	8b 81       	ldd	r24, Y+3	; 0x03
    2464:	9c 81       	ldd	r25, Y+4	; 0x04
    2466:	01 97       	sbiw	r24, 0x01	; 1
    2468:	9c 83       	std	Y+4, r25	; 0x04
    246a:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    246c:	89 81       	ldd	r24, Y+1	; 0x01
    246e:	9a 81       	ldd	r25, Y+2	; 0x02
    2470:	89 2f       	mov	r24, r25
    2472:	99 27       	eor	r25, r25
    2474:	9a 83       	std	Y+2, r25	; 0x02
    2476:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2478:	89 81       	ldd	r24, Y+1	; 0x01
    247a:	eb 81       	ldd	r30, Y+3	; 0x03
    247c:	fc 81       	ldd	r31, Y+4	; 0x04
    247e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2480:	8b 81       	ldd	r24, Y+3	; 0x03
    2482:	9c 81       	ldd	r25, Y+4	; 0x04
    2484:	01 97       	sbiw	r24, 0x01	; 1
    2486:	9c 83       	std	Y+4, r25	; 0x04
    2488:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    248a:	eb 81       	ldd	r30, Y+3	; 0x03
    248c:	fc 81       	ldd	r31, Y+4	; 0x04
    248e:	86 e2       	ldi	r24, 0x26	; 38
    2490:	80 83       	st	Z, r24
	pxTopOfStack--;
    2492:	8b 81       	ldd	r24, Y+3	; 0x03
    2494:	9c 81       	ldd	r25, Y+4	; 0x04
    2496:	01 97       	sbiw	r24, 0x01	; 1
    2498:	9c 83       	std	Y+4, r25	; 0x04
    249a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    249c:	eb 81       	ldd	r30, Y+3	; 0x03
    249e:	fc 81       	ldd	r31, Y+4	; 0x04
    24a0:	87 e2       	ldi	r24, 0x27	; 39
    24a2:	80 83       	st	Z, r24
	pxTopOfStack--;
    24a4:	8b 81       	ldd	r24, Y+3	; 0x03
    24a6:	9c 81       	ldd	r25, Y+4	; 0x04
    24a8:	01 97       	sbiw	r24, 0x01	; 1
    24aa:	9c 83       	std	Y+4, r25	; 0x04
    24ac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    24ae:	eb 81       	ldd	r30, Y+3	; 0x03
    24b0:	fc 81       	ldd	r31, Y+4	; 0x04
    24b2:	88 e2       	ldi	r24, 0x28	; 40
    24b4:	80 83       	st	Z, r24
	pxTopOfStack--;
    24b6:	8b 81       	ldd	r24, Y+3	; 0x03
    24b8:	9c 81       	ldd	r25, Y+4	; 0x04
    24ba:	01 97       	sbiw	r24, 0x01	; 1
    24bc:	9c 83       	std	Y+4, r25	; 0x04
    24be:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    24c0:	eb 81       	ldd	r30, Y+3	; 0x03
    24c2:	fc 81       	ldd	r31, Y+4	; 0x04
    24c4:	89 e2       	ldi	r24, 0x29	; 41
    24c6:	80 83       	st	Z, r24
	pxTopOfStack--;
    24c8:	8b 81       	ldd	r24, Y+3	; 0x03
    24ca:	9c 81       	ldd	r25, Y+4	; 0x04
    24cc:	01 97       	sbiw	r24, 0x01	; 1
    24ce:	9c 83       	std	Y+4, r25	; 0x04
    24d0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    24d2:	eb 81       	ldd	r30, Y+3	; 0x03
    24d4:	fc 81       	ldd	r31, Y+4	; 0x04
    24d6:	80 e3       	ldi	r24, 0x30	; 48
    24d8:	80 83       	st	Z, r24
	pxTopOfStack--;
    24da:	8b 81       	ldd	r24, Y+3	; 0x03
    24dc:	9c 81       	ldd	r25, Y+4	; 0x04
    24de:	01 97       	sbiw	r24, 0x01	; 1
    24e0:	9c 83       	std	Y+4, r25	; 0x04
    24e2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    24e4:	eb 81       	ldd	r30, Y+3	; 0x03
    24e6:	fc 81       	ldd	r31, Y+4	; 0x04
    24e8:	81 e3       	ldi	r24, 0x31	; 49
    24ea:	80 83       	st	Z, r24
	pxTopOfStack--;
    24ec:	8b 81       	ldd	r24, Y+3	; 0x03
    24ee:	9c 81       	ldd	r25, Y+4	; 0x04
    24f0:	01 97       	sbiw	r24, 0x01	; 1
    24f2:	9c 83       	std	Y+4, r25	; 0x04
    24f4:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    24f6:	8b 81       	ldd	r24, Y+3	; 0x03
    24f8:	9c 81       	ldd	r25, Y+4	; 0x04
}
    24fa:	28 96       	adiw	r28, 0x08	; 8
    24fc:	0f b6       	in	r0, 0x3f	; 63
    24fe:	f8 94       	cli
    2500:	de bf       	out	0x3e, r29	; 62
    2502:	0f be       	out	0x3f, r0	; 63
    2504:	cd bf       	out	0x3d, r28	; 61
    2506:	cf 91       	pop	r28
    2508:	df 91       	pop	r29
    250a:	08 95       	ret

0000250c <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    250c:	df 93       	push	r29
    250e:	cf 93       	push	r28
    2510:	cd b7       	in	r28, 0x3d	; 61
    2512:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2514:	0e 94 78 13 	call	0x26f0	; 0x26f0 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2518:	a0 91 ce 06 	lds	r26, 0x06CE
    251c:	b0 91 cf 06 	lds	r27, 0x06CF
    2520:	cd 91       	ld	r28, X+
    2522:	cd bf       	out	0x3d, r28	; 61
    2524:	dd 91       	ld	r29, X+
    2526:	de bf       	out	0x3e, r29	; 62
    2528:	ff 91       	pop	r31
    252a:	ef 91       	pop	r30
    252c:	df 91       	pop	r29
    252e:	cf 91       	pop	r28
    2530:	bf 91       	pop	r27
    2532:	af 91       	pop	r26
    2534:	9f 91       	pop	r25
    2536:	8f 91       	pop	r24
    2538:	7f 91       	pop	r23
    253a:	6f 91       	pop	r22
    253c:	5f 91       	pop	r21
    253e:	4f 91       	pop	r20
    2540:	3f 91       	pop	r19
    2542:	2f 91       	pop	r18
    2544:	1f 91       	pop	r17
    2546:	0f 91       	pop	r16
    2548:	ff 90       	pop	r15
    254a:	ef 90       	pop	r14
    254c:	df 90       	pop	r13
    254e:	cf 90       	pop	r12
    2550:	bf 90       	pop	r11
    2552:	af 90       	pop	r10
    2554:	9f 90       	pop	r9
    2556:	8f 90       	pop	r8
    2558:	7f 90       	pop	r7
    255a:	6f 90       	pop	r6
    255c:	5f 90       	pop	r5
    255e:	4f 90       	pop	r4
    2560:	3f 90       	pop	r3
    2562:	2f 90       	pop	r2
    2564:	1f 90       	pop	r1
    2566:	0f 90       	pop	r0
    2568:	0f be       	out	0x3f, r0	; 63
    256a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    256c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    256e:	81 e0       	ldi	r24, 0x01	; 1
}
    2570:	cf 91       	pop	r28
    2572:	df 91       	pop	r29
    2574:	08 95       	ret

00002576 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2576:	df 93       	push	r29
    2578:	cf 93       	push	r28
    257a:	cd b7       	in	r28, 0x3d	; 61
    257c:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    257e:	cf 91       	pop	r28
    2580:	df 91       	pop	r29
    2582:	08 95       	ret

00002584 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2584:	0f 92       	push	r0
    2586:	0f b6       	in	r0, 0x3f	; 63
    2588:	f8 94       	cli
    258a:	0f 92       	push	r0
    258c:	1f 92       	push	r1
    258e:	11 24       	eor	r1, r1
    2590:	2f 92       	push	r2
    2592:	3f 92       	push	r3
    2594:	4f 92       	push	r4
    2596:	5f 92       	push	r5
    2598:	6f 92       	push	r6
    259a:	7f 92       	push	r7
    259c:	8f 92       	push	r8
    259e:	9f 92       	push	r9
    25a0:	af 92       	push	r10
    25a2:	bf 92       	push	r11
    25a4:	cf 92       	push	r12
    25a6:	df 92       	push	r13
    25a8:	ef 92       	push	r14
    25aa:	ff 92       	push	r15
    25ac:	0f 93       	push	r16
    25ae:	1f 93       	push	r17
    25b0:	2f 93       	push	r18
    25b2:	3f 93       	push	r19
    25b4:	4f 93       	push	r20
    25b6:	5f 93       	push	r21
    25b8:	6f 93       	push	r22
    25ba:	7f 93       	push	r23
    25bc:	8f 93       	push	r24
    25be:	9f 93       	push	r25
    25c0:	af 93       	push	r26
    25c2:	bf 93       	push	r27
    25c4:	cf 93       	push	r28
    25c6:	df 93       	push	r29
    25c8:	ef 93       	push	r30
    25ca:	ff 93       	push	r31
    25cc:	a0 91 ce 06 	lds	r26, 0x06CE
    25d0:	b0 91 cf 06 	lds	r27, 0x06CF
    25d4:	0d b6       	in	r0, 0x3d	; 61
    25d6:	0d 92       	st	X+, r0
    25d8:	0e b6       	in	r0, 0x3e	; 62
    25da:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    25dc:	0e 94 59 28 	call	0x50b2	; 0x50b2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    25e0:	a0 91 ce 06 	lds	r26, 0x06CE
    25e4:	b0 91 cf 06 	lds	r27, 0x06CF
    25e8:	cd 91       	ld	r28, X+
    25ea:	cd bf       	out	0x3d, r28	; 61
    25ec:	dd 91       	ld	r29, X+
    25ee:	de bf       	out	0x3e, r29	; 62
    25f0:	ff 91       	pop	r31
    25f2:	ef 91       	pop	r30
    25f4:	df 91       	pop	r29
    25f6:	cf 91       	pop	r28
    25f8:	bf 91       	pop	r27
    25fa:	af 91       	pop	r26
    25fc:	9f 91       	pop	r25
    25fe:	8f 91       	pop	r24
    2600:	7f 91       	pop	r23
    2602:	6f 91       	pop	r22
    2604:	5f 91       	pop	r21
    2606:	4f 91       	pop	r20
    2608:	3f 91       	pop	r19
    260a:	2f 91       	pop	r18
    260c:	1f 91       	pop	r17
    260e:	0f 91       	pop	r16
    2610:	ff 90       	pop	r15
    2612:	ef 90       	pop	r14
    2614:	df 90       	pop	r13
    2616:	cf 90       	pop	r12
    2618:	bf 90       	pop	r11
    261a:	af 90       	pop	r10
    261c:	9f 90       	pop	r9
    261e:	8f 90       	pop	r8
    2620:	7f 90       	pop	r7
    2622:	6f 90       	pop	r6
    2624:	5f 90       	pop	r5
    2626:	4f 90       	pop	r4
    2628:	3f 90       	pop	r3
    262a:	2f 90       	pop	r2
    262c:	1f 90       	pop	r1
    262e:	0f 90       	pop	r0
    2630:	0f be       	out	0x3f, r0	; 63
    2632:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2634:	08 95       	ret

00002636 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2636:	0f 92       	push	r0
    2638:	0f b6       	in	r0, 0x3f	; 63
    263a:	f8 94       	cli
    263c:	0f 92       	push	r0
    263e:	1f 92       	push	r1
    2640:	11 24       	eor	r1, r1
    2642:	2f 92       	push	r2
    2644:	3f 92       	push	r3
    2646:	4f 92       	push	r4
    2648:	5f 92       	push	r5
    264a:	6f 92       	push	r6
    264c:	7f 92       	push	r7
    264e:	8f 92       	push	r8
    2650:	9f 92       	push	r9
    2652:	af 92       	push	r10
    2654:	bf 92       	push	r11
    2656:	cf 92       	push	r12
    2658:	df 92       	push	r13
    265a:	ef 92       	push	r14
    265c:	ff 92       	push	r15
    265e:	0f 93       	push	r16
    2660:	1f 93       	push	r17
    2662:	2f 93       	push	r18
    2664:	3f 93       	push	r19
    2666:	4f 93       	push	r20
    2668:	5f 93       	push	r21
    266a:	6f 93       	push	r22
    266c:	7f 93       	push	r23
    266e:	8f 93       	push	r24
    2670:	9f 93       	push	r25
    2672:	af 93       	push	r26
    2674:	bf 93       	push	r27
    2676:	cf 93       	push	r28
    2678:	df 93       	push	r29
    267a:	ef 93       	push	r30
    267c:	ff 93       	push	r31
    267e:	a0 91 ce 06 	lds	r26, 0x06CE
    2682:	b0 91 cf 06 	lds	r27, 0x06CF
    2686:	0d b6       	in	r0, 0x3d	; 61
    2688:	0d 92       	st	X+, r0
    268a:	0e b6       	in	r0, 0x3e	; 62
    268c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    268e:	0e 94 74 27 	call	0x4ee8	; 0x4ee8 <xTaskIncrementTick>
    2692:	88 23       	and	r24, r24
    2694:	11 f0       	breq	.+4      	; 0x269a <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    2696:	0e 94 59 28 	call	0x50b2	; 0x50b2 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    269a:	a0 91 ce 06 	lds	r26, 0x06CE
    269e:	b0 91 cf 06 	lds	r27, 0x06CF
    26a2:	cd 91       	ld	r28, X+
    26a4:	cd bf       	out	0x3d, r28	; 61
    26a6:	dd 91       	ld	r29, X+
    26a8:	de bf       	out	0x3e, r29	; 62
    26aa:	ff 91       	pop	r31
    26ac:	ef 91       	pop	r30
    26ae:	df 91       	pop	r29
    26b0:	cf 91       	pop	r28
    26b2:	bf 91       	pop	r27
    26b4:	af 91       	pop	r26
    26b6:	9f 91       	pop	r25
    26b8:	8f 91       	pop	r24
    26ba:	7f 91       	pop	r23
    26bc:	6f 91       	pop	r22
    26be:	5f 91       	pop	r21
    26c0:	4f 91       	pop	r20
    26c2:	3f 91       	pop	r19
    26c4:	2f 91       	pop	r18
    26c6:	1f 91       	pop	r17
    26c8:	0f 91       	pop	r16
    26ca:	ff 90       	pop	r15
    26cc:	ef 90       	pop	r14
    26ce:	df 90       	pop	r13
    26d0:	cf 90       	pop	r12
    26d2:	bf 90       	pop	r11
    26d4:	af 90       	pop	r10
    26d6:	9f 90       	pop	r9
    26d8:	8f 90       	pop	r8
    26da:	7f 90       	pop	r7
    26dc:	6f 90       	pop	r6
    26de:	5f 90       	pop	r5
    26e0:	4f 90       	pop	r4
    26e2:	3f 90       	pop	r3
    26e4:	2f 90       	pop	r2
    26e6:	1f 90       	pop	r1
    26e8:	0f 90       	pop	r0
    26ea:	0f be       	out	0x3f, r0	; 63
    26ec:	0f 90       	pop	r0

	asm volatile ( "ret" );
    26ee:	08 95       	ret

000026f0 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    26f0:	df 93       	push	r29
    26f2:	cf 93       	push	r28
    26f4:	00 d0       	rcall	.+0      	; 0x26f6 <prvSetupTimerInterrupt+0x6>
    26f6:	00 d0       	rcall	.+0      	; 0x26f8 <prvSetupTimerInterrupt+0x8>
    26f8:	00 d0       	rcall	.+0      	; 0x26fa <prvSetupTimerInterrupt+0xa>
    26fa:	cd b7       	in	r28, 0x3d	; 61
    26fc:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    26fe:	80 e4       	ldi	r24, 0x40	; 64
    2700:	9f e1       	ldi	r25, 0x1F	; 31
    2702:	a0 e0       	ldi	r26, 0x00	; 0
    2704:	b0 e0       	ldi	r27, 0x00	; 0
    2706:	8b 83       	std	Y+3, r24	; 0x03
    2708:	9c 83       	std	Y+4, r25	; 0x04
    270a:	ad 83       	std	Y+5, r26	; 0x05
    270c:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    270e:	8b 81       	ldd	r24, Y+3	; 0x03
    2710:	9c 81       	ldd	r25, Y+4	; 0x04
    2712:	ad 81       	ldd	r26, Y+5	; 0x05
    2714:	be 81       	ldd	r27, Y+6	; 0x06
    2716:	68 94       	set
    2718:	15 f8       	bld	r1, 5
    271a:	b6 95       	lsr	r27
    271c:	a7 95       	ror	r26
    271e:	97 95       	ror	r25
    2720:	87 95       	ror	r24
    2722:	16 94       	lsr	r1
    2724:	d1 f7       	brne	.-12     	; 0x271a <prvSetupTimerInterrupt+0x2a>
    2726:	8b 83       	std	Y+3, r24	; 0x03
    2728:	9c 83       	std	Y+4, r25	; 0x04
    272a:	ad 83       	std	Y+5, r26	; 0x05
    272c:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    272e:	8b 81       	ldd	r24, Y+3	; 0x03
    2730:	9c 81       	ldd	r25, Y+4	; 0x04
    2732:	ad 81       	ldd	r26, Y+5	; 0x05
    2734:	be 81       	ldd	r27, Y+6	; 0x06
    2736:	01 97       	sbiw	r24, 0x01	; 1
    2738:	a1 09       	sbc	r26, r1
    273a:	b1 09       	sbc	r27, r1
    273c:	8b 83       	std	Y+3, r24	; 0x03
    273e:	9c 83       	std	Y+4, r25	; 0x04
    2740:	ad 83       	std	Y+5, r26	; 0x05
    2742:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2744:	8b 81       	ldd	r24, Y+3	; 0x03
    2746:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    2748:	8b 81       	ldd	r24, Y+3	; 0x03
    274a:	9c 81       	ldd	r25, Y+4	; 0x04
    274c:	ad 81       	ldd	r26, Y+5	; 0x05
    274e:	be 81       	ldd	r27, Y+6	; 0x06
    2750:	89 2f       	mov	r24, r25
    2752:	9a 2f       	mov	r25, r26
    2754:	ab 2f       	mov	r26, r27
    2756:	bb 27       	eor	r27, r27
    2758:	8b 83       	std	Y+3, r24	; 0x03
    275a:	9c 83       	std	Y+4, r25	; 0x04
    275c:	ad 83       	std	Y+5, r26	; 0x05
    275e:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2760:	8b 81       	ldd	r24, Y+3	; 0x03
    2762:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    2764:	eb e4       	ldi	r30, 0x4B	; 75
    2766:	f0 e0       	ldi	r31, 0x00	; 0
    2768:	8a 81       	ldd	r24, Y+2	; 0x02
    276a:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    276c:	ea e4       	ldi	r30, 0x4A	; 74
    276e:	f0 e0       	ldi	r31, 0x00	; 0
    2770:	89 81       	ldd	r24, Y+1	; 0x01
    2772:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    2774:	8b e0       	ldi	r24, 0x0B	; 11
    2776:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    2778:	ee e4       	ldi	r30, 0x4E	; 78
    277a:	f0 e0       	ldi	r31, 0x00	; 0
    277c:	89 81       	ldd	r24, Y+1	; 0x01
    277e:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2780:	e9 e5       	ldi	r30, 0x59	; 89
    2782:	f0 e0       	ldi	r31, 0x00	; 0
    2784:	80 81       	ld	r24, Z
    2786:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2788:	89 81       	ldd	r24, Y+1	; 0x01
    278a:	80 61       	ori	r24, 0x10	; 16
    278c:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    278e:	e9 e5       	ldi	r30, 0x59	; 89
    2790:	f0 e0       	ldi	r31, 0x00	; 0
    2792:	89 81       	ldd	r24, Y+1	; 0x01
    2794:	80 83       	st	Z, r24
}
    2796:	26 96       	adiw	r28, 0x06	; 6
    2798:	0f b6       	in	r0, 0x3f	; 63
    279a:	f8 94       	cli
    279c:	de bf       	out	0x3e, r29	; 62
    279e:	0f be       	out	0x3f, r0	; 63
    27a0:	cd bf       	out	0x3d, r28	; 61
    27a2:	cf 91       	pop	r28
    27a4:	df 91       	pop	r29
    27a6:	08 95       	ret

000027a8 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    27a8:	0e 94 1b 13 	call	0x2636	; 0x2636 <vPortYieldFromTick>
		asm volatile ( "reti" );
    27ac:	18 95       	reti

000027ae <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    27ae:	df 93       	push	r29
    27b0:	cf 93       	push	r28
    27b2:	00 d0       	rcall	.+0      	; 0x27b4 <xQueueGenericReset+0x6>
    27b4:	00 d0       	rcall	.+0      	; 0x27b6 <xQueueGenericReset+0x8>
    27b6:	0f 92       	push	r0
    27b8:	cd b7       	in	r28, 0x3d	; 61
    27ba:	de b7       	in	r29, 0x3e	; 62
    27bc:	9c 83       	std	Y+4, r25	; 0x04
    27be:	8b 83       	std	Y+3, r24	; 0x03
    27c0:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    27c2:	8b 81       	ldd	r24, Y+3	; 0x03
    27c4:	9c 81       	ldd	r25, Y+4	; 0x04
    27c6:	9a 83       	std	Y+2, r25	; 0x02
    27c8:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    27ca:	0f b6       	in	r0, 0x3f	; 63
    27cc:	f8 94       	cli
    27ce:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    27d0:	e9 81       	ldd	r30, Y+1	; 0x01
    27d2:	fa 81       	ldd	r31, Y+2	; 0x02
    27d4:	40 81       	ld	r20, Z
    27d6:	51 81       	ldd	r21, Z+1	; 0x01
    27d8:	e9 81       	ldd	r30, Y+1	; 0x01
    27da:	fa 81       	ldd	r31, Y+2	; 0x02
    27dc:	83 8d       	ldd	r24, Z+27	; 0x1b
    27de:	28 2f       	mov	r18, r24
    27e0:	30 e0       	ldi	r19, 0x00	; 0
    27e2:	e9 81       	ldd	r30, Y+1	; 0x01
    27e4:	fa 81       	ldd	r31, Y+2	; 0x02
    27e6:	84 8d       	ldd	r24, Z+28	; 0x1c
    27e8:	88 2f       	mov	r24, r24
    27ea:	90 e0       	ldi	r25, 0x00	; 0
    27ec:	bc 01       	movw	r22, r24
    27ee:	26 9f       	mul	r18, r22
    27f0:	c0 01       	movw	r24, r0
    27f2:	27 9f       	mul	r18, r23
    27f4:	90 0d       	add	r25, r0
    27f6:	36 9f       	mul	r19, r22
    27f8:	90 0d       	add	r25, r0
    27fa:	11 24       	eor	r1, r1
    27fc:	84 0f       	add	r24, r20
    27fe:	95 1f       	adc	r25, r21
    2800:	e9 81       	ldd	r30, Y+1	; 0x01
    2802:	fa 81       	ldd	r31, Y+2	; 0x02
    2804:	95 83       	std	Z+5, r25	; 0x05
    2806:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2808:	e9 81       	ldd	r30, Y+1	; 0x01
    280a:	fa 81       	ldd	r31, Y+2	; 0x02
    280c:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    280e:	e9 81       	ldd	r30, Y+1	; 0x01
    2810:	fa 81       	ldd	r31, Y+2	; 0x02
    2812:	80 81       	ld	r24, Z
    2814:	91 81       	ldd	r25, Z+1	; 0x01
    2816:	e9 81       	ldd	r30, Y+1	; 0x01
    2818:	fa 81       	ldd	r31, Y+2	; 0x02
    281a:	93 83       	std	Z+3, r25	; 0x03
    281c:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    281e:	e9 81       	ldd	r30, Y+1	; 0x01
    2820:	fa 81       	ldd	r31, Y+2	; 0x02
    2822:	40 81       	ld	r20, Z
    2824:	51 81       	ldd	r21, Z+1	; 0x01
    2826:	e9 81       	ldd	r30, Y+1	; 0x01
    2828:	fa 81       	ldd	r31, Y+2	; 0x02
    282a:	83 8d       	ldd	r24, Z+27	; 0x1b
    282c:	88 2f       	mov	r24, r24
    282e:	90 e0       	ldi	r25, 0x00	; 0
    2830:	9c 01       	movw	r18, r24
    2832:	21 50       	subi	r18, 0x01	; 1
    2834:	30 40       	sbci	r19, 0x00	; 0
    2836:	e9 81       	ldd	r30, Y+1	; 0x01
    2838:	fa 81       	ldd	r31, Y+2	; 0x02
    283a:	84 8d       	ldd	r24, Z+28	; 0x1c
    283c:	88 2f       	mov	r24, r24
    283e:	90 e0       	ldi	r25, 0x00	; 0
    2840:	bc 01       	movw	r22, r24
    2842:	26 9f       	mul	r18, r22
    2844:	c0 01       	movw	r24, r0
    2846:	27 9f       	mul	r18, r23
    2848:	90 0d       	add	r25, r0
    284a:	36 9f       	mul	r19, r22
    284c:	90 0d       	add	r25, r0
    284e:	11 24       	eor	r1, r1
    2850:	84 0f       	add	r24, r20
    2852:	95 1f       	adc	r25, r21
    2854:	e9 81       	ldd	r30, Y+1	; 0x01
    2856:	fa 81       	ldd	r31, Y+2	; 0x02
    2858:	97 83       	std	Z+7, r25	; 0x07
    285a:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    285c:	e9 81       	ldd	r30, Y+1	; 0x01
    285e:	fa 81       	ldd	r31, Y+2	; 0x02
    2860:	8f ef       	ldi	r24, 0xFF	; 255
    2862:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    2864:	e9 81       	ldd	r30, Y+1	; 0x01
    2866:	fa 81       	ldd	r31, Y+2	; 0x02
    2868:	8f ef       	ldi	r24, 0xFF	; 255
    286a:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    286c:	8d 81       	ldd	r24, Y+5	; 0x05
    286e:	88 23       	and	r24, r24
    2870:	79 f4       	brne	.+30     	; 0x2890 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2872:	e9 81       	ldd	r30, Y+1	; 0x01
    2874:	fa 81       	ldd	r31, Y+2	; 0x02
    2876:	80 85       	ldd	r24, Z+8	; 0x08
    2878:	88 23       	and	r24, r24
    287a:	a1 f0       	breq	.+40     	; 0x28a4 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    287c:	89 81       	ldd	r24, Y+1	; 0x01
    287e:	9a 81       	ldd	r25, Y+2	; 0x02
    2880:	08 96       	adiw	r24, 0x08	; 8
    2882:	0e 94 18 29 	call	0x5230	; 0x5230 <xTaskRemoveFromEventList>
    2886:	88 23       	and	r24, r24
    2888:	69 f0       	breq	.+26     	; 0x28a4 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    288a:	0e 94 c2 12 	call	0x2584	; 0x2584 <vPortYield>
    288e:	0a c0       	rjmp	.+20     	; 0x28a4 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    2890:	89 81       	ldd	r24, Y+1	; 0x01
    2892:	9a 81       	ldd	r25, Y+2	; 0x02
    2894:	08 96       	adiw	r24, 0x08	; 8
    2896:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    289a:	89 81       	ldd	r24, Y+1	; 0x01
    289c:	9a 81       	ldd	r25, Y+2	; 0x02
    289e:	41 96       	adiw	r24, 0x11	; 17
    28a0:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    28a4:	0f 90       	pop	r0
    28a6:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    28a8:	81 e0       	ldi	r24, 0x01	; 1
}
    28aa:	0f 90       	pop	r0
    28ac:	0f 90       	pop	r0
    28ae:	0f 90       	pop	r0
    28b0:	0f 90       	pop	r0
    28b2:	0f 90       	pop	r0
    28b4:	cf 91       	pop	r28
    28b6:	df 91       	pop	r29
    28b8:	08 95       	ret

000028ba <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    28ba:	0f 93       	push	r16
    28bc:	1f 93       	push	r17
    28be:	df 93       	push	r29
    28c0:	cf 93       	push	r28
    28c2:	cd b7       	in	r28, 0x3d	; 61
    28c4:	de b7       	in	r29, 0x3e	; 62
    28c6:	29 97       	sbiw	r28, 0x09	; 9
    28c8:	0f b6       	in	r0, 0x3f	; 63
    28ca:	f8 94       	cli
    28cc:	de bf       	out	0x3e, r29	; 62
    28ce:	0f be       	out	0x3f, r0	; 63
    28d0:	cd bf       	out	0x3d, r28	; 61
    28d2:	8f 83       	std	Y+7, r24	; 0x07
    28d4:	68 87       	std	Y+8, r22	; 0x08
    28d6:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    28d8:	88 85       	ldd	r24, Y+8	; 0x08
    28da:	88 23       	and	r24, r24
    28dc:	19 f4       	brne	.+6      	; 0x28e4 <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    28de:	1c 82       	std	Y+4, r1	; 0x04
    28e0:	1b 82       	std	Y+3, r1	; 0x03
    28e2:	10 c0       	rjmp	.+32     	; 0x2904 <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    28e4:	8f 81       	ldd	r24, Y+7	; 0x07
    28e6:	28 2f       	mov	r18, r24
    28e8:	30 e0       	ldi	r19, 0x00	; 0
    28ea:	88 85       	ldd	r24, Y+8	; 0x08
    28ec:	88 2f       	mov	r24, r24
    28ee:	90 e0       	ldi	r25, 0x00	; 0
    28f0:	ac 01       	movw	r20, r24
    28f2:	24 9f       	mul	r18, r20
    28f4:	c0 01       	movw	r24, r0
    28f6:	25 9f       	mul	r18, r21
    28f8:	90 0d       	add	r25, r0
    28fa:	34 9f       	mul	r19, r20
    28fc:	90 0d       	add	r25, r0
    28fe:	11 24       	eor	r1, r1
    2900:	9c 83       	std	Y+4, r25	; 0x04
    2902:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    2904:	8b 81       	ldd	r24, Y+3	; 0x03
    2906:	9c 81       	ldd	r25, Y+4	; 0x04
    2908:	4f 96       	adiw	r24, 0x1f	; 31
    290a:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <pvPortMalloc>
    290e:	9e 83       	std	Y+6, r25	; 0x06
    2910:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    2912:	8d 81       	ldd	r24, Y+5	; 0x05
    2914:	9e 81       	ldd	r25, Y+6	; 0x06
    2916:	00 97       	sbiw	r24, 0x00	; 0
    2918:	a1 f0       	breq	.+40     	; 0x2942 <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    291a:	8d 81       	ldd	r24, Y+5	; 0x05
    291c:	9e 81       	ldd	r25, Y+6	; 0x06
    291e:	9a 83       	std	Y+2, r25	; 0x02
    2920:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2922:	89 81       	ldd	r24, Y+1	; 0x01
    2924:	9a 81       	ldd	r25, Y+2	; 0x02
    2926:	4f 96       	adiw	r24, 0x1f	; 31
    2928:	9a 83       	std	Y+2, r25	; 0x02
    292a:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    292c:	29 81       	ldd	r18, Y+1	; 0x01
    292e:	3a 81       	ldd	r19, Y+2	; 0x02
    2930:	ed 81       	ldd	r30, Y+5	; 0x05
    2932:	fe 81       	ldd	r31, Y+6	; 0x06
    2934:	8f 81       	ldd	r24, Y+7	; 0x07
    2936:	68 85       	ldd	r22, Y+8	; 0x08
    2938:	a9 01       	movw	r20, r18
    293a:	29 85       	ldd	r18, Y+9	; 0x09
    293c:	8f 01       	movw	r16, r30
    293e:	0e 94 ae 14 	call	0x295c	; 0x295c <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    2942:	8d 81       	ldd	r24, Y+5	; 0x05
    2944:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    2946:	29 96       	adiw	r28, 0x09	; 9
    2948:	0f b6       	in	r0, 0x3f	; 63
    294a:	f8 94       	cli
    294c:	de bf       	out	0x3e, r29	; 62
    294e:	0f be       	out	0x3f, r0	; 63
    2950:	cd bf       	out	0x3d, r28	; 61
    2952:	cf 91       	pop	r28
    2954:	df 91       	pop	r29
    2956:	1f 91       	pop	r17
    2958:	0f 91       	pop	r16
    295a:	08 95       	ret

0000295c <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    295c:	0f 93       	push	r16
    295e:	1f 93       	push	r17
    2960:	df 93       	push	r29
    2962:	cf 93       	push	r28
    2964:	cd b7       	in	r28, 0x3d	; 61
    2966:	de b7       	in	r29, 0x3e	; 62
    2968:	27 97       	sbiw	r28, 0x07	; 7
    296a:	0f b6       	in	r0, 0x3f	; 63
    296c:	f8 94       	cli
    296e:	de bf       	out	0x3e, r29	; 62
    2970:	0f be       	out	0x3f, r0	; 63
    2972:	cd bf       	out	0x3d, r28	; 61
    2974:	89 83       	std	Y+1, r24	; 0x01
    2976:	6a 83       	std	Y+2, r22	; 0x02
    2978:	5c 83       	std	Y+4, r21	; 0x04
    297a:	4b 83       	std	Y+3, r20	; 0x03
    297c:	2d 83       	std	Y+5, r18	; 0x05
    297e:	1f 83       	std	Y+7, r17	; 0x07
    2980:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    2982:	8a 81       	ldd	r24, Y+2	; 0x02
    2984:	88 23       	and	r24, r24
    2986:	39 f4       	brne	.+14     	; 0x2996 <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    2988:	8e 81       	ldd	r24, Y+6	; 0x06
    298a:	9f 81       	ldd	r25, Y+7	; 0x07
    298c:	ee 81       	ldd	r30, Y+6	; 0x06
    298e:	ff 81       	ldd	r31, Y+7	; 0x07
    2990:	91 83       	std	Z+1, r25	; 0x01
    2992:	80 83       	st	Z, r24
    2994:	06 c0       	rjmp	.+12     	; 0x29a2 <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    2996:	8b 81       	ldd	r24, Y+3	; 0x03
    2998:	9c 81       	ldd	r25, Y+4	; 0x04
    299a:	ee 81       	ldd	r30, Y+6	; 0x06
    299c:	ff 81       	ldd	r31, Y+7	; 0x07
    299e:	91 83       	std	Z+1, r25	; 0x01
    29a0:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    29a2:	ee 81       	ldd	r30, Y+6	; 0x06
    29a4:	ff 81       	ldd	r31, Y+7	; 0x07
    29a6:	89 81       	ldd	r24, Y+1	; 0x01
    29a8:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    29aa:	ee 81       	ldd	r30, Y+6	; 0x06
    29ac:	ff 81       	ldd	r31, Y+7	; 0x07
    29ae:	8a 81       	ldd	r24, Y+2	; 0x02
    29b0:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    29b2:	8e 81       	ldd	r24, Y+6	; 0x06
    29b4:	9f 81       	ldd	r25, Y+7	; 0x07
    29b6:	61 e0       	ldi	r22, 0x01	; 1
    29b8:	0e 94 d7 13 	call	0x27ae	; 0x27ae <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    29bc:	27 96       	adiw	r28, 0x07	; 7
    29be:	0f b6       	in	r0, 0x3f	; 63
    29c0:	f8 94       	cli
    29c2:	de bf       	out	0x3e, r29	; 62
    29c4:	0f be       	out	0x3f, r0	; 63
    29c6:	cd bf       	out	0x3d, r28	; 61
    29c8:	cf 91       	pop	r28
    29ca:	df 91       	pop	r29
    29cc:	1f 91       	pop	r17
    29ce:	0f 91       	pop	r16
    29d0:	08 95       	ret

000029d2 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    29d2:	df 93       	push	r29
    29d4:	cf 93       	push	r28
    29d6:	cd b7       	in	r28, 0x3d	; 61
    29d8:	de b7       	in	r29, 0x3e	; 62
    29da:	2f 97       	sbiw	r28, 0x0f	; 15
    29dc:	0f b6       	in	r0, 0x3f	; 63
    29de:	f8 94       	cli
    29e0:	de bf       	out	0x3e, r29	; 62
    29e2:	0f be       	out	0x3f, r0	; 63
    29e4:	cd bf       	out	0x3d, r28	; 61
    29e6:	99 87       	std	Y+9, r25	; 0x09
    29e8:	88 87       	std	Y+8, r24	; 0x08
    29ea:	7b 87       	std	Y+11, r23	; 0x0b
    29ec:	6a 87       	std	Y+10, r22	; 0x0a
    29ee:	5d 87       	std	Y+13, r21	; 0x0d
    29f0:	4c 87       	std	Y+12, r20	; 0x0c
    29f2:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    29f4:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    29f6:	88 85       	ldd	r24, Y+8	; 0x08
    29f8:	99 85       	ldd	r25, Y+9	; 0x09
    29fa:	9a 83       	std	Y+2, r25	; 0x02
    29fc:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    29fe:	0f b6       	in	r0, 0x3f	; 63
    2a00:	f8 94       	cli
    2a02:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2a04:	e9 81       	ldd	r30, Y+1	; 0x01
    2a06:	fa 81       	ldd	r31, Y+2	; 0x02
    2a08:	92 8d       	ldd	r25, Z+26	; 0x1a
    2a0a:	e9 81       	ldd	r30, Y+1	; 0x01
    2a0c:	fa 81       	ldd	r31, Y+2	; 0x02
    2a0e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2a10:	98 17       	cp	r25, r24
    2a12:	18 f0       	brcs	.+6      	; 0x2a1a <xQueueGenericSend+0x48>
    2a14:	8e 85       	ldd	r24, Y+14	; 0x0e
    2a16:	82 30       	cpi	r24, 0x02	; 2
    2a18:	11 f5       	brne	.+68     	; 0x2a5e <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2a1a:	89 81       	ldd	r24, Y+1	; 0x01
    2a1c:	9a 81       	ldd	r25, Y+2	; 0x02
    2a1e:	2a 85       	ldd	r18, Y+10	; 0x0a
    2a20:	3b 85       	ldd	r19, Y+11	; 0x0b
    2a22:	b9 01       	movw	r22, r18
    2a24:	4e 85       	ldd	r20, Y+14	; 0x0e
    2a26:	0e 94 3b 19 	call	0x3276	; 0x3276 <prvCopyDataToQueue>
    2a2a:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2a2c:	e9 81       	ldd	r30, Y+1	; 0x01
    2a2e:	fa 81       	ldd	r31, Y+2	; 0x02
    2a30:	81 89       	ldd	r24, Z+17	; 0x11
    2a32:	88 23       	and	r24, r24
    2a34:	51 f0       	breq	.+20     	; 0x2a4a <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2a36:	89 81       	ldd	r24, Y+1	; 0x01
    2a38:	9a 81       	ldd	r25, Y+2	; 0x02
    2a3a:	41 96       	adiw	r24, 0x11	; 17
    2a3c:	0e 94 18 29 	call	0x5230	; 0x5230 <xTaskRemoveFromEventList>
    2a40:	88 23       	and	r24, r24
    2a42:	41 f0       	breq	.+16     	; 0x2a54 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    2a44:	0e 94 c2 12 	call	0x2584	; 0x2584 <vPortYield>
    2a48:	05 c0       	rjmp	.+10     	; 0x2a54 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    2a4a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a4c:	88 23       	and	r24, r24
    2a4e:	11 f0       	breq	.+4      	; 0x2a54 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    2a50:	0e 94 c2 12 	call	0x2584	; 0x2584 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    2a54:	0f 90       	pop	r0
    2a56:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2a58:	81 e0       	ldi	r24, 0x01	; 1
    2a5a:	8f 87       	std	Y+15, r24	; 0x0f
    2a5c:	5c c0       	rjmp	.+184    	; 0x2b16 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2a5e:	8c 85       	ldd	r24, Y+12	; 0x0c
    2a60:	9d 85       	ldd	r25, Y+13	; 0x0d
    2a62:	00 97       	sbiw	r24, 0x00	; 0
    2a64:	21 f4       	brne	.+8      	; 0x2a6e <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2a66:	0f 90       	pop	r0
    2a68:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    2a6a:	1f 86       	std	Y+15, r1	; 0x0f
    2a6c:	54 c0       	rjmp	.+168    	; 0x2b16 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    2a6e:	8c 81       	ldd	r24, Y+4	; 0x04
    2a70:	88 23       	and	r24, r24
    2a72:	31 f4       	brne	.+12     	; 0x2a80 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2a74:	ce 01       	movw	r24, r28
    2a76:	05 96       	adiw	r24, 0x05	; 5
    2a78:	0e 94 fe 29 	call	0x53fc	; 0x53fc <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2a7c:	81 e0       	ldi	r24, 0x01	; 1
    2a7e:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2a80:	0f 90       	pop	r0
    2a82:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2a84:	0e 94 78 26 	call	0x4cf0	; 0x4cf0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2a88:	0f b6       	in	r0, 0x3f	; 63
    2a8a:	f8 94       	cli
    2a8c:	0f 92       	push	r0
    2a8e:	e9 81       	ldd	r30, Y+1	; 0x01
    2a90:	fa 81       	ldd	r31, Y+2	; 0x02
    2a92:	85 8d       	ldd	r24, Z+29	; 0x1d
    2a94:	8f 3f       	cpi	r24, 0xFF	; 255
    2a96:	19 f4       	brne	.+6      	; 0x2a9e <xQueueGenericSend+0xcc>
    2a98:	e9 81       	ldd	r30, Y+1	; 0x01
    2a9a:	fa 81       	ldd	r31, Y+2	; 0x02
    2a9c:	15 8e       	std	Z+29, r1	; 0x1d
    2a9e:	e9 81       	ldd	r30, Y+1	; 0x01
    2aa0:	fa 81       	ldd	r31, Y+2	; 0x02
    2aa2:	86 8d       	ldd	r24, Z+30	; 0x1e
    2aa4:	8f 3f       	cpi	r24, 0xFF	; 255
    2aa6:	19 f4       	brne	.+6      	; 0x2aae <xQueueGenericSend+0xdc>
    2aa8:	e9 81       	ldd	r30, Y+1	; 0x01
    2aaa:	fa 81       	ldd	r31, Y+2	; 0x02
    2aac:	16 8e       	std	Z+30, r1	; 0x1e
    2aae:	0f 90       	pop	r0
    2ab0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2ab2:	ce 01       	movw	r24, r28
    2ab4:	05 96       	adiw	r24, 0x05	; 5
    2ab6:	9e 01       	movw	r18, r28
    2ab8:	24 5f       	subi	r18, 0xF4	; 244
    2aba:	3f 4f       	sbci	r19, 0xFF	; 255
    2abc:	b9 01       	movw	r22, r18
    2abe:	0e 94 17 2a 	call	0x542e	; 0x542e <xTaskCheckForTimeOut>
    2ac2:	88 23       	and	r24, r24
    2ac4:	09 f5       	brne	.+66     	; 0x2b08 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2ac6:	89 81       	ldd	r24, Y+1	; 0x01
    2ac8:	9a 81       	ldd	r25, Y+2	; 0x02
    2aca:	0e 94 b7 1a 	call	0x356e	; 0x356e <prvIsQueueFull>
    2ace:	88 23       	and	r24, r24
    2ad0:	a1 f0       	breq	.+40     	; 0x2afa <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2ad2:	89 81       	ldd	r24, Y+1	; 0x01
    2ad4:	9a 81       	ldd	r25, Y+2	; 0x02
    2ad6:	08 96       	adiw	r24, 0x08	; 8
    2ad8:	2c 85       	ldd	r18, Y+12	; 0x0c
    2ada:	3d 85       	ldd	r19, Y+13	; 0x0d
    2adc:	b9 01       	movw	r22, r18
    2ade:	0e 94 c6 28 	call	0x518c	; 0x518c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2ae2:	89 81       	ldd	r24, Y+1	; 0x01
    2ae4:	9a 81       	ldd	r25, Y+2	; 0x02
    2ae6:	0e 94 28 1a 	call	0x3450	; 0x3450 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    2aea:	0e 94 84 26 	call	0x4d08	; 0x4d08 <xTaskResumeAll>
    2aee:	88 23       	and	r24, r24
    2af0:	09 f0       	breq	.+2      	; 0x2af4 <xQueueGenericSend+0x122>
    2af2:	85 cf       	rjmp	.-246    	; 0x29fe <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    2af4:	0e 94 c2 12 	call	0x2584	; 0x2584 <vPortYield>
    2af8:	82 cf       	rjmp	.-252    	; 0x29fe <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2afa:	89 81       	ldd	r24, Y+1	; 0x01
    2afc:	9a 81       	ldd	r25, Y+2	; 0x02
    2afe:	0e 94 28 1a 	call	0x3450	; 0x3450 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2b02:	0e 94 84 26 	call	0x4d08	; 0x4d08 <xTaskResumeAll>
    2b06:	7b cf       	rjmp	.-266    	; 0x29fe <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    2b08:	89 81       	ldd	r24, Y+1	; 0x01
    2b0a:	9a 81       	ldd	r25, Y+2	; 0x02
    2b0c:	0e 94 28 1a 	call	0x3450	; 0x3450 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2b10:	0e 94 84 26 	call	0x4d08	; 0x4d08 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2b14:	1f 86       	std	Y+15, r1	; 0x0f
    2b16:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    2b18:	2f 96       	adiw	r28, 0x0f	; 15
    2b1a:	0f b6       	in	r0, 0x3f	; 63
    2b1c:	f8 94       	cli
    2b1e:	de bf       	out	0x3e, r29	; 62
    2b20:	0f be       	out	0x3f, r0	; 63
    2b22:	cd bf       	out	0x3d, r28	; 61
    2b24:	cf 91       	pop	r28
    2b26:	df 91       	pop	r29
    2b28:	08 95       	ret

00002b2a <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    2b2a:	df 93       	push	r29
    2b2c:	cf 93       	push	r28
    2b2e:	cd b7       	in	r28, 0x3d	; 61
    2b30:	de b7       	in	r29, 0x3e	; 62
    2b32:	2c 97       	sbiw	r28, 0x0c	; 12
    2b34:	0f b6       	in	r0, 0x3f	; 63
    2b36:	f8 94       	cli
    2b38:	de bf       	out	0x3e, r29	; 62
    2b3a:	0f be       	out	0x3f, r0	; 63
    2b3c:	cd bf       	out	0x3d, r28	; 61
    2b3e:	9f 83       	std	Y+7, r25	; 0x07
    2b40:	8e 83       	std	Y+6, r24	; 0x06
    2b42:	79 87       	std	Y+9, r23	; 0x09
    2b44:	68 87       	std	Y+8, r22	; 0x08
    2b46:	5b 87       	std	Y+11, r21	; 0x0b
    2b48:	4a 87       	std	Y+10, r20	; 0x0a
    2b4a:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    2b4c:	8e 81       	ldd	r24, Y+6	; 0x06
    2b4e:	9f 81       	ldd	r25, Y+7	; 0x07
    2b50:	9b 83       	std	Y+3, r25	; 0x03
    2b52:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2b54:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2b56:	ea 81       	ldd	r30, Y+2	; 0x02
    2b58:	fb 81       	ldd	r31, Y+3	; 0x03
    2b5a:	92 8d       	ldd	r25, Z+26	; 0x1a
    2b5c:	ea 81       	ldd	r30, Y+2	; 0x02
    2b5e:	fb 81       	ldd	r31, Y+3	; 0x03
    2b60:	83 8d       	ldd	r24, Z+27	; 0x1b
    2b62:	98 17       	cp	r25, r24
    2b64:	18 f0       	brcs	.+6      	; 0x2b6c <xQueueGenericSendFromISR+0x42>
    2b66:	8c 85       	ldd	r24, Y+12	; 0x0c
    2b68:	82 30       	cpi	r24, 0x02	; 2
    2b6a:	61 f5       	brne	.+88     	; 0x2bc4 <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    2b6c:	ea 81       	ldd	r30, Y+2	; 0x02
    2b6e:	fb 81       	ldd	r31, Y+3	; 0x03
    2b70:	86 8d       	ldd	r24, Z+30	; 0x1e
    2b72:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2b74:	8a 81       	ldd	r24, Y+2	; 0x02
    2b76:	9b 81       	ldd	r25, Y+3	; 0x03
    2b78:	28 85       	ldd	r18, Y+8	; 0x08
    2b7a:	39 85       	ldd	r19, Y+9	; 0x09
    2b7c:	b9 01       	movw	r22, r18
    2b7e:	4c 85       	ldd	r20, Y+12	; 0x0c
    2b80:	0e 94 3b 19 	call	0x3276	; 0x3276 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    2b84:	89 81       	ldd	r24, Y+1	; 0x01
    2b86:	8f 3f       	cpi	r24, 0xFF	; 255
    2b88:	a9 f4       	brne	.+42     	; 0x2bb4 <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2b8a:	ea 81       	ldd	r30, Y+2	; 0x02
    2b8c:	fb 81       	ldd	r31, Y+3	; 0x03
    2b8e:	81 89       	ldd	r24, Z+17	; 0x11
    2b90:	88 23       	and	r24, r24
    2b92:	a9 f0       	breq	.+42     	; 0x2bbe <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2b94:	8a 81       	ldd	r24, Y+2	; 0x02
    2b96:	9b 81       	ldd	r25, Y+3	; 0x03
    2b98:	41 96       	adiw	r24, 0x11	; 17
    2b9a:	0e 94 18 29 	call	0x5230	; 0x5230 <xTaskRemoveFromEventList>
    2b9e:	88 23       	and	r24, r24
    2ba0:	71 f0       	breq	.+28     	; 0x2bbe <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2ba2:	8a 85       	ldd	r24, Y+10	; 0x0a
    2ba4:	9b 85       	ldd	r25, Y+11	; 0x0b
    2ba6:	00 97       	sbiw	r24, 0x00	; 0
    2ba8:	51 f0       	breq	.+20     	; 0x2bbe <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2baa:	ea 85       	ldd	r30, Y+10	; 0x0a
    2bac:	fb 85       	ldd	r31, Y+11	; 0x0b
    2bae:	81 e0       	ldi	r24, 0x01	; 1
    2bb0:	80 83       	st	Z, r24
    2bb2:	05 c0       	rjmp	.+10     	; 0x2bbe <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2bb4:	89 81       	ldd	r24, Y+1	; 0x01
    2bb6:	8f 5f       	subi	r24, 0xFF	; 255
    2bb8:	ea 81       	ldd	r30, Y+2	; 0x02
    2bba:	fb 81       	ldd	r31, Y+3	; 0x03
    2bbc:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2bbe:	81 e0       	ldi	r24, 0x01	; 1
    2bc0:	8d 83       	std	Y+5, r24	; 0x05
    2bc2:	01 c0       	rjmp	.+2      	; 0x2bc6 <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2bc4:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2bc6:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2bc8:	2c 96       	adiw	r28, 0x0c	; 12
    2bca:	0f b6       	in	r0, 0x3f	; 63
    2bcc:	f8 94       	cli
    2bce:	de bf       	out	0x3e, r29	; 62
    2bd0:	0f be       	out	0x3f, r0	; 63
    2bd2:	cd bf       	out	0x3d, r28	; 61
    2bd4:	cf 91       	pop	r28
    2bd6:	df 91       	pop	r29
    2bd8:	08 95       	ret

00002bda <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2bda:	df 93       	push	r29
    2bdc:	cf 93       	push	r28
    2bde:	cd b7       	in	r28, 0x3d	; 61
    2be0:	de b7       	in	r29, 0x3e	; 62
    2be2:	2a 97       	sbiw	r28, 0x0a	; 10
    2be4:	0f b6       	in	r0, 0x3f	; 63
    2be6:	f8 94       	cli
    2be8:	de bf       	out	0x3e, r29	; 62
    2bea:	0f be       	out	0x3f, r0	; 63
    2bec:	cd bf       	out	0x3d, r28	; 61
    2bee:	98 87       	std	Y+8, r25	; 0x08
    2bf0:	8f 83       	std	Y+7, r24	; 0x07
    2bf2:	7a 87       	std	Y+10, r23	; 0x0a
    2bf4:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    2bf6:	8f 81       	ldd	r24, Y+7	; 0x07
    2bf8:	98 85       	ldd	r25, Y+8	; 0x08
    2bfa:	9c 83       	std	Y+4, r25	; 0x04
    2bfc:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2bfe:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2c00:	eb 81       	ldd	r30, Y+3	; 0x03
    2c02:	fc 81       	ldd	r31, Y+4	; 0x04
    2c04:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c06:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    2c08:	eb 81       	ldd	r30, Y+3	; 0x03
    2c0a:	fc 81       	ldd	r31, Y+4	; 0x04
    2c0c:	93 8d       	ldd	r25, Z+27	; 0x1b
    2c0e:	8a 81       	ldd	r24, Y+2	; 0x02
    2c10:	89 17       	cp	r24, r25
    2c12:	48 f5       	brcc	.+82     	; 0x2c66 <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    2c14:	eb 81       	ldd	r30, Y+3	; 0x03
    2c16:	fc 81       	ldd	r31, Y+4	; 0x04
    2c18:	86 8d       	ldd	r24, Z+30	; 0x1e
    2c1a:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2c1c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c1e:	8f 5f       	subi	r24, 0xFF	; 255
    2c20:	eb 81       	ldd	r30, Y+3	; 0x03
    2c22:	fc 81       	ldd	r31, Y+4	; 0x04
    2c24:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    2c26:	89 81       	ldd	r24, Y+1	; 0x01
    2c28:	8f 3f       	cpi	r24, 0xFF	; 255
    2c2a:	a9 f4       	brne	.+42     	; 0x2c56 <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2c2c:	eb 81       	ldd	r30, Y+3	; 0x03
    2c2e:	fc 81       	ldd	r31, Y+4	; 0x04
    2c30:	81 89       	ldd	r24, Z+17	; 0x11
    2c32:	88 23       	and	r24, r24
    2c34:	a9 f0       	breq	.+42     	; 0x2c60 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2c36:	8b 81       	ldd	r24, Y+3	; 0x03
    2c38:	9c 81       	ldd	r25, Y+4	; 0x04
    2c3a:	41 96       	adiw	r24, 0x11	; 17
    2c3c:	0e 94 18 29 	call	0x5230	; 0x5230 <xTaskRemoveFromEventList>
    2c40:	88 23       	and	r24, r24
    2c42:	71 f0       	breq	.+28     	; 0x2c60 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2c44:	89 85       	ldd	r24, Y+9	; 0x09
    2c46:	9a 85       	ldd	r25, Y+10	; 0x0a
    2c48:	00 97       	sbiw	r24, 0x00	; 0
    2c4a:	51 f0       	breq	.+20     	; 0x2c60 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2c4c:	e9 85       	ldd	r30, Y+9	; 0x09
    2c4e:	fa 85       	ldd	r31, Y+10	; 0x0a
    2c50:	81 e0       	ldi	r24, 0x01	; 1
    2c52:	80 83       	st	Z, r24
    2c54:	05 c0       	rjmp	.+10     	; 0x2c60 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2c56:	89 81       	ldd	r24, Y+1	; 0x01
    2c58:	8f 5f       	subi	r24, 0xFF	; 255
    2c5a:	eb 81       	ldd	r30, Y+3	; 0x03
    2c5c:	fc 81       	ldd	r31, Y+4	; 0x04
    2c5e:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2c60:	81 e0       	ldi	r24, 0x01	; 1
    2c62:	8e 83       	std	Y+6, r24	; 0x06
    2c64:	01 c0       	rjmp	.+2      	; 0x2c68 <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2c66:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2c68:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2c6a:	2a 96       	adiw	r28, 0x0a	; 10
    2c6c:	0f b6       	in	r0, 0x3f	; 63
    2c6e:	f8 94       	cli
    2c70:	de bf       	out	0x3e, r29	; 62
    2c72:	0f be       	out	0x3f, r0	; 63
    2c74:	cd bf       	out	0x3d, r28	; 61
    2c76:	cf 91       	pop	r28
    2c78:	df 91       	pop	r29
    2c7a:	08 95       	ret

00002c7c <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    2c7c:	df 93       	push	r29
    2c7e:	cf 93       	push	r28
    2c80:	cd b7       	in	r28, 0x3d	; 61
    2c82:	de b7       	in	r29, 0x3e	; 62
    2c84:	2e 97       	sbiw	r28, 0x0e	; 14
    2c86:	0f b6       	in	r0, 0x3f	; 63
    2c88:	f8 94       	cli
    2c8a:	de bf       	out	0x3e, r29	; 62
    2c8c:	0f be       	out	0x3f, r0	; 63
    2c8e:	cd bf       	out	0x3d, r28	; 61
    2c90:	99 87       	std	Y+9, r25	; 0x09
    2c92:	88 87       	std	Y+8, r24	; 0x08
    2c94:	7b 87       	std	Y+11, r23	; 0x0b
    2c96:	6a 87       	std	Y+10, r22	; 0x0a
    2c98:	5d 87       	std	Y+13, r21	; 0x0d
    2c9a:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    2c9c:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    2c9e:	88 85       	ldd	r24, Y+8	; 0x08
    2ca0:	99 85       	ldd	r25, Y+9	; 0x09
    2ca2:	9b 83       	std	Y+3, r25	; 0x03
    2ca4:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2ca6:	0f b6       	in	r0, 0x3f	; 63
    2ca8:	f8 94       	cli
    2caa:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2cac:	ea 81       	ldd	r30, Y+2	; 0x02
    2cae:	fb 81       	ldd	r31, Y+3	; 0x03
    2cb0:	82 8d       	ldd	r24, Z+26	; 0x1a
    2cb2:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2cb4:	89 81       	ldd	r24, Y+1	; 0x01
    2cb6:	88 23       	and	r24, r24
    2cb8:	f9 f0       	breq	.+62     	; 0x2cf8 <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2cba:	8a 81       	ldd	r24, Y+2	; 0x02
    2cbc:	9b 81       	ldd	r25, Y+3	; 0x03
    2cbe:	2a 85       	ldd	r18, Y+10	; 0x0a
    2cc0:	3b 85       	ldd	r19, Y+11	; 0x0b
    2cc2:	b9 01       	movw	r22, r18
    2cc4:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2cc8:	89 81       	ldd	r24, Y+1	; 0x01
    2cca:	81 50       	subi	r24, 0x01	; 1
    2ccc:	ea 81       	ldd	r30, Y+2	; 0x02
    2cce:	fb 81       	ldd	r31, Y+3	; 0x03
    2cd0:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2cd2:	ea 81       	ldd	r30, Y+2	; 0x02
    2cd4:	fb 81       	ldd	r31, Y+3	; 0x03
    2cd6:	80 85       	ldd	r24, Z+8	; 0x08
    2cd8:	88 23       	and	r24, r24
    2cda:	49 f0       	breq	.+18     	; 0x2cee <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2cdc:	8a 81       	ldd	r24, Y+2	; 0x02
    2cde:	9b 81       	ldd	r25, Y+3	; 0x03
    2ce0:	08 96       	adiw	r24, 0x08	; 8
    2ce2:	0e 94 18 29 	call	0x5230	; 0x5230 <xTaskRemoveFromEventList>
    2ce6:	88 23       	and	r24, r24
    2ce8:	11 f0       	breq	.+4      	; 0x2cee <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    2cea:	0e 94 c2 12 	call	0x2584	; 0x2584 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2cee:	0f 90       	pop	r0
    2cf0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2cf2:	81 e0       	ldi	r24, 0x01	; 1
    2cf4:	8e 87       	std	Y+14, r24	; 0x0e
    2cf6:	63 c0       	rjmp	.+198    	; 0x2dbe <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2cf8:	8c 85       	ldd	r24, Y+12	; 0x0c
    2cfa:	9d 85       	ldd	r25, Y+13	; 0x0d
    2cfc:	00 97       	sbiw	r24, 0x00	; 0
    2cfe:	21 f4       	brne	.+8      	; 0x2d08 <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2d00:	0f 90       	pop	r0
    2d02:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2d04:	1e 86       	std	Y+14, r1	; 0x0e
    2d06:	5b c0       	rjmp	.+182    	; 0x2dbe <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    2d08:	8c 81       	ldd	r24, Y+4	; 0x04
    2d0a:	88 23       	and	r24, r24
    2d0c:	31 f4       	brne	.+12     	; 0x2d1a <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2d0e:	ce 01       	movw	r24, r28
    2d10:	05 96       	adiw	r24, 0x05	; 5
    2d12:	0e 94 fe 29 	call	0x53fc	; 0x53fc <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2d16:	81 e0       	ldi	r24, 0x01	; 1
    2d18:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2d1a:	0f 90       	pop	r0
    2d1c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2d1e:	0e 94 78 26 	call	0x4cf0	; 0x4cf0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2d22:	0f b6       	in	r0, 0x3f	; 63
    2d24:	f8 94       	cli
    2d26:	0f 92       	push	r0
    2d28:	ea 81       	ldd	r30, Y+2	; 0x02
    2d2a:	fb 81       	ldd	r31, Y+3	; 0x03
    2d2c:	85 8d       	ldd	r24, Z+29	; 0x1d
    2d2e:	8f 3f       	cpi	r24, 0xFF	; 255
    2d30:	19 f4       	brne	.+6      	; 0x2d38 <xQueueReceive+0xbc>
    2d32:	ea 81       	ldd	r30, Y+2	; 0x02
    2d34:	fb 81       	ldd	r31, Y+3	; 0x03
    2d36:	15 8e       	std	Z+29, r1	; 0x1d
    2d38:	ea 81       	ldd	r30, Y+2	; 0x02
    2d3a:	fb 81       	ldd	r31, Y+3	; 0x03
    2d3c:	86 8d       	ldd	r24, Z+30	; 0x1e
    2d3e:	8f 3f       	cpi	r24, 0xFF	; 255
    2d40:	19 f4       	brne	.+6      	; 0x2d48 <xQueueReceive+0xcc>
    2d42:	ea 81       	ldd	r30, Y+2	; 0x02
    2d44:	fb 81       	ldd	r31, Y+3	; 0x03
    2d46:	16 8e       	std	Z+30, r1	; 0x1e
    2d48:	0f 90       	pop	r0
    2d4a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2d4c:	ce 01       	movw	r24, r28
    2d4e:	05 96       	adiw	r24, 0x05	; 5
    2d50:	9e 01       	movw	r18, r28
    2d52:	24 5f       	subi	r18, 0xF4	; 244
    2d54:	3f 4f       	sbci	r19, 0xFF	; 255
    2d56:	b9 01       	movw	r22, r18
    2d58:	0e 94 17 2a 	call	0x542e	; 0x542e <xTaskCheckForTimeOut>
    2d5c:	88 23       	and	r24, r24
    2d5e:	09 f5       	brne	.+66     	; 0x2da2 <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2d60:	8a 81       	ldd	r24, Y+2	; 0x02
    2d62:	9b 81       	ldd	r25, Y+3	; 0x03
    2d64:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <prvIsQueueEmpty>
    2d68:	88 23       	and	r24, r24
    2d6a:	a1 f0       	breq	.+40     	; 0x2d94 <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2d6c:	8a 81       	ldd	r24, Y+2	; 0x02
    2d6e:	9b 81       	ldd	r25, Y+3	; 0x03
    2d70:	41 96       	adiw	r24, 0x11	; 17
    2d72:	2c 85       	ldd	r18, Y+12	; 0x0c
    2d74:	3d 85       	ldd	r19, Y+13	; 0x0d
    2d76:	b9 01       	movw	r22, r18
    2d78:	0e 94 c6 28 	call	0x518c	; 0x518c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2d7c:	8a 81       	ldd	r24, Y+2	; 0x02
    2d7e:	9b 81       	ldd	r25, Y+3	; 0x03
    2d80:	0e 94 28 1a 	call	0x3450	; 0x3450 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2d84:	0e 94 84 26 	call	0x4d08	; 0x4d08 <xTaskResumeAll>
    2d88:	88 23       	and	r24, r24
    2d8a:	09 f0       	breq	.+2      	; 0x2d8e <xQueueReceive+0x112>
    2d8c:	8c cf       	rjmp	.-232    	; 0x2ca6 <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    2d8e:	0e 94 c2 12 	call	0x2584	; 0x2584 <vPortYield>
    2d92:	89 cf       	rjmp	.-238    	; 0x2ca6 <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    2d94:	8a 81       	ldd	r24, Y+2	; 0x02
    2d96:	9b 81       	ldd	r25, Y+3	; 0x03
    2d98:	0e 94 28 1a 	call	0x3450	; 0x3450 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2d9c:	0e 94 84 26 	call	0x4d08	; 0x4d08 <xTaskResumeAll>
    2da0:	82 cf       	rjmp	.-252    	; 0x2ca6 <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    2da2:	8a 81       	ldd	r24, Y+2	; 0x02
    2da4:	9b 81       	ldd	r25, Y+3	; 0x03
    2da6:	0e 94 28 1a 	call	0x3450	; 0x3450 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2daa:	0e 94 84 26 	call	0x4d08	; 0x4d08 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2dae:	8a 81       	ldd	r24, Y+2	; 0x02
    2db0:	9b 81       	ldd	r25, Y+3	; 0x03
    2db2:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <prvIsQueueEmpty>
    2db6:	88 23       	and	r24, r24
    2db8:	09 f4       	brne	.+2      	; 0x2dbc <xQueueReceive+0x140>
    2dba:	75 cf       	rjmp	.-278    	; 0x2ca6 <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2dbc:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2dbe:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    2dc0:	2e 96       	adiw	r28, 0x0e	; 14
    2dc2:	0f b6       	in	r0, 0x3f	; 63
    2dc4:	f8 94       	cli
    2dc6:	de bf       	out	0x3e, r29	; 62
    2dc8:	0f be       	out	0x3f, r0	; 63
    2dca:	cd bf       	out	0x3d, r28	; 61
    2dcc:	cf 91       	pop	r28
    2dce:	df 91       	pop	r29
    2dd0:	08 95       	ret

00002dd2 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    2dd2:	df 93       	push	r29
    2dd4:	cf 93       	push	r28
    2dd6:	cd b7       	in	r28, 0x3d	; 61
    2dd8:	de b7       	in	r29, 0x3e	; 62
    2dda:	2c 97       	sbiw	r28, 0x0c	; 12
    2ddc:	0f b6       	in	r0, 0x3f	; 63
    2dde:	f8 94       	cli
    2de0:	de bf       	out	0x3e, r29	; 62
    2de2:	0f be       	out	0x3f, r0	; 63
    2de4:	cd bf       	out	0x3d, r28	; 61
    2de6:	99 87       	std	Y+9, r25	; 0x09
    2de8:	88 87       	std	Y+8, r24	; 0x08
    2dea:	7b 87       	std	Y+11, r23	; 0x0b
    2dec:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    2dee:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    2df0:	88 85       	ldd	r24, Y+8	; 0x08
    2df2:	99 85       	ldd	r25, Y+9	; 0x09
    2df4:	9b 83       	std	Y+3, r25	; 0x03
    2df6:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2df8:	0f b6       	in	r0, 0x3f	; 63
    2dfa:	f8 94       	cli
    2dfc:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    2dfe:	ea 81       	ldd	r30, Y+2	; 0x02
    2e00:	fb 81       	ldd	r31, Y+3	; 0x03
    2e02:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e04:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    2e06:	89 81       	ldd	r24, Y+1	; 0x01
    2e08:	88 23       	and	r24, r24
    2e0a:	c1 f0       	breq	.+48     	; 0x2e3c <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    2e0c:	89 81       	ldd	r24, Y+1	; 0x01
    2e0e:	81 50       	subi	r24, 0x01	; 1
    2e10:	ea 81       	ldd	r30, Y+2	; 0x02
    2e12:	fb 81       	ldd	r31, Y+3	; 0x03
    2e14:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2e16:	ea 81       	ldd	r30, Y+2	; 0x02
    2e18:	fb 81       	ldd	r31, Y+3	; 0x03
    2e1a:	80 85       	ldd	r24, Z+8	; 0x08
    2e1c:	88 23       	and	r24, r24
    2e1e:	49 f0       	breq	.+18     	; 0x2e32 <xQueueSemaphoreTake+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2e20:	8a 81       	ldd	r24, Y+2	; 0x02
    2e22:	9b 81       	ldd	r25, Y+3	; 0x03
    2e24:	08 96       	adiw	r24, 0x08	; 8
    2e26:	0e 94 18 29 	call	0x5230	; 0x5230 <xTaskRemoveFromEventList>
    2e2a:	88 23       	and	r24, r24
    2e2c:	11 f0       	breq	.+4      	; 0x2e32 <xQueueSemaphoreTake+0x60>
					{
						queueYIELD_IF_USING_PREEMPTION();
    2e2e:	0e 94 c2 12 	call	0x2584	; 0x2584 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2e32:	0f 90       	pop	r0
    2e34:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2e36:	81 e0       	ldi	r24, 0x01	; 1
    2e38:	8c 87       	std	Y+12, r24	; 0x0c
    2e3a:	63 c0       	rjmp	.+198    	; 0x2f02 <xQueueSemaphoreTake+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2e3c:	8a 85       	ldd	r24, Y+10	; 0x0a
    2e3e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2e40:	00 97       	sbiw	r24, 0x00	; 0
    2e42:	21 f4       	brne	.+8      	; 0x2e4c <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    2e44:	0f 90       	pop	r0
    2e46:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2e48:	1c 86       	std	Y+12, r1	; 0x0c
    2e4a:	5b c0       	rjmp	.+182    	; 0x2f02 <xQueueSemaphoreTake+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    2e4c:	8c 81       	ldd	r24, Y+4	; 0x04
    2e4e:	88 23       	and	r24, r24
    2e50:	31 f4       	brne	.+12     	; 0x2e5e <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2e52:	ce 01       	movw	r24, r28
    2e54:	05 96       	adiw	r24, 0x05	; 5
    2e56:	0e 94 fe 29 	call	0x53fc	; 0x53fc <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2e5a:	81 e0       	ldi	r24, 0x01	; 1
    2e5c:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2e5e:	0f 90       	pop	r0
    2e60:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    2e62:	0e 94 78 26 	call	0x4cf0	; 0x4cf0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2e66:	0f b6       	in	r0, 0x3f	; 63
    2e68:	f8 94       	cli
    2e6a:	0f 92       	push	r0
    2e6c:	ea 81       	ldd	r30, Y+2	; 0x02
    2e6e:	fb 81       	ldd	r31, Y+3	; 0x03
    2e70:	85 8d       	ldd	r24, Z+29	; 0x1d
    2e72:	8f 3f       	cpi	r24, 0xFF	; 255
    2e74:	19 f4       	brne	.+6      	; 0x2e7c <xQueueSemaphoreTake+0xaa>
    2e76:	ea 81       	ldd	r30, Y+2	; 0x02
    2e78:	fb 81       	ldd	r31, Y+3	; 0x03
    2e7a:	15 8e       	std	Z+29, r1	; 0x1d
    2e7c:	ea 81       	ldd	r30, Y+2	; 0x02
    2e7e:	fb 81       	ldd	r31, Y+3	; 0x03
    2e80:	86 8d       	ldd	r24, Z+30	; 0x1e
    2e82:	8f 3f       	cpi	r24, 0xFF	; 255
    2e84:	19 f4       	brne	.+6      	; 0x2e8c <xQueueSemaphoreTake+0xba>
    2e86:	ea 81       	ldd	r30, Y+2	; 0x02
    2e88:	fb 81       	ldd	r31, Y+3	; 0x03
    2e8a:	16 8e       	std	Z+30, r1	; 0x1e
    2e8c:	0f 90       	pop	r0
    2e8e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2e90:	ce 01       	movw	r24, r28
    2e92:	05 96       	adiw	r24, 0x05	; 5
    2e94:	9e 01       	movw	r18, r28
    2e96:	26 5f       	subi	r18, 0xF6	; 246
    2e98:	3f 4f       	sbci	r19, 0xFF	; 255
    2e9a:	b9 01       	movw	r22, r18
    2e9c:	0e 94 17 2a 	call	0x542e	; 0x542e <xTaskCheckForTimeOut>
    2ea0:	88 23       	and	r24, r24
    2ea2:	09 f5       	brne	.+66     	; 0x2ee6 <xQueueSemaphoreTake+0x114>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2ea4:	8a 81       	ldd	r24, Y+2	; 0x02
    2ea6:	9b 81       	ldd	r25, Y+3	; 0x03
    2ea8:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <prvIsQueueEmpty>
    2eac:	88 23       	and	r24, r24
    2eae:	a1 f0       	breq	.+40     	; 0x2ed8 <xQueueSemaphoreTake+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2eb0:	8a 81       	ldd	r24, Y+2	; 0x02
    2eb2:	9b 81       	ldd	r25, Y+3	; 0x03
    2eb4:	41 96       	adiw	r24, 0x11	; 17
    2eb6:	2a 85       	ldd	r18, Y+10	; 0x0a
    2eb8:	3b 85       	ldd	r19, Y+11	; 0x0b
    2eba:	b9 01       	movw	r22, r18
    2ebc:	0e 94 c6 28 	call	0x518c	; 0x518c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2ec0:	8a 81       	ldd	r24, Y+2	; 0x02
    2ec2:	9b 81       	ldd	r25, Y+3	; 0x03
    2ec4:	0e 94 28 1a 	call	0x3450	; 0x3450 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2ec8:	0e 94 84 26 	call	0x4d08	; 0x4d08 <xTaskResumeAll>
    2ecc:	88 23       	and	r24, r24
    2ece:	09 f0       	breq	.+2      	; 0x2ed2 <xQueueSemaphoreTake+0x100>
    2ed0:	93 cf       	rjmp	.-218    	; 0x2df8 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    2ed2:	0e 94 c2 12 	call	0x2584	; 0x2584 <vPortYield>
    2ed6:	90 cf       	rjmp	.-224    	; 0x2df8 <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    2ed8:	8a 81       	ldd	r24, Y+2	; 0x02
    2eda:	9b 81       	ldd	r25, Y+3	; 0x03
    2edc:	0e 94 28 1a 	call	0x3450	; 0x3450 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2ee0:	0e 94 84 26 	call	0x4d08	; 0x4d08 <xTaskResumeAll>
    2ee4:	89 cf       	rjmp	.-238    	; 0x2df8 <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    2ee6:	8a 81       	ldd	r24, Y+2	; 0x02
    2ee8:	9b 81       	ldd	r25, Y+3	; 0x03
    2eea:	0e 94 28 1a 	call	0x3450	; 0x3450 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2eee:	0e 94 84 26 	call	0x4d08	; 0x4d08 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2ef2:	8a 81       	ldd	r24, Y+2	; 0x02
    2ef4:	9b 81       	ldd	r25, Y+3	; 0x03
    2ef6:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <prvIsQueueEmpty>
    2efa:	88 23       	and	r24, r24
    2efc:	09 f4       	brne	.+2      	; 0x2f00 <xQueueSemaphoreTake+0x12e>
    2efe:	7c cf       	rjmp	.-264    	; 0x2df8 <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2f00:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2f02:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    2f04:	2c 96       	adiw	r28, 0x0c	; 12
    2f06:	0f b6       	in	r0, 0x3f	; 63
    2f08:	f8 94       	cli
    2f0a:	de bf       	out	0x3e, r29	; 62
    2f0c:	0f be       	out	0x3f, r0	; 63
    2f0e:	cd bf       	out	0x3d, r28	; 61
    2f10:	cf 91       	pop	r28
    2f12:	df 91       	pop	r29
    2f14:	08 95       	ret

00002f16 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    2f16:	df 93       	push	r29
    2f18:	cf 93       	push	r28
    2f1a:	cd b7       	in	r28, 0x3d	; 61
    2f1c:	de b7       	in	r29, 0x3e	; 62
    2f1e:	60 97       	sbiw	r28, 0x10	; 16
    2f20:	0f b6       	in	r0, 0x3f	; 63
    2f22:	f8 94       	cli
    2f24:	de bf       	out	0x3e, r29	; 62
    2f26:	0f be       	out	0x3f, r0	; 63
    2f28:	cd bf       	out	0x3d, r28	; 61
    2f2a:	9b 87       	std	Y+11, r25	; 0x0b
    2f2c:	8a 87       	std	Y+10, r24	; 0x0a
    2f2e:	7d 87       	std	Y+13, r23	; 0x0d
    2f30:	6c 87       	std	Y+12, r22	; 0x0c
    2f32:	5f 87       	std	Y+15, r21	; 0x0f
    2f34:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    2f36:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    2f38:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f3a:	9b 85       	ldd	r25, Y+11	; 0x0b
    2f3c:	9b 83       	std	Y+3, r25	; 0x03
    2f3e:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2f40:	0f b6       	in	r0, 0x3f	; 63
    2f42:	f8 94       	cli
    2f44:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2f46:	ea 81       	ldd	r30, Y+2	; 0x02
    2f48:	fb 81       	ldd	r31, Y+3	; 0x03
    2f4a:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f4c:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2f4e:	89 81       	ldd	r24, Y+1	; 0x01
    2f50:	88 23       	and	r24, r24
    2f52:	31 f1       	breq	.+76     	; 0x2fa0 <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2f54:	ea 81       	ldd	r30, Y+2	; 0x02
    2f56:	fb 81       	ldd	r31, Y+3	; 0x03
    2f58:	86 81       	ldd	r24, Z+6	; 0x06
    2f5a:	97 81       	ldd	r25, Z+7	; 0x07
    2f5c:	9d 83       	std	Y+5, r25	; 0x05
    2f5e:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2f60:	8a 81       	ldd	r24, Y+2	; 0x02
    2f62:	9b 81       	ldd	r25, Y+3	; 0x03
    2f64:	2c 85       	ldd	r18, Y+12	; 0x0c
    2f66:	3d 85       	ldd	r19, Y+13	; 0x0d
    2f68:	b9 01       	movw	r22, r18
    2f6a:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2f6e:	ea 81       	ldd	r30, Y+2	; 0x02
    2f70:	fb 81       	ldd	r31, Y+3	; 0x03
    2f72:	8c 81       	ldd	r24, Y+4	; 0x04
    2f74:	9d 81       	ldd	r25, Y+5	; 0x05
    2f76:	97 83       	std	Z+7, r25	; 0x07
    2f78:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2f7a:	ea 81       	ldd	r30, Y+2	; 0x02
    2f7c:	fb 81       	ldd	r31, Y+3	; 0x03
    2f7e:	81 89       	ldd	r24, Z+17	; 0x11
    2f80:	88 23       	and	r24, r24
    2f82:	49 f0       	breq	.+18     	; 0x2f96 <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2f84:	8a 81       	ldd	r24, Y+2	; 0x02
    2f86:	9b 81       	ldd	r25, Y+3	; 0x03
    2f88:	41 96       	adiw	r24, 0x11	; 17
    2f8a:	0e 94 18 29 	call	0x5230	; 0x5230 <xTaskRemoveFromEventList>
    2f8e:	88 23       	and	r24, r24
    2f90:	11 f0       	breq	.+4      	; 0x2f96 <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    2f92:	0e 94 c2 12 	call	0x2584	; 0x2584 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2f96:	0f 90       	pop	r0
    2f98:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2f9a:	81 e0       	ldi	r24, 0x01	; 1
    2f9c:	88 8b       	std	Y+16, r24	; 0x10
    2f9e:	63 c0       	rjmp	.+198    	; 0x3066 <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2fa0:	8e 85       	ldd	r24, Y+14	; 0x0e
    2fa2:	9f 85       	ldd	r25, Y+15	; 0x0f
    2fa4:	00 97       	sbiw	r24, 0x00	; 0
    2fa6:	21 f4       	brne	.+8      	; 0x2fb0 <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2fa8:	0f 90       	pop	r0
    2faa:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2fac:	18 8a       	std	Y+16, r1	; 0x10
    2fae:	5b c0       	rjmp	.+182    	; 0x3066 <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    2fb0:	8e 81       	ldd	r24, Y+6	; 0x06
    2fb2:	88 23       	and	r24, r24
    2fb4:	31 f4       	brne	.+12     	; 0x2fc2 <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2fb6:	ce 01       	movw	r24, r28
    2fb8:	07 96       	adiw	r24, 0x07	; 7
    2fba:	0e 94 fe 29 	call	0x53fc	; 0x53fc <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2fbe:	81 e0       	ldi	r24, 0x01	; 1
    2fc0:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2fc2:	0f 90       	pop	r0
    2fc4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2fc6:	0e 94 78 26 	call	0x4cf0	; 0x4cf0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2fca:	0f b6       	in	r0, 0x3f	; 63
    2fcc:	f8 94       	cli
    2fce:	0f 92       	push	r0
    2fd0:	ea 81       	ldd	r30, Y+2	; 0x02
    2fd2:	fb 81       	ldd	r31, Y+3	; 0x03
    2fd4:	85 8d       	ldd	r24, Z+29	; 0x1d
    2fd6:	8f 3f       	cpi	r24, 0xFF	; 255
    2fd8:	19 f4       	brne	.+6      	; 0x2fe0 <xQueuePeek+0xca>
    2fda:	ea 81       	ldd	r30, Y+2	; 0x02
    2fdc:	fb 81       	ldd	r31, Y+3	; 0x03
    2fde:	15 8e       	std	Z+29, r1	; 0x1d
    2fe0:	ea 81       	ldd	r30, Y+2	; 0x02
    2fe2:	fb 81       	ldd	r31, Y+3	; 0x03
    2fe4:	86 8d       	ldd	r24, Z+30	; 0x1e
    2fe6:	8f 3f       	cpi	r24, 0xFF	; 255
    2fe8:	19 f4       	brne	.+6      	; 0x2ff0 <xQueuePeek+0xda>
    2fea:	ea 81       	ldd	r30, Y+2	; 0x02
    2fec:	fb 81       	ldd	r31, Y+3	; 0x03
    2fee:	16 8e       	std	Z+30, r1	; 0x1e
    2ff0:	0f 90       	pop	r0
    2ff2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2ff4:	ce 01       	movw	r24, r28
    2ff6:	07 96       	adiw	r24, 0x07	; 7
    2ff8:	9e 01       	movw	r18, r28
    2ffa:	22 5f       	subi	r18, 0xF2	; 242
    2ffc:	3f 4f       	sbci	r19, 0xFF	; 255
    2ffe:	b9 01       	movw	r22, r18
    3000:	0e 94 17 2a 	call	0x542e	; 0x542e <xTaskCheckForTimeOut>
    3004:	88 23       	and	r24, r24
    3006:	09 f5       	brne	.+66     	; 0x304a <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3008:	8a 81       	ldd	r24, Y+2	; 0x02
    300a:	9b 81       	ldd	r25, Y+3	; 0x03
    300c:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <prvIsQueueEmpty>
    3010:	88 23       	and	r24, r24
    3012:	a1 f0       	breq	.+40     	; 0x303c <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3014:	8a 81       	ldd	r24, Y+2	; 0x02
    3016:	9b 81       	ldd	r25, Y+3	; 0x03
    3018:	41 96       	adiw	r24, 0x11	; 17
    301a:	2e 85       	ldd	r18, Y+14	; 0x0e
    301c:	3f 85       	ldd	r19, Y+15	; 0x0f
    301e:	b9 01       	movw	r22, r18
    3020:	0e 94 c6 28 	call	0x518c	; 0x518c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3024:	8a 81       	ldd	r24, Y+2	; 0x02
    3026:	9b 81       	ldd	r25, Y+3	; 0x03
    3028:	0e 94 28 1a 	call	0x3450	; 0x3450 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    302c:	0e 94 84 26 	call	0x4d08	; 0x4d08 <xTaskResumeAll>
    3030:	88 23       	and	r24, r24
    3032:	09 f0       	breq	.+2      	; 0x3036 <xQueuePeek+0x120>
    3034:	85 cf       	rjmp	.-246    	; 0x2f40 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    3036:	0e 94 c2 12 	call	0x2584	; 0x2584 <vPortYield>
    303a:	82 cf       	rjmp	.-252    	; 0x2f40 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    303c:	8a 81       	ldd	r24, Y+2	; 0x02
    303e:	9b 81       	ldd	r25, Y+3	; 0x03
    3040:	0e 94 28 1a 	call	0x3450	; 0x3450 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3044:	0e 94 84 26 	call	0x4d08	; 0x4d08 <xTaskResumeAll>
    3048:	7b cf       	rjmp	.-266    	; 0x2f40 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    304a:	8a 81       	ldd	r24, Y+2	; 0x02
    304c:	9b 81       	ldd	r25, Y+3	; 0x03
    304e:	0e 94 28 1a 	call	0x3450	; 0x3450 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3052:	0e 94 84 26 	call	0x4d08	; 0x4d08 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3056:	8a 81       	ldd	r24, Y+2	; 0x02
    3058:	9b 81       	ldd	r25, Y+3	; 0x03
    305a:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <prvIsQueueEmpty>
    305e:	88 23       	and	r24, r24
    3060:	09 f4       	brne	.+2      	; 0x3064 <xQueuePeek+0x14e>
    3062:	6e cf       	rjmp	.-292    	; 0x2f40 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    3064:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    3066:	88 89       	ldd	r24, Y+16	; 0x10
}
    3068:	60 96       	adiw	r28, 0x10	; 16
    306a:	0f b6       	in	r0, 0x3f	; 63
    306c:	f8 94       	cli
    306e:	de bf       	out	0x3e, r29	; 62
    3070:	0f be       	out	0x3f, r0	; 63
    3072:	cd bf       	out	0x3d, r28	; 61
    3074:	cf 91       	pop	r28
    3076:	df 91       	pop	r29
    3078:	08 95       	ret

0000307a <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    307a:	df 93       	push	r29
    307c:	cf 93       	push	r28
    307e:	cd b7       	in	r28, 0x3d	; 61
    3080:	de b7       	in	r29, 0x3e	; 62
    3082:	2c 97       	sbiw	r28, 0x0c	; 12
    3084:	0f b6       	in	r0, 0x3f	; 63
    3086:	f8 94       	cli
    3088:	de bf       	out	0x3e, r29	; 62
    308a:	0f be       	out	0x3f, r0	; 63
    308c:	cd bf       	out	0x3d, r28	; 61
    308e:	98 87       	std	Y+8, r25	; 0x08
    3090:	8f 83       	std	Y+7, r24	; 0x07
    3092:	7a 87       	std	Y+10, r23	; 0x0a
    3094:	69 87       	std	Y+9, r22	; 0x09
    3096:	5c 87       	std	Y+12, r21	; 0x0c
    3098:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    309a:	8f 81       	ldd	r24, Y+7	; 0x07
    309c:	98 85       	ldd	r25, Y+8	; 0x08
    309e:	9c 83       	std	Y+4, r25	; 0x04
    30a0:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    30a2:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    30a4:	eb 81       	ldd	r30, Y+3	; 0x03
    30a6:	fc 81       	ldd	r31, Y+4	; 0x04
    30a8:	82 8d       	ldd	r24, Z+26	; 0x1a
    30aa:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    30ac:	8a 81       	ldd	r24, Y+2	; 0x02
    30ae:	88 23       	and	r24, r24
    30b0:	81 f1       	breq	.+96     	; 0x3112 <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    30b2:	eb 81       	ldd	r30, Y+3	; 0x03
    30b4:	fc 81       	ldd	r31, Y+4	; 0x04
    30b6:	85 8d       	ldd	r24, Z+29	; 0x1d
    30b8:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    30ba:	8b 81       	ldd	r24, Y+3	; 0x03
    30bc:	9c 81       	ldd	r25, Y+4	; 0x04
    30be:	29 85       	ldd	r18, Y+9	; 0x09
    30c0:	3a 85       	ldd	r19, Y+10	; 0x0a
    30c2:	b9 01       	movw	r22, r18
    30c4:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    30c8:	8a 81       	ldd	r24, Y+2	; 0x02
    30ca:	81 50       	subi	r24, 0x01	; 1
    30cc:	eb 81       	ldd	r30, Y+3	; 0x03
    30ce:	fc 81       	ldd	r31, Y+4	; 0x04
    30d0:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    30d2:	89 81       	ldd	r24, Y+1	; 0x01
    30d4:	8f 3f       	cpi	r24, 0xFF	; 255
    30d6:	a9 f4       	brne	.+42     	; 0x3102 <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    30d8:	eb 81       	ldd	r30, Y+3	; 0x03
    30da:	fc 81       	ldd	r31, Y+4	; 0x04
    30dc:	80 85       	ldd	r24, Z+8	; 0x08
    30de:	88 23       	and	r24, r24
    30e0:	a9 f0       	breq	.+42     	; 0x310c <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    30e2:	8b 81       	ldd	r24, Y+3	; 0x03
    30e4:	9c 81       	ldd	r25, Y+4	; 0x04
    30e6:	08 96       	adiw	r24, 0x08	; 8
    30e8:	0e 94 18 29 	call	0x5230	; 0x5230 <xTaskRemoveFromEventList>
    30ec:	88 23       	and	r24, r24
    30ee:	71 f0       	breq	.+28     	; 0x310c <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    30f0:	8b 85       	ldd	r24, Y+11	; 0x0b
    30f2:	9c 85       	ldd	r25, Y+12	; 0x0c
    30f4:	00 97       	sbiw	r24, 0x00	; 0
    30f6:	51 f0       	breq	.+20     	; 0x310c <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    30f8:	eb 85       	ldd	r30, Y+11	; 0x0b
    30fa:	fc 85       	ldd	r31, Y+12	; 0x0c
    30fc:	81 e0       	ldi	r24, 0x01	; 1
    30fe:	80 83       	st	Z, r24
    3100:	05 c0       	rjmp	.+10     	; 0x310c <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    3102:	89 81       	ldd	r24, Y+1	; 0x01
    3104:	8f 5f       	subi	r24, 0xFF	; 255
    3106:	eb 81       	ldd	r30, Y+3	; 0x03
    3108:	fc 81       	ldd	r31, Y+4	; 0x04
    310a:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    310c:	81 e0       	ldi	r24, 0x01	; 1
    310e:	8e 83       	std	Y+6, r24	; 0x06
    3110:	01 c0       	rjmp	.+2      	; 0x3114 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    3112:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3114:	8e 81       	ldd	r24, Y+6	; 0x06
}
    3116:	2c 96       	adiw	r28, 0x0c	; 12
    3118:	0f b6       	in	r0, 0x3f	; 63
    311a:	f8 94       	cli
    311c:	de bf       	out	0x3e, r29	; 62
    311e:	0f be       	out	0x3f, r0	; 63
    3120:	cd bf       	out	0x3d, r28	; 61
    3122:	cf 91       	pop	r28
    3124:	df 91       	pop	r29
    3126:	08 95       	ret

00003128 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    3128:	df 93       	push	r29
    312a:	cf 93       	push	r28
    312c:	cd b7       	in	r28, 0x3d	; 61
    312e:	de b7       	in	r29, 0x3e	; 62
    3130:	2a 97       	sbiw	r28, 0x0a	; 10
    3132:	0f b6       	in	r0, 0x3f	; 63
    3134:	f8 94       	cli
    3136:	de bf       	out	0x3e, r29	; 62
    3138:	0f be       	out	0x3f, r0	; 63
    313a:	cd bf       	out	0x3d, r28	; 61
    313c:	98 87       	std	Y+8, r25	; 0x08
    313e:	8f 83       	std	Y+7, r24	; 0x07
    3140:	7a 87       	std	Y+10, r23	; 0x0a
    3142:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    3144:	8f 81       	ldd	r24, Y+7	; 0x07
    3146:	98 85       	ldd	r25, Y+8	; 0x08
    3148:	9a 83       	std	Y+2, r25	; 0x02
    314a:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    314c:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    314e:	e9 81       	ldd	r30, Y+1	; 0x01
    3150:	fa 81       	ldd	r31, Y+2	; 0x02
    3152:	82 8d       	ldd	r24, Z+26	; 0x1a
    3154:	88 23       	and	r24, r24
    3156:	b1 f0       	breq	.+44     	; 0x3184 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3158:	e9 81       	ldd	r30, Y+1	; 0x01
    315a:	fa 81       	ldd	r31, Y+2	; 0x02
    315c:	86 81       	ldd	r24, Z+6	; 0x06
    315e:	97 81       	ldd	r25, Z+7	; 0x07
    3160:	9c 83       	std	Y+4, r25	; 0x04
    3162:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3164:	89 81       	ldd	r24, Y+1	; 0x01
    3166:	9a 81       	ldd	r25, Y+2	; 0x02
    3168:	29 85       	ldd	r18, Y+9	; 0x09
    316a:	3a 85       	ldd	r19, Y+10	; 0x0a
    316c:	b9 01       	movw	r22, r18
    316e:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    3172:	e9 81       	ldd	r30, Y+1	; 0x01
    3174:	fa 81       	ldd	r31, Y+2	; 0x02
    3176:	8b 81       	ldd	r24, Y+3	; 0x03
    3178:	9c 81       	ldd	r25, Y+4	; 0x04
    317a:	97 83       	std	Z+7, r25	; 0x07
    317c:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    317e:	81 e0       	ldi	r24, 0x01	; 1
    3180:	8e 83       	std	Y+6, r24	; 0x06
    3182:	01 c0       	rjmp	.+2      	; 0x3186 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    3184:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3186:	8e 81       	ldd	r24, Y+6	; 0x06
}
    3188:	2a 96       	adiw	r28, 0x0a	; 10
    318a:	0f b6       	in	r0, 0x3f	; 63
    318c:	f8 94       	cli
    318e:	de bf       	out	0x3e, r29	; 62
    3190:	0f be       	out	0x3f, r0	; 63
    3192:	cd bf       	out	0x3d, r28	; 61
    3194:	cf 91       	pop	r28
    3196:	df 91       	pop	r29
    3198:	08 95       	ret

0000319a <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    319a:	df 93       	push	r29
    319c:	cf 93       	push	r28
    319e:	00 d0       	rcall	.+0      	; 0x31a0 <uxQueueMessagesWaiting+0x6>
    31a0:	0f 92       	push	r0
    31a2:	cd b7       	in	r28, 0x3d	; 61
    31a4:	de b7       	in	r29, 0x3e	; 62
    31a6:	9b 83       	std	Y+3, r25	; 0x03
    31a8:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    31aa:	0f b6       	in	r0, 0x3f	; 63
    31ac:	f8 94       	cli
    31ae:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    31b0:	ea 81       	ldd	r30, Y+2	; 0x02
    31b2:	fb 81       	ldd	r31, Y+3	; 0x03
    31b4:	82 8d       	ldd	r24, Z+26	; 0x1a
    31b6:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    31b8:	0f 90       	pop	r0
    31ba:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    31bc:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    31be:	0f 90       	pop	r0
    31c0:	0f 90       	pop	r0
    31c2:	0f 90       	pop	r0
    31c4:	cf 91       	pop	r28
    31c6:	df 91       	pop	r29
    31c8:	08 95       	ret

000031ca <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    31ca:	df 93       	push	r29
    31cc:	cf 93       	push	r28
    31ce:	00 d0       	rcall	.+0      	; 0x31d0 <uxQueueSpacesAvailable+0x6>
    31d0:	00 d0       	rcall	.+0      	; 0x31d2 <uxQueueSpacesAvailable+0x8>
    31d2:	0f 92       	push	r0
    31d4:	cd b7       	in	r28, 0x3d	; 61
    31d6:	de b7       	in	r29, 0x3e	; 62
    31d8:	9d 83       	std	Y+5, r25	; 0x05
    31da:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    31dc:	8c 81       	ldd	r24, Y+4	; 0x04
    31de:	9d 81       	ldd	r25, Y+5	; 0x05
    31e0:	9a 83       	std	Y+2, r25	; 0x02
    31e2:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    31e4:	0f b6       	in	r0, 0x3f	; 63
    31e6:	f8 94       	cli
    31e8:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    31ea:	e9 81       	ldd	r30, Y+1	; 0x01
    31ec:	fa 81       	ldd	r31, Y+2	; 0x02
    31ee:	93 8d       	ldd	r25, Z+27	; 0x1b
    31f0:	e9 81       	ldd	r30, Y+1	; 0x01
    31f2:	fa 81       	ldd	r31, Y+2	; 0x02
    31f4:	82 8d       	ldd	r24, Z+26	; 0x1a
    31f6:	29 2f       	mov	r18, r25
    31f8:	28 1b       	sub	r18, r24
    31fa:	82 2f       	mov	r24, r18
    31fc:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    31fe:	0f 90       	pop	r0
    3200:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3202:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3204:	0f 90       	pop	r0
    3206:	0f 90       	pop	r0
    3208:	0f 90       	pop	r0
    320a:	0f 90       	pop	r0
    320c:	0f 90       	pop	r0
    320e:	cf 91       	pop	r28
    3210:	df 91       	pop	r29
    3212:	08 95       	ret

00003214 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    3214:	df 93       	push	r29
    3216:	cf 93       	push	r28
    3218:	00 d0       	rcall	.+0      	; 0x321a <uxQueueMessagesWaitingFromISR+0x6>
    321a:	00 d0       	rcall	.+0      	; 0x321c <uxQueueMessagesWaitingFromISR+0x8>
    321c:	0f 92       	push	r0
    321e:	cd b7       	in	r28, 0x3d	; 61
    3220:	de b7       	in	r29, 0x3e	; 62
    3222:	9d 83       	std	Y+5, r25	; 0x05
    3224:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    3226:	8c 81       	ldd	r24, Y+4	; 0x04
    3228:	9d 81       	ldd	r25, Y+5	; 0x05
    322a:	9a 83       	std	Y+2, r25	; 0x02
    322c:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    322e:	e9 81       	ldd	r30, Y+1	; 0x01
    3230:	fa 81       	ldd	r31, Y+2	; 0x02
    3232:	82 8d       	ldd	r24, Z+26	; 0x1a
    3234:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    3236:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3238:	0f 90       	pop	r0
    323a:	0f 90       	pop	r0
    323c:	0f 90       	pop	r0
    323e:	0f 90       	pop	r0
    3240:	0f 90       	pop	r0
    3242:	cf 91       	pop	r28
    3244:	df 91       	pop	r29
    3246:	08 95       	ret

00003248 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    3248:	df 93       	push	r29
    324a:	cf 93       	push	r28
    324c:	00 d0       	rcall	.+0      	; 0x324e <vQueueDelete+0x6>
    324e:	00 d0       	rcall	.+0      	; 0x3250 <vQueueDelete+0x8>
    3250:	cd b7       	in	r28, 0x3d	; 61
    3252:	de b7       	in	r29, 0x3e	; 62
    3254:	9c 83       	std	Y+4, r25	; 0x04
    3256:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    3258:	8b 81       	ldd	r24, Y+3	; 0x03
    325a:	9c 81       	ldd	r25, Y+4	; 0x04
    325c:	9a 83       	std	Y+2, r25	; 0x02
    325e:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    3260:	89 81       	ldd	r24, Y+1	; 0x01
    3262:	9a 81       	ldd	r25, Y+2	; 0x02
    3264:	0e 94 c7 0c 	call	0x198e	; 0x198e <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    3268:	0f 90       	pop	r0
    326a:	0f 90       	pop	r0
    326c:	0f 90       	pop	r0
    326e:	0f 90       	pop	r0
    3270:	cf 91       	pop	r28
    3272:	df 91       	pop	r29
    3274:	08 95       	ret

00003276 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    3276:	df 93       	push	r29
    3278:	cf 93       	push	r28
    327a:	cd b7       	in	r28, 0x3d	; 61
    327c:	de b7       	in	r29, 0x3e	; 62
    327e:	27 97       	sbiw	r28, 0x07	; 7
    3280:	0f b6       	in	r0, 0x3f	; 63
    3282:	f8 94       	cli
    3284:	de bf       	out	0x3e, r29	; 62
    3286:	0f be       	out	0x3f, r0	; 63
    3288:	cd bf       	out	0x3d, r28	; 61
    328a:	9c 83       	std	Y+4, r25	; 0x04
    328c:	8b 83       	std	Y+3, r24	; 0x03
    328e:	7e 83       	std	Y+6, r23	; 0x06
    3290:	6d 83       	std	Y+5, r22	; 0x05
    3292:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    3294:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3296:	eb 81       	ldd	r30, Y+3	; 0x03
    3298:	fc 81       	ldd	r31, Y+4	; 0x04
    329a:	82 8d       	ldd	r24, Z+26	; 0x1a
    329c:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    329e:	eb 81       	ldd	r30, Y+3	; 0x03
    32a0:	fc 81       	ldd	r31, Y+4	; 0x04
    32a2:	84 8d       	ldd	r24, Z+28	; 0x1c
    32a4:	88 23       	and	r24, r24
    32a6:	09 f4       	brne	.+2      	; 0x32aa <prvCopyDataToQueue+0x34>
    32a8:	7d c0       	rjmp	.+250    	; 0x33a4 <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    32aa:	8f 81       	ldd	r24, Y+7	; 0x07
    32ac:	88 23       	and	r24, r24
    32ae:	99 f5       	brne	.+102    	; 0x3316 <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    32b0:	eb 81       	ldd	r30, Y+3	; 0x03
    32b2:	fc 81       	ldd	r31, Y+4	; 0x04
    32b4:	62 81       	ldd	r22, Z+2	; 0x02
    32b6:	73 81       	ldd	r23, Z+3	; 0x03
    32b8:	eb 81       	ldd	r30, Y+3	; 0x03
    32ba:	fc 81       	ldd	r31, Y+4	; 0x04
    32bc:	84 8d       	ldd	r24, Z+28	; 0x1c
    32be:	48 2f       	mov	r20, r24
    32c0:	50 e0       	ldi	r21, 0x00	; 0
    32c2:	2d 81       	ldd	r18, Y+5	; 0x05
    32c4:	3e 81       	ldd	r19, Y+6	; 0x06
    32c6:	cb 01       	movw	r24, r22
    32c8:	b9 01       	movw	r22, r18
    32ca:	0e 94 a6 2f 	call	0x5f4c	; 0x5f4c <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    32ce:	eb 81       	ldd	r30, Y+3	; 0x03
    32d0:	fc 81       	ldd	r31, Y+4	; 0x04
    32d2:	22 81       	ldd	r18, Z+2	; 0x02
    32d4:	33 81       	ldd	r19, Z+3	; 0x03
    32d6:	eb 81       	ldd	r30, Y+3	; 0x03
    32d8:	fc 81       	ldd	r31, Y+4	; 0x04
    32da:	84 8d       	ldd	r24, Z+28	; 0x1c
    32dc:	88 2f       	mov	r24, r24
    32de:	90 e0       	ldi	r25, 0x00	; 0
    32e0:	82 0f       	add	r24, r18
    32e2:	93 1f       	adc	r25, r19
    32e4:	eb 81       	ldd	r30, Y+3	; 0x03
    32e6:	fc 81       	ldd	r31, Y+4	; 0x04
    32e8:	93 83       	std	Z+3, r25	; 0x03
    32ea:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    32ec:	eb 81       	ldd	r30, Y+3	; 0x03
    32ee:	fc 81       	ldd	r31, Y+4	; 0x04
    32f0:	22 81       	ldd	r18, Z+2	; 0x02
    32f2:	33 81       	ldd	r19, Z+3	; 0x03
    32f4:	eb 81       	ldd	r30, Y+3	; 0x03
    32f6:	fc 81       	ldd	r31, Y+4	; 0x04
    32f8:	84 81       	ldd	r24, Z+4	; 0x04
    32fa:	95 81       	ldd	r25, Z+5	; 0x05
    32fc:	28 17       	cp	r18, r24
    32fe:	39 07       	cpc	r19, r25
    3300:	08 f4       	brcc	.+2      	; 0x3304 <prvCopyDataToQueue+0x8e>
    3302:	50 c0       	rjmp	.+160    	; 0x33a4 <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3304:	eb 81       	ldd	r30, Y+3	; 0x03
    3306:	fc 81       	ldd	r31, Y+4	; 0x04
    3308:	80 81       	ld	r24, Z
    330a:	91 81       	ldd	r25, Z+1	; 0x01
    330c:	eb 81       	ldd	r30, Y+3	; 0x03
    330e:	fc 81       	ldd	r31, Y+4	; 0x04
    3310:	93 83       	std	Z+3, r25	; 0x03
    3312:	82 83       	std	Z+2, r24	; 0x02
    3314:	47 c0       	rjmp	.+142    	; 0x33a4 <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    3316:	eb 81       	ldd	r30, Y+3	; 0x03
    3318:	fc 81       	ldd	r31, Y+4	; 0x04
    331a:	66 81       	ldd	r22, Z+6	; 0x06
    331c:	77 81       	ldd	r23, Z+7	; 0x07
    331e:	eb 81       	ldd	r30, Y+3	; 0x03
    3320:	fc 81       	ldd	r31, Y+4	; 0x04
    3322:	84 8d       	ldd	r24, Z+28	; 0x1c
    3324:	48 2f       	mov	r20, r24
    3326:	50 e0       	ldi	r21, 0x00	; 0
    3328:	2d 81       	ldd	r18, Y+5	; 0x05
    332a:	3e 81       	ldd	r19, Y+6	; 0x06
    332c:	cb 01       	movw	r24, r22
    332e:	b9 01       	movw	r22, r18
    3330:	0e 94 a6 2f 	call	0x5f4c	; 0x5f4c <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    3334:	eb 81       	ldd	r30, Y+3	; 0x03
    3336:	fc 81       	ldd	r31, Y+4	; 0x04
    3338:	26 81       	ldd	r18, Z+6	; 0x06
    333a:	37 81       	ldd	r19, Z+7	; 0x07
    333c:	eb 81       	ldd	r30, Y+3	; 0x03
    333e:	fc 81       	ldd	r31, Y+4	; 0x04
    3340:	84 8d       	ldd	r24, Z+28	; 0x1c
    3342:	88 2f       	mov	r24, r24
    3344:	90 e0       	ldi	r25, 0x00	; 0
    3346:	90 95       	com	r25
    3348:	81 95       	neg	r24
    334a:	9f 4f       	sbci	r25, 0xFF	; 255
    334c:	82 0f       	add	r24, r18
    334e:	93 1f       	adc	r25, r19
    3350:	eb 81       	ldd	r30, Y+3	; 0x03
    3352:	fc 81       	ldd	r31, Y+4	; 0x04
    3354:	97 83       	std	Z+7, r25	; 0x07
    3356:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3358:	eb 81       	ldd	r30, Y+3	; 0x03
    335a:	fc 81       	ldd	r31, Y+4	; 0x04
    335c:	26 81       	ldd	r18, Z+6	; 0x06
    335e:	37 81       	ldd	r19, Z+7	; 0x07
    3360:	eb 81       	ldd	r30, Y+3	; 0x03
    3362:	fc 81       	ldd	r31, Y+4	; 0x04
    3364:	80 81       	ld	r24, Z
    3366:	91 81       	ldd	r25, Z+1	; 0x01
    3368:	28 17       	cp	r18, r24
    336a:	39 07       	cpc	r19, r25
    336c:	90 f4       	brcc	.+36     	; 0x3392 <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    336e:	eb 81       	ldd	r30, Y+3	; 0x03
    3370:	fc 81       	ldd	r31, Y+4	; 0x04
    3372:	24 81       	ldd	r18, Z+4	; 0x04
    3374:	35 81       	ldd	r19, Z+5	; 0x05
    3376:	eb 81       	ldd	r30, Y+3	; 0x03
    3378:	fc 81       	ldd	r31, Y+4	; 0x04
    337a:	84 8d       	ldd	r24, Z+28	; 0x1c
    337c:	88 2f       	mov	r24, r24
    337e:	90 e0       	ldi	r25, 0x00	; 0
    3380:	90 95       	com	r25
    3382:	81 95       	neg	r24
    3384:	9f 4f       	sbci	r25, 0xFF	; 255
    3386:	82 0f       	add	r24, r18
    3388:	93 1f       	adc	r25, r19
    338a:	eb 81       	ldd	r30, Y+3	; 0x03
    338c:	fc 81       	ldd	r31, Y+4	; 0x04
    338e:	97 83       	std	Z+7, r25	; 0x07
    3390:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    3392:	8f 81       	ldd	r24, Y+7	; 0x07
    3394:	82 30       	cpi	r24, 0x02	; 2
    3396:	31 f4       	brne	.+12     	; 0x33a4 <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3398:	89 81       	ldd	r24, Y+1	; 0x01
    339a:	88 23       	and	r24, r24
    339c:	19 f0       	breq	.+6      	; 0x33a4 <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    339e:	89 81       	ldd	r24, Y+1	; 0x01
    33a0:	81 50       	subi	r24, 0x01	; 1
    33a2:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    33a4:	89 81       	ldd	r24, Y+1	; 0x01
    33a6:	8f 5f       	subi	r24, 0xFF	; 255
    33a8:	eb 81       	ldd	r30, Y+3	; 0x03
    33aa:	fc 81       	ldd	r31, Y+4	; 0x04
    33ac:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    33ae:	8a 81       	ldd	r24, Y+2	; 0x02
}
    33b0:	27 96       	adiw	r28, 0x07	; 7
    33b2:	0f b6       	in	r0, 0x3f	; 63
    33b4:	f8 94       	cli
    33b6:	de bf       	out	0x3e, r29	; 62
    33b8:	0f be       	out	0x3f, r0	; 63
    33ba:	cd bf       	out	0x3d, r28	; 61
    33bc:	cf 91       	pop	r28
    33be:	df 91       	pop	r29
    33c0:	08 95       	ret

000033c2 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    33c2:	df 93       	push	r29
    33c4:	cf 93       	push	r28
    33c6:	00 d0       	rcall	.+0      	; 0x33c8 <prvCopyDataFromQueue+0x6>
    33c8:	00 d0       	rcall	.+0      	; 0x33ca <prvCopyDataFromQueue+0x8>
    33ca:	cd b7       	in	r28, 0x3d	; 61
    33cc:	de b7       	in	r29, 0x3e	; 62
    33ce:	9a 83       	std	Y+2, r25	; 0x02
    33d0:	89 83       	std	Y+1, r24	; 0x01
    33d2:	7c 83       	std	Y+4, r23	; 0x04
    33d4:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    33d6:	e9 81       	ldd	r30, Y+1	; 0x01
    33d8:	fa 81       	ldd	r31, Y+2	; 0x02
    33da:	84 8d       	ldd	r24, Z+28	; 0x1c
    33dc:	88 23       	and	r24, r24
    33de:	89 f1       	breq	.+98     	; 0x3442 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    33e0:	e9 81       	ldd	r30, Y+1	; 0x01
    33e2:	fa 81       	ldd	r31, Y+2	; 0x02
    33e4:	26 81       	ldd	r18, Z+6	; 0x06
    33e6:	37 81       	ldd	r19, Z+7	; 0x07
    33e8:	e9 81       	ldd	r30, Y+1	; 0x01
    33ea:	fa 81       	ldd	r31, Y+2	; 0x02
    33ec:	84 8d       	ldd	r24, Z+28	; 0x1c
    33ee:	88 2f       	mov	r24, r24
    33f0:	90 e0       	ldi	r25, 0x00	; 0
    33f2:	82 0f       	add	r24, r18
    33f4:	93 1f       	adc	r25, r19
    33f6:	e9 81       	ldd	r30, Y+1	; 0x01
    33f8:	fa 81       	ldd	r31, Y+2	; 0x02
    33fa:	97 83       	std	Z+7, r25	; 0x07
    33fc:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    33fe:	e9 81       	ldd	r30, Y+1	; 0x01
    3400:	fa 81       	ldd	r31, Y+2	; 0x02
    3402:	26 81       	ldd	r18, Z+6	; 0x06
    3404:	37 81       	ldd	r19, Z+7	; 0x07
    3406:	e9 81       	ldd	r30, Y+1	; 0x01
    3408:	fa 81       	ldd	r31, Y+2	; 0x02
    340a:	84 81       	ldd	r24, Z+4	; 0x04
    340c:	95 81       	ldd	r25, Z+5	; 0x05
    340e:	28 17       	cp	r18, r24
    3410:	39 07       	cpc	r19, r25
    3412:	40 f0       	brcs	.+16     	; 0x3424 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    3414:	e9 81       	ldd	r30, Y+1	; 0x01
    3416:	fa 81       	ldd	r31, Y+2	; 0x02
    3418:	80 81       	ld	r24, Z
    341a:	91 81       	ldd	r25, Z+1	; 0x01
    341c:	e9 81       	ldd	r30, Y+1	; 0x01
    341e:	fa 81       	ldd	r31, Y+2	; 0x02
    3420:	97 83       	std	Z+7, r25	; 0x07
    3422:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3424:	e9 81       	ldd	r30, Y+1	; 0x01
    3426:	fa 81       	ldd	r31, Y+2	; 0x02
    3428:	46 81       	ldd	r20, Z+6	; 0x06
    342a:	57 81       	ldd	r21, Z+7	; 0x07
    342c:	e9 81       	ldd	r30, Y+1	; 0x01
    342e:	fa 81       	ldd	r31, Y+2	; 0x02
    3430:	84 8d       	ldd	r24, Z+28	; 0x1c
    3432:	28 2f       	mov	r18, r24
    3434:	30 e0       	ldi	r19, 0x00	; 0
    3436:	8b 81       	ldd	r24, Y+3	; 0x03
    3438:	9c 81       	ldd	r25, Y+4	; 0x04
    343a:	ba 01       	movw	r22, r20
    343c:	a9 01       	movw	r20, r18
    343e:	0e 94 a6 2f 	call	0x5f4c	; 0x5f4c <memcpy>
	}
}
    3442:	0f 90       	pop	r0
    3444:	0f 90       	pop	r0
    3446:	0f 90       	pop	r0
    3448:	0f 90       	pop	r0
    344a:	cf 91       	pop	r28
    344c:	df 91       	pop	r29
    344e:	08 95       	ret

00003450 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    3450:	df 93       	push	r29
    3452:	cf 93       	push	r28
    3454:	00 d0       	rcall	.+0      	; 0x3456 <prvUnlockQueue+0x6>
    3456:	00 d0       	rcall	.+0      	; 0x3458 <prvUnlockQueue+0x8>
    3458:	cd b7       	in	r28, 0x3d	; 61
    345a:	de b7       	in	r29, 0x3e	; 62
    345c:	9c 83       	std	Y+4, r25	; 0x04
    345e:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3460:	0f b6       	in	r0, 0x3f	; 63
    3462:	f8 94       	cli
    3464:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    3466:	eb 81       	ldd	r30, Y+3	; 0x03
    3468:	fc 81       	ldd	r31, Y+4	; 0x04
    346a:	86 8d       	ldd	r24, Z+30	; 0x1e
    346c:	8a 83       	std	Y+2, r24	; 0x02
    346e:	11 c0       	rjmp	.+34     	; 0x3492 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3470:	eb 81       	ldd	r30, Y+3	; 0x03
    3472:	fc 81       	ldd	r31, Y+4	; 0x04
    3474:	81 89       	ldd	r24, Z+17	; 0x11
    3476:	88 23       	and	r24, r24
    3478:	79 f0       	breq	.+30     	; 0x3498 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    347a:	8b 81       	ldd	r24, Y+3	; 0x03
    347c:	9c 81       	ldd	r25, Y+4	; 0x04
    347e:	41 96       	adiw	r24, 0x11	; 17
    3480:	0e 94 18 29 	call	0x5230	; 0x5230 <xTaskRemoveFromEventList>
    3484:	88 23       	and	r24, r24
    3486:	11 f0       	breq	.+4      	; 0x348c <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    3488:	0e 94 84 2a 	call	0x5508	; 0x5508 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    348c:	8a 81       	ldd	r24, Y+2	; 0x02
    348e:	81 50       	subi	r24, 0x01	; 1
    3490:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    3492:	8a 81       	ldd	r24, Y+2	; 0x02
    3494:	18 16       	cp	r1, r24
    3496:	64 f3       	brlt	.-40     	; 0x3470 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    3498:	eb 81       	ldd	r30, Y+3	; 0x03
    349a:	fc 81       	ldd	r31, Y+4	; 0x04
    349c:	8f ef       	ldi	r24, 0xFF	; 255
    349e:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    34a0:	0f 90       	pop	r0
    34a2:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    34a4:	0f b6       	in	r0, 0x3f	; 63
    34a6:	f8 94       	cli
    34a8:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    34aa:	eb 81       	ldd	r30, Y+3	; 0x03
    34ac:	fc 81       	ldd	r31, Y+4	; 0x04
    34ae:	85 8d       	ldd	r24, Z+29	; 0x1d
    34b0:	89 83       	std	Y+1, r24	; 0x01
    34b2:	11 c0       	rjmp	.+34     	; 0x34d6 <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    34b4:	eb 81       	ldd	r30, Y+3	; 0x03
    34b6:	fc 81       	ldd	r31, Y+4	; 0x04
    34b8:	80 85       	ldd	r24, Z+8	; 0x08
    34ba:	88 23       	and	r24, r24
    34bc:	79 f0       	breq	.+30     	; 0x34dc <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    34be:	8b 81       	ldd	r24, Y+3	; 0x03
    34c0:	9c 81       	ldd	r25, Y+4	; 0x04
    34c2:	08 96       	adiw	r24, 0x08	; 8
    34c4:	0e 94 18 29 	call	0x5230	; 0x5230 <xTaskRemoveFromEventList>
    34c8:	88 23       	and	r24, r24
    34ca:	11 f0       	breq	.+4      	; 0x34d0 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    34cc:	0e 94 84 2a 	call	0x5508	; 0x5508 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    34d0:	89 81       	ldd	r24, Y+1	; 0x01
    34d2:	81 50       	subi	r24, 0x01	; 1
    34d4:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    34d6:	89 81       	ldd	r24, Y+1	; 0x01
    34d8:	18 16       	cp	r1, r24
    34da:	64 f3       	brlt	.-40     	; 0x34b4 <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    34dc:	eb 81       	ldd	r30, Y+3	; 0x03
    34de:	fc 81       	ldd	r31, Y+4	; 0x04
    34e0:	8f ef       	ldi	r24, 0xFF	; 255
    34e2:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    34e4:	0f 90       	pop	r0
    34e6:	0f be       	out	0x3f, r0	; 63
}
    34e8:	0f 90       	pop	r0
    34ea:	0f 90       	pop	r0
    34ec:	0f 90       	pop	r0
    34ee:	0f 90       	pop	r0
    34f0:	cf 91       	pop	r28
    34f2:	df 91       	pop	r29
    34f4:	08 95       	ret

000034f6 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    34f6:	df 93       	push	r29
    34f8:	cf 93       	push	r28
    34fa:	00 d0       	rcall	.+0      	; 0x34fc <prvIsQueueEmpty+0x6>
    34fc:	0f 92       	push	r0
    34fe:	cd b7       	in	r28, 0x3d	; 61
    3500:	de b7       	in	r29, 0x3e	; 62
    3502:	9b 83       	std	Y+3, r25	; 0x03
    3504:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3506:	0f b6       	in	r0, 0x3f	; 63
    3508:	f8 94       	cli
    350a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    350c:	ea 81       	ldd	r30, Y+2	; 0x02
    350e:	fb 81       	ldd	r31, Y+3	; 0x03
    3510:	82 8d       	ldd	r24, Z+26	; 0x1a
    3512:	88 23       	and	r24, r24
    3514:	19 f4       	brne	.+6      	; 0x351c <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    3516:	81 e0       	ldi	r24, 0x01	; 1
    3518:	89 83       	std	Y+1, r24	; 0x01
    351a:	01 c0       	rjmp	.+2      	; 0x351e <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    351c:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    351e:	0f 90       	pop	r0
    3520:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3522:	89 81       	ldd	r24, Y+1	; 0x01
}
    3524:	0f 90       	pop	r0
    3526:	0f 90       	pop	r0
    3528:	0f 90       	pop	r0
    352a:	cf 91       	pop	r28
    352c:	df 91       	pop	r29
    352e:	08 95       	ret

00003530 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    3530:	df 93       	push	r29
    3532:	cf 93       	push	r28
    3534:	00 d0       	rcall	.+0      	; 0x3536 <xQueueIsQueueEmptyFromISR+0x6>
    3536:	00 d0       	rcall	.+0      	; 0x3538 <xQueueIsQueueEmptyFromISR+0x8>
    3538:	0f 92       	push	r0
    353a:	cd b7       	in	r28, 0x3d	; 61
    353c:	de b7       	in	r29, 0x3e	; 62
    353e:	9d 83       	std	Y+5, r25	; 0x05
    3540:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    3542:	8c 81       	ldd	r24, Y+4	; 0x04
    3544:	9d 81       	ldd	r25, Y+5	; 0x05
    3546:	9a 83       	std	Y+2, r25	; 0x02
    3548:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    354a:	e9 81       	ldd	r30, Y+1	; 0x01
    354c:	fa 81       	ldd	r31, Y+2	; 0x02
    354e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3550:	88 23       	and	r24, r24
    3552:	19 f4       	brne	.+6      	; 0x355a <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    3554:	81 e0       	ldi	r24, 0x01	; 1
    3556:	8b 83       	std	Y+3, r24	; 0x03
    3558:	01 c0       	rjmp	.+2      	; 0x355c <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    355a:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    355c:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    355e:	0f 90       	pop	r0
    3560:	0f 90       	pop	r0
    3562:	0f 90       	pop	r0
    3564:	0f 90       	pop	r0
    3566:	0f 90       	pop	r0
    3568:	cf 91       	pop	r28
    356a:	df 91       	pop	r29
    356c:	08 95       	ret

0000356e <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    356e:	df 93       	push	r29
    3570:	cf 93       	push	r28
    3572:	00 d0       	rcall	.+0      	; 0x3574 <prvIsQueueFull+0x6>
    3574:	0f 92       	push	r0
    3576:	cd b7       	in	r28, 0x3d	; 61
    3578:	de b7       	in	r29, 0x3e	; 62
    357a:	9b 83       	std	Y+3, r25	; 0x03
    357c:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    357e:	0f b6       	in	r0, 0x3f	; 63
    3580:	f8 94       	cli
    3582:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3584:	ea 81       	ldd	r30, Y+2	; 0x02
    3586:	fb 81       	ldd	r31, Y+3	; 0x03
    3588:	92 8d       	ldd	r25, Z+26	; 0x1a
    358a:	ea 81       	ldd	r30, Y+2	; 0x02
    358c:	fb 81       	ldd	r31, Y+3	; 0x03
    358e:	83 8d       	ldd	r24, Z+27	; 0x1b
    3590:	98 17       	cp	r25, r24
    3592:	19 f4       	brne	.+6      	; 0x359a <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    3594:	81 e0       	ldi	r24, 0x01	; 1
    3596:	89 83       	std	Y+1, r24	; 0x01
    3598:	01 c0       	rjmp	.+2      	; 0x359c <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    359a:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    359c:	0f 90       	pop	r0
    359e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    35a0:	89 81       	ldd	r24, Y+1	; 0x01
}
    35a2:	0f 90       	pop	r0
    35a4:	0f 90       	pop	r0
    35a6:	0f 90       	pop	r0
    35a8:	cf 91       	pop	r28
    35aa:	df 91       	pop	r29
    35ac:	08 95       	ret

000035ae <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    35ae:	df 93       	push	r29
    35b0:	cf 93       	push	r28
    35b2:	00 d0       	rcall	.+0      	; 0x35b4 <xQueueIsQueueFullFromISR+0x6>
    35b4:	00 d0       	rcall	.+0      	; 0x35b6 <xQueueIsQueueFullFromISR+0x8>
    35b6:	0f 92       	push	r0
    35b8:	cd b7       	in	r28, 0x3d	; 61
    35ba:	de b7       	in	r29, 0x3e	; 62
    35bc:	9d 83       	std	Y+5, r25	; 0x05
    35be:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    35c0:	8c 81       	ldd	r24, Y+4	; 0x04
    35c2:	9d 81       	ldd	r25, Y+5	; 0x05
    35c4:	9a 83       	std	Y+2, r25	; 0x02
    35c6:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    35c8:	e9 81       	ldd	r30, Y+1	; 0x01
    35ca:	fa 81       	ldd	r31, Y+2	; 0x02
    35cc:	92 8d       	ldd	r25, Z+26	; 0x1a
    35ce:	e9 81       	ldd	r30, Y+1	; 0x01
    35d0:	fa 81       	ldd	r31, Y+2	; 0x02
    35d2:	83 8d       	ldd	r24, Z+27	; 0x1b
    35d4:	98 17       	cp	r25, r24
    35d6:	19 f4       	brne	.+6      	; 0x35de <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    35d8:	81 e0       	ldi	r24, 0x01	; 1
    35da:	8b 83       	std	Y+3, r24	; 0x03
    35dc:	01 c0       	rjmp	.+2      	; 0x35e0 <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    35de:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    35e0:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    35e2:	0f 90       	pop	r0
    35e4:	0f 90       	pop	r0
    35e6:	0f 90       	pop	r0
    35e8:	0f 90       	pop	r0
    35ea:	0f 90       	pop	r0
    35ec:	cf 91       	pop	r28
    35ee:	df 91       	pop	r29
    35f0:	08 95       	ret

000035f2 <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
    35f2:	0f 93       	push	r16
    35f4:	df 93       	push	r29
    35f6:	cf 93       	push	r28
    35f8:	cd b7       	in	r28, 0x3d	; 61
    35fa:	de b7       	in	r29, 0x3e	; 62
    35fc:	28 97       	sbiw	r28, 0x08	; 8
    35fe:	0f b6       	in	r0, 0x3f	; 63
    3600:	f8 94       	cli
    3602:	de bf       	out	0x3e, r29	; 62
    3604:	0f be       	out	0x3f, r0	; 63
    3606:	cd bf       	out	0x3d, r28	; 61
    3608:	9d 83       	std	Y+5, r25	; 0x05
    360a:	8c 83       	std	Y+4, r24	; 0x04
    360c:	7f 83       	std	Y+7, r23	; 0x07
    360e:	6e 83       	std	Y+6, r22	; 0x06
    3610:	48 87       	std	Y+8, r20	; 0x08

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
    3612:	88 85       	ldd	r24, Y+8	; 0x08
    3614:	81 30       	cpi	r24, 0x01	; 1
    3616:	19 f4       	brne	.+6      	; 0x361e <xStreamBufferGenericCreate+0x2c>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    3618:	81 e0       	ldi	r24, 0x01	; 1
    361a:	89 83       	std	Y+1, r24	; 0x01
    361c:	01 c0       	rjmp	.+2      	; 0x3620 <xStreamBufferGenericCreate+0x2e>
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
    361e:	19 82       	std	Y+1, r1	; 0x01
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
    3620:	8e 81       	ldd	r24, Y+6	; 0x06
    3622:	9f 81       	ldd	r25, Y+7	; 0x07
    3624:	00 97       	sbiw	r24, 0x00	; 0
    3626:	21 f4       	brne	.+8      	; 0x3630 <xStreamBufferGenericCreate+0x3e>
		{
			xTriggerLevelBytes = ( size_t ) 1;
    3628:	81 e0       	ldi	r24, 0x01	; 1
    362a:	90 e0       	ldi	r25, 0x00	; 0
    362c:	9f 83       	std	Y+7, r25	; 0x07
    362e:	8e 83       	std	Y+6, r24	; 0x06
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
    3630:	8c 81       	ldd	r24, Y+4	; 0x04
    3632:	9d 81       	ldd	r25, Y+5	; 0x05
    3634:	01 96       	adiw	r24, 0x01	; 1
    3636:	9d 83       	std	Y+5, r25	; 0x05
    3638:	8c 83       	std	Y+4, r24	; 0x04
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    363a:	8c 81       	ldd	r24, Y+4	; 0x04
    363c:	9d 81       	ldd	r25, Y+5	; 0x05
    363e:	0f 96       	adiw	r24, 0x0f	; 15
    3640:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <pvPortMalloc>
    3644:	9b 83       	std	Y+3, r25	; 0x03
    3646:	8a 83       	std	Y+2, r24	; 0x02

		if( pucAllocatedMemory != NULL )
    3648:	8a 81       	ldd	r24, Y+2	; 0x02
    364a:	9b 81       	ldd	r25, Y+3	; 0x03
    364c:	00 97       	sbiw	r24, 0x00	; 0
    364e:	89 f0       	breq	.+34     	; 0x3672 <xStreamBufferGenericCreate+0x80>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    3650:	6a 81       	ldd	r22, Y+2	; 0x02
    3652:	7b 81       	ldd	r23, Y+3	; 0x03
    3654:	8a 81       	ldd	r24, Y+2	; 0x02
    3656:	9b 81       	ldd	r25, Y+3	; 0x03
    3658:	9c 01       	movw	r18, r24
    365a:	21 5f       	subi	r18, 0xF1	; 241
    365c:	3f 4f       	sbci	r19, 0xFF	; 255
    365e:	4c 81       	ldd	r20, Y+4	; 0x04
    3660:	5d 81       	ldd	r21, Y+5	; 0x05
    3662:	ee 81       	ldd	r30, Y+6	; 0x06
    3664:	ff 81       	ldd	r31, Y+7	; 0x07
    3666:	cb 01       	movw	r24, r22
    3668:	b9 01       	movw	r22, r18
    366a:	9f 01       	movw	r18, r30
    366c:	09 81       	ldd	r16, Y+1	; 0x01
    366e:	0e 94 51 22 	call	0x44a2	; 0x44a2 <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    3672:	8a 81       	ldd	r24, Y+2	; 0x02
    3674:	9b 81       	ldd	r25, Y+3	; 0x03
	}
    3676:	28 96       	adiw	r28, 0x08	; 8
    3678:	0f b6       	in	r0, 0x3f	; 63
    367a:	f8 94       	cli
    367c:	de bf       	out	0x3e, r29	; 62
    367e:	0f be       	out	0x3f, r0	; 63
    3680:	cd bf       	out	0x3d, r28	; 61
    3682:	cf 91       	pop	r28
    3684:	df 91       	pop	r29
    3686:	0f 91       	pop	r16
    3688:	08 95       	ret

0000368a <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    368a:	df 93       	push	r29
    368c:	cf 93       	push	r28
    368e:	00 d0       	rcall	.+0      	; 0x3690 <vStreamBufferDelete+0x6>
    3690:	00 d0       	rcall	.+0      	; 0x3692 <vStreamBufferDelete+0x8>
    3692:	cd b7       	in	r28, 0x3d	; 61
    3694:	de b7       	in	r29, 0x3e	; 62
    3696:	9c 83       	std	Y+4, r25	; 0x04
    3698:	8b 83       	std	Y+3, r24	; 0x03
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    369a:	8b 81       	ldd	r24, Y+3	; 0x03
    369c:	9c 81       	ldd	r25, Y+4	; 0x04
    369e:	9a 83       	std	Y+2, r25	; 0x02
    36a0:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    36a2:	e9 81       	ldd	r30, Y+1	; 0x01
    36a4:	fa 81       	ldd	r31, Y+2	; 0x02
    36a6:	86 85       	ldd	r24, Z+14	; 0x0e
    36a8:	88 2f       	mov	r24, r24
    36aa:	90 e0       	ldi	r25, 0x00	; 0
    36ac:	82 70       	andi	r24, 0x02	; 2
    36ae:	90 70       	andi	r25, 0x00	; 0
    36b0:	00 97       	sbiw	r24, 0x00	; 0
    36b2:	29 f4       	brne	.+10     	; 0x36be <vStreamBufferDelete+0x34>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    36b4:	89 81       	ldd	r24, Y+1	; 0x01
    36b6:	9a 81       	ldd	r25, Y+2	; 0x02
    36b8:	0e 94 c7 0c 	call	0x198e	; 0x198e <vPortFree>
    36bc:	08 c0       	rjmp	.+16     	; 0x36ce <vStreamBufferDelete+0x44>
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    36be:	89 81       	ldd	r24, Y+1	; 0x01
    36c0:	9a 81       	ldd	r25, Y+2	; 0x02
    36c2:	60 e0       	ldi	r22, 0x00	; 0
    36c4:	70 e0       	ldi	r23, 0x00	; 0
    36c6:	4f e0       	ldi	r20, 0x0F	; 15
    36c8:	50 e0       	ldi	r21, 0x00	; 0
    36ca:	0e 94 af 2f 	call	0x5f5e	; 0x5f5e <memset>
	}
}
    36ce:	0f 90       	pop	r0
    36d0:	0f 90       	pop	r0
    36d2:	0f 90       	pop	r0
    36d4:	0f 90       	pop	r0
    36d6:	cf 91       	pop	r28
    36d8:	df 91       	pop	r29
    36da:	08 95       	ret

000036dc <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    36dc:	0f 93       	push	r16
    36de:	df 93       	push	r29
    36e0:	cf 93       	push	r28
    36e2:	00 d0       	rcall	.+0      	; 0x36e4 <xStreamBufferReset+0x8>
    36e4:	00 d0       	rcall	.+0      	; 0x36e6 <xStreamBufferReset+0xa>
    36e6:	0f 92       	push	r0
    36e8:	cd b7       	in	r28, 0x3d	; 61
    36ea:	de b7       	in	r29, 0x3e	; 62
    36ec:	9d 83       	std	Y+5, r25	; 0x05
    36ee:	8c 83       	std	Y+4, r24	; 0x04
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    36f0:	8c 81       	ldd	r24, Y+4	; 0x04
    36f2:	9d 81       	ldd	r25, Y+5	; 0x05
    36f4:	9b 83       	std	Y+3, r25	; 0x03
    36f6:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn = pdFAIL;
    36f8:	19 82       	std	Y+1, r1	; 0x01
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
    36fa:	0f b6       	in	r0, 0x3f	; 63
    36fc:	f8 94       	cli
    36fe:	0f 92       	push	r0
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    3700:	ea 81       	ldd	r30, Y+2	; 0x02
    3702:	fb 81       	ldd	r31, Y+3	; 0x03
    3704:	80 85       	ldd	r24, Z+8	; 0x08
    3706:	91 85       	ldd	r25, Z+9	; 0x09
    3708:	00 97       	sbiw	r24, 0x00	; 0
    370a:	f1 f4       	brne	.+60     	; 0x3748 <xStreamBufferReset+0x6c>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    370c:	ea 81       	ldd	r30, Y+2	; 0x02
    370e:	fb 81       	ldd	r31, Y+3	; 0x03
    3710:	82 85       	ldd	r24, Z+10	; 0x0a
    3712:	93 85       	ldd	r25, Z+11	; 0x0b
    3714:	00 97       	sbiw	r24, 0x00	; 0
    3716:	c1 f4       	brne	.+48     	; 0x3748 <xStreamBufferReset+0x6c>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
    3718:	ea 81       	ldd	r30, Y+2	; 0x02
    371a:	fb 81       	ldd	r31, Y+3	; 0x03
    371c:	24 85       	ldd	r18, Z+12	; 0x0c
    371e:	35 85       	ldd	r19, Z+13	; 0x0d
    3720:	ea 81       	ldd	r30, Y+2	; 0x02
    3722:	fb 81       	ldd	r31, Y+3	; 0x03
    3724:	44 81       	ldd	r20, Z+4	; 0x04
    3726:	55 81       	ldd	r21, Z+5	; 0x05
    3728:	ea 81       	ldd	r30, Y+2	; 0x02
    372a:	fb 81       	ldd	r31, Y+3	; 0x03
    372c:	a6 81       	ldd	r26, Z+6	; 0x06
    372e:	b7 81       	ldd	r27, Z+7	; 0x07
    3730:	ea 81       	ldd	r30, Y+2	; 0x02
    3732:	fb 81       	ldd	r31, Y+3	; 0x03
    3734:	e6 85       	ldd	r30, Z+14	; 0x0e
    3736:	8a 81       	ldd	r24, Y+2	; 0x02
    3738:	9b 81       	ldd	r25, Y+3	; 0x03
    373a:	b9 01       	movw	r22, r18
    373c:	9d 01       	movw	r18, r26
    373e:	0e 2f       	mov	r16, r30
    3740:	0e 94 51 22 	call	0x44a2	; 0x44a2 <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
    3744:	81 e0       	ldi	r24, 0x01	; 1
    3746:	89 83       	std	Y+1, r24	; 0x01

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
    3748:	0f 90       	pop	r0
    374a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    374c:	89 81       	ldd	r24, Y+1	; 0x01
}
    374e:	0f 90       	pop	r0
    3750:	0f 90       	pop	r0
    3752:	0f 90       	pop	r0
    3754:	0f 90       	pop	r0
    3756:	0f 90       	pop	r0
    3758:	cf 91       	pop	r28
    375a:	df 91       	pop	r29
    375c:	0f 91       	pop	r16
    375e:	08 95       	ret

00003760 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
    3760:	df 93       	push	r29
    3762:	cf 93       	push	r28
    3764:	cd b7       	in	r28, 0x3d	; 61
    3766:	de b7       	in	r29, 0x3e	; 62
    3768:	27 97       	sbiw	r28, 0x07	; 7
    376a:	0f b6       	in	r0, 0x3f	; 63
    376c:	f8 94       	cli
    376e:	de bf       	out	0x3e, r29	; 62
    3770:	0f be       	out	0x3f, r0	; 63
    3772:	cd bf       	out	0x3d, r28	; 61
    3774:	9d 83       	std	Y+5, r25	; 0x05
    3776:	8c 83       	std	Y+4, r24	; 0x04
    3778:	7f 83       	std	Y+7, r23	; 0x07
    377a:	6e 83       	std	Y+6, r22	; 0x06
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    377c:	8c 81       	ldd	r24, Y+4	; 0x04
    377e:	9d 81       	ldd	r25, Y+5	; 0x05
    3780:	9b 83       	std	Y+3, r25	; 0x03
    3782:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
    3784:	8e 81       	ldd	r24, Y+6	; 0x06
    3786:	9f 81       	ldd	r25, Y+7	; 0x07
    3788:	00 97       	sbiw	r24, 0x00	; 0
    378a:	21 f4       	brne	.+8      	; 0x3794 <xStreamBufferSetTriggerLevel+0x34>
	{
		xTriggerLevel = ( size_t ) 1;
    378c:	81 e0       	ldi	r24, 0x01	; 1
    378e:	90 e0       	ldi	r25, 0x00	; 0
    3790:	9f 83       	std	Y+7, r25	; 0x07
    3792:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
    3794:	ea 81       	ldd	r30, Y+2	; 0x02
    3796:	fb 81       	ldd	r31, Y+3	; 0x03
    3798:	24 81       	ldd	r18, Z+4	; 0x04
    379a:	35 81       	ldd	r19, Z+5	; 0x05
    379c:	8e 81       	ldd	r24, Y+6	; 0x06
    379e:	9f 81       	ldd	r25, Y+7	; 0x07
    37a0:	28 17       	cp	r18, r24
    37a2:	39 07       	cpc	r19, r25
    37a4:	48 f0       	brcs	.+18     	; 0x37b8 <xStreamBufferSetTriggerLevel+0x58>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    37a6:	ea 81       	ldd	r30, Y+2	; 0x02
    37a8:	fb 81       	ldd	r31, Y+3	; 0x03
    37aa:	8e 81       	ldd	r24, Y+6	; 0x06
    37ac:	9f 81       	ldd	r25, Y+7	; 0x07
    37ae:	97 83       	std	Z+7, r25	; 0x07
    37b0:	86 83       	std	Z+6, r24	; 0x06
		xReturn = pdPASS;
    37b2:	81 e0       	ldi	r24, 0x01	; 1
    37b4:	89 83       	std	Y+1, r24	; 0x01
    37b6:	01 c0       	rjmp	.+2      	; 0x37ba <xStreamBufferSetTriggerLevel+0x5a>
	}
	else
	{
		xReturn = pdFALSE;
    37b8:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    37ba:	89 81       	ldd	r24, Y+1	; 0x01
}
    37bc:	27 96       	adiw	r28, 0x07	; 7
    37be:	0f b6       	in	r0, 0x3f	; 63
    37c0:	f8 94       	cli
    37c2:	de bf       	out	0x3e, r29	; 62
    37c4:	0f be       	out	0x3f, r0	; 63
    37c6:	cd bf       	out	0x3d, r28	; 61
    37c8:	cf 91       	pop	r28
    37ca:	df 91       	pop	r29
    37cc:	08 95       	ret

000037ce <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    37ce:	df 93       	push	r29
    37d0:	cf 93       	push	r28
    37d2:	00 d0       	rcall	.+0      	; 0x37d4 <xStreamBufferSpacesAvailable+0x6>
    37d4:	00 d0       	rcall	.+0      	; 0x37d6 <xStreamBufferSpacesAvailable+0x8>
    37d6:	00 d0       	rcall	.+0      	; 0x37d8 <xStreamBufferSpacesAvailable+0xa>
    37d8:	cd b7       	in	r28, 0x3d	; 61
    37da:	de b7       	in	r29, 0x3e	; 62
    37dc:	9e 83       	std	Y+6, r25	; 0x06
    37de:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    37e0:	8d 81       	ldd	r24, Y+5	; 0x05
    37e2:	9e 81       	ldd	r25, Y+6	; 0x06
    37e4:	9c 83       	std	Y+4, r25	; 0x04
    37e6:	8b 83       	std	Y+3, r24	; 0x03
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    37e8:	eb 81       	ldd	r30, Y+3	; 0x03
    37ea:	fc 81       	ldd	r31, Y+4	; 0x04
    37ec:	24 81       	ldd	r18, Z+4	; 0x04
    37ee:	35 81       	ldd	r19, Z+5	; 0x05
    37f0:	eb 81       	ldd	r30, Y+3	; 0x03
    37f2:	fc 81       	ldd	r31, Y+4	; 0x04
    37f4:	80 81       	ld	r24, Z
    37f6:	91 81       	ldd	r25, Z+1	; 0x01
    37f8:	82 0f       	add	r24, r18
    37fa:	93 1f       	adc	r25, r19
    37fc:	9a 83       	std	Y+2, r25	; 0x02
    37fe:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= pxStreamBuffer->xHead;
    3800:	eb 81       	ldd	r30, Y+3	; 0x03
    3802:	fc 81       	ldd	r31, Y+4	; 0x04
    3804:	22 81       	ldd	r18, Z+2	; 0x02
    3806:	33 81       	ldd	r19, Z+3	; 0x03
    3808:	89 81       	ldd	r24, Y+1	; 0x01
    380a:	9a 81       	ldd	r25, Y+2	; 0x02
    380c:	82 1b       	sub	r24, r18
    380e:	93 0b       	sbc	r25, r19
    3810:	9a 83       	std	Y+2, r25	; 0x02
    3812:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= ( size_t ) 1;
    3814:	89 81       	ldd	r24, Y+1	; 0x01
    3816:	9a 81       	ldd	r25, Y+2	; 0x02
    3818:	01 97       	sbiw	r24, 0x01	; 1
    381a:	9a 83       	std	Y+2, r25	; 0x02
    381c:	89 83       	std	Y+1, r24	; 0x01

	if( xSpace >= pxStreamBuffer->xLength )
    381e:	eb 81       	ldd	r30, Y+3	; 0x03
    3820:	fc 81       	ldd	r31, Y+4	; 0x04
    3822:	24 81       	ldd	r18, Z+4	; 0x04
    3824:	35 81       	ldd	r19, Z+5	; 0x05
    3826:	89 81       	ldd	r24, Y+1	; 0x01
    3828:	9a 81       	ldd	r25, Y+2	; 0x02
    382a:	82 17       	cp	r24, r18
    382c:	93 07       	cpc	r25, r19
    382e:	50 f0       	brcs	.+20     	; 0x3844 <xStreamBufferSpacesAvailable+0x76>
	{
		xSpace -= pxStreamBuffer->xLength;
    3830:	eb 81       	ldd	r30, Y+3	; 0x03
    3832:	fc 81       	ldd	r31, Y+4	; 0x04
    3834:	24 81       	ldd	r18, Z+4	; 0x04
    3836:	35 81       	ldd	r19, Z+5	; 0x05
    3838:	89 81       	ldd	r24, Y+1	; 0x01
    383a:	9a 81       	ldd	r25, Y+2	; 0x02
    383c:	82 1b       	sub	r24, r18
    383e:	93 0b       	sbc	r25, r19
    3840:	9a 83       	std	Y+2, r25	; 0x02
    3842:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
    3844:	89 81       	ldd	r24, Y+1	; 0x01
    3846:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3848:	26 96       	adiw	r28, 0x06	; 6
    384a:	0f b6       	in	r0, 0x3f	; 63
    384c:	f8 94       	cli
    384e:	de bf       	out	0x3e, r29	; 62
    3850:	0f be       	out	0x3f, r0	; 63
    3852:	cd bf       	out	0x3d, r28	; 61
    3854:	cf 91       	pop	r28
    3856:	df 91       	pop	r29
    3858:	08 95       	ret

0000385a <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    385a:	df 93       	push	r29
    385c:	cf 93       	push	r28
    385e:	00 d0       	rcall	.+0      	; 0x3860 <xStreamBufferBytesAvailable+0x6>
    3860:	00 d0       	rcall	.+0      	; 0x3862 <xStreamBufferBytesAvailable+0x8>
    3862:	00 d0       	rcall	.+0      	; 0x3864 <xStreamBufferBytesAvailable+0xa>
    3864:	cd b7       	in	r28, 0x3d	; 61
    3866:	de b7       	in	r29, 0x3e	; 62
    3868:	9e 83       	std	Y+6, r25	; 0x06
    386a:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    386c:	8d 81       	ldd	r24, Y+5	; 0x05
    386e:	9e 81       	ldd	r25, Y+6	; 0x06
    3870:	9c 83       	std	Y+4, r25	; 0x04
    3872:	8b 83       	std	Y+3, r24	; 0x03
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
    3874:	8b 81       	ldd	r24, Y+3	; 0x03
    3876:	9c 81       	ldd	r25, Y+4	; 0x04
    3878:	0e 94 17 22 	call	0x442e	; 0x442e <prvBytesInBuffer>
    387c:	9a 83       	std	Y+2, r25	; 0x02
    387e:	89 83       	std	Y+1, r24	; 0x01
	return xReturn;
    3880:	89 81       	ldd	r24, Y+1	; 0x01
    3882:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3884:	26 96       	adiw	r28, 0x06	; 6
    3886:	0f b6       	in	r0, 0x3f	; 63
    3888:	f8 94       	cli
    388a:	de bf       	out	0x3e, r29	; 62
    388c:	0f be       	out	0x3f, r0	; 63
    388e:	cd bf       	out	0x3d, r28	; 61
    3890:	cf 91       	pop	r28
    3892:	df 91       	pop	r29
    3894:	08 95       	ret

00003896 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
    3896:	ef 92       	push	r14
    3898:	ff 92       	push	r15
    389a:	0f 93       	push	r16
    389c:	1f 93       	push	r17
    389e:	df 93       	push	r29
    38a0:	cf 93       	push	r28
    38a2:	cd b7       	in	r28, 0x3d	; 61
    38a4:	de b7       	in	r29, 0x3e	; 62
    38a6:	63 97       	sbiw	r28, 0x13	; 19
    38a8:	0f b6       	in	r0, 0x3f	; 63
    38aa:	f8 94       	cli
    38ac:	de bf       	out	0x3e, r29	; 62
    38ae:	0f be       	out	0x3f, r0	; 63
    38b0:	cd bf       	out	0x3d, r28	; 61
    38b2:	9d 87       	std	Y+13, r25	; 0x0d
    38b4:	8c 87       	std	Y+12, r24	; 0x0c
    38b6:	7f 87       	std	Y+15, r23	; 0x0f
    38b8:	6e 87       	std	Y+14, r22	; 0x0e
    38ba:	59 8b       	std	Y+17, r21	; 0x11
    38bc:	48 8b       	std	Y+16, r20	; 0x10
    38be:	3b 8b       	std	Y+19, r19	; 0x13
    38c0:	2a 8b       	std	Y+18, r18	; 0x12
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    38c2:	8c 85       	ldd	r24, Y+12	; 0x0c
    38c4:	9d 85       	ldd	r25, Y+13	; 0x0d
    38c6:	98 87       	std	Y+8, r25	; 0x08
    38c8:	8f 83       	std	Y+7, r24	; 0x07
size_t xReturn, xSpace = 0;
    38ca:	1c 82       	std	Y+4, r1	; 0x04
    38cc:	1b 82       	std	Y+3, r1	; 0x03
size_t xRequiredSpace = xDataLengthBytes;
    38ce:	88 89       	ldd	r24, Y+16	; 0x10
    38d0:	99 89       	ldd	r25, Y+17	; 0x11
    38d2:	9a 83       	std	Y+2, r25	; 0x02
    38d4:	89 83       	std	Y+1, r24	; 0x01

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    38d6:	ef 81       	ldd	r30, Y+7	; 0x07
    38d8:	f8 85       	ldd	r31, Y+8	; 0x08
    38da:	86 85       	ldd	r24, Z+14	; 0x0e
    38dc:	88 2f       	mov	r24, r24
    38de:	90 e0       	ldi	r25, 0x00	; 0
    38e0:	81 70       	andi	r24, 0x01	; 1
    38e2:	90 70       	andi	r25, 0x00	; 0
    38e4:	88 23       	and	r24, r24
    38e6:	29 f0       	breq	.+10     	; 0x38f2 <xStreamBufferSend+0x5c>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    38e8:	89 81       	ldd	r24, Y+1	; 0x01
    38ea:	9a 81       	ldd	r25, Y+2	; 0x02
    38ec:	02 96       	adiw	r24, 0x02	; 2
    38ee:	9a 83       	std	Y+2, r25	; 0x02
    38f0:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    38f2:	8a 89       	ldd	r24, Y+18	; 0x12
    38f4:	9b 89       	ldd	r25, Y+19	; 0x13
    38f6:	00 97       	sbiw	r24, 0x00	; 0
    38f8:	09 f4       	brne	.+2      	; 0x38fc <xStreamBufferSend+0x66>
    38fa:	40 c0       	rjmp	.+128    	; 0x397c <xStreamBufferSend+0xe6>
	{
		vTaskSetTimeOutState( &xTimeOut );
    38fc:	ce 01       	movw	r24, r28
    38fe:	09 96       	adiw	r24, 0x09	; 9
    3900:	0e 94 e0 29 	call	0x53c0	; 0x53c0 <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
    3904:	0f b6       	in	r0, 0x3f	; 63
    3906:	f8 94       	cli
    3908:	0f 92       	push	r0
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    390a:	8f 81       	ldd	r24, Y+7	; 0x07
    390c:	98 85       	ldd	r25, Y+8	; 0x08
    390e:	0e 94 e7 1b 	call	0x37ce	; 0x37ce <xStreamBufferSpacesAvailable>
    3912:	9c 83       	std	Y+4, r25	; 0x04
    3914:	8b 83       	std	Y+3, r24	; 0x03

				if( xSpace < xRequiredSpace )
    3916:	2b 81       	ldd	r18, Y+3	; 0x03
    3918:	3c 81       	ldd	r19, Y+4	; 0x04
    391a:	89 81       	ldd	r24, Y+1	; 0x01
    391c:	9a 81       	ldd	r25, Y+2	; 0x02
    391e:	28 17       	cp	r18, r24
    3920:	39 07       	cpc	r19, r25
    3922:	50 f5       	brcc	.+84     	; 0x3978 <xStreamBufferSend+0xe2>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
    3924:	80 e0       	ldi	r24, 0x00	; 0
    3926:	90 e0       	ldi	r25, 0x00	; 0
    3928:	0e 94 f0 2e 	call	0x5de0	; 0x5de0 <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    392c:	0e 94 49 2b 	call	0x5692	; 0x5692 <xTaskGetCurrentTaskHandle>
    3930:	ef 81       	ldd	r30, Y+7	; 0x07
    3932:	f8 85       	ldd	r31, Y+8	; 0x08
    3934:	93 87       	std	Z+11, r25	; 0x0b
    3936:	82 87       	std	Z+10, r24	; 0x0a
				{
					taskEXIT_CRITICAL();
					break;
				}
			}
			taskEXIT_CRITICAL();
    3938:	0f 90       	pop	r0
    393a:	0f be       	out	0x3f, r0	; 63

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    393c:	ea 89       	ldd	r30, Y+18	; 0x12
    393e:	fb 89       	ldd	r31, Y+19	; 0x13
    3940:	60 e0       	ldi	r22, 0x00	; 0
    3942:	70 e0       	ldi	r23, 0x00	; 0
    3944:	80 e0       	ldi	r24, 0x00	; 0
    3946:	90 e0       	ldi	r25, 0x00	; 0
    3948:	20 e0       	ldi	r18, 0x00	; 0
    394a:	30 e0       	ldi	r19, 0x00	; 0
    394c:	40 e0       	ldi	r20, 0x00	; 0
    394e:	50 e0       	ldi	r21, 0x00	; 0
    3950:	00 e0       	ldi	r16, 0x00	; 0
    3952:	10 e0       	ldi	r17, 0x00	; 0
    3954:	7f 01       	movw	r14, r30
    3956:	0e 94 f9 2b 	call	0x57f2	; 0x57f2 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
    395a:	ef 81       	ldd	r30, Y+7	; 0x07
    395c:	f8 85       	ldd	r31, Y+8	; 0x08
    395e:	13 86       	std	Z+11, r1	; 0x0b
    3960:	12 86       	std	Z+10, r1	; 0x0a

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    3962:	ce 01       	movw	r24, r28
    3964:	09 96       	adiw	r24, 0x09	; 9
    3966:	9e 01       	movw	r18, r28
    3968:	2e 5e       	subi	r18, 0xEE	; 238
    396a:	3f 4f       	sbci	r19, 0xFF	; 255
    396c:	b9 01       	movw	r22, r18
    396e:	0e 94 17 2a 	call	0x542e	; 0x542e <xTaskCheckForTimeOut>
    3972:	88 23       	and	r24, r24
    3974:	39 f2       	breq	.-114    	; 0x3904 <xStreamBufferSend+0x6e>
    3976:	02 c0       	rjmp	.+4      	; 0x397c <xStreamBufferSend+0xe6>
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
				}
				else
				{
					taskEXIT_CRITICAL();
    3978:	0f 90       	pop	r0
    397a:	0f be       	out	0x3f, r0	; 63
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
    397c:	8b 81       	ldd	r24, Y+3	; 0x03
    397e:	9c 81       	ldd	r25, Y+4	; 0x04
    3980:	00 97       	sbiw	r24, 0x00	; 0
    3982:	31 f4       	brne	.+12     	; 0x3990 <xStreamBufferSend+0xfa>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3984:	8f 81       	ldd	r24, Y+7	; 0x07
    3986:	98 85       	ldd	r25, Y+8	; 0x08
    3988:	0e 94 e7 1b 	call	0x37ce	; 0x37ce <xStreamBufferSpacesAvailable>
    398c:	9c 83       	std	Y+4, r25	; 0x04
    398e:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    3990:	8f 81       	ldd	r24, Y+7	; 0x07
    3992:	98 85       	ldd	r25, Y+8	; 0x08
    3994:	2e 85       	ldd	r18, Y+14	; 0x0e
    3996:	3f 85       	ldd	r19, Y+15	; 0x0f
    3998:	48 89       	ldd	r20, Y+16	; 0x10
    399a:	59 89       	ldd	r21, Y+17	; 0x11
    399c:	eb 81       	ldd	r30, Y+3	; 0x03
    399e:	fc 81       	ldd	r31, Y+4	; 0x04
    39a0:	a9 81       	ldd	r26, Y+1	; 0x01
    39a2:	ba 81       	ldd	r27, Y+2	; 0x02
    39a4:	b9 01       	movw	r22, r18
    39a6:	9f 01       	movw	r18, r30
    39a8:	8d 01       	movw	r16, r26
    39aa:	0e 94 90 1d 	call	0x3b20	; 0x3b20 <prvWriteMessageToBuffer>
    39ae:	9e 83       	std	Y+6, r25	; 0x06
    39b0:	8d 83       	std	Y+5, r24	; 0x05

	if( xReturn > ( size_t ) 0 )
    39b2:	8d 81       	ldd	r24, Y+5	; 0x05
    39b4:	9e 81       	ldd	r25, Y+6	; 0x06
    39b6:	00 97       	sbiw	r24, 0x00	; 0
    39b8:	39 f1       	breq	.+78     	; 0x3a08 <xStreamBufferSend+0x172>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    39ba:	8f 81       	ldd	r24, Y+7	; 0x07
    39bc:	98 85       	ldd	r25, Y+8	; 0x08
    39be:	0e 94 17 22 	call	0x442e	; 0x442e <prvBytesInBuffer>
    39c2:	9c 01       	movw	r18, r24
    39c4:	ef 81       	ldd	r30, Y+7	; 0x07
    39c6:	f8 85       	ldd	r31, Y+8	; 0x08
    39c8:	86 81       	ldd	r24, Z+6	; 0x06
    39ca:	97 81       	ldd	r25, Z+7	; 0x07
    39cc:	28 17       	cp	r18, r24
    39ce:	39 07       	cpc	r19, r25
    39d0:	d8 f0       	brcs	.+54     	; 0x3a08 <xStreamBufferSend+0x172>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
    39d2:	0e 94 78 26 	call	0x4cf0	; 0x4cf0 <vTaskSuspendAll>
    39d6:	ef 81       	ldd	r30, Y+7	; 0x07
    39d8:	f8 85       	ldd	r31, Y+8	; 0x08
    39da:	80 85       	ldd	r24, Z+8	; 0x08
    39dc:	91 85       	ldd	r25, Z+9	; 0x09
    39de:	00 97       	sbiw	r24, 0x00	; 0
    39e0:	89 f0       	breq	.+34     	; 0x3a04 <xStreamBufferSend+0x16e>
    39e2:	ef 81       	ldd	r30, Y+7	; 0x07
    39e4:	f8 85       	ldd	r31, Y+8	; 0x08
    39e6:	80 85       	ldd	r24, Z+8	; 0x08
    39e8:	91 85       	ldd	r25, Z+9	; 0x09
    39ea:	40 e0       	ldi	r20, 0x00	; 0
    39ec:	50 e0       	ldi	r21, 0x00	; 0
    39ee:	60 e0       	ldi	r22, 0x00	; 0
    39f0:	70 e0       	ldi	r23, 0x00	; 0
    39f2:	20 e0       	ldi	r18, 0x00	; 0
    39f4:	00 e0       	ldi	r16, 0x00	; 0
    39f6:	10 e0       	ldi	r17, 0x00	; 0
    39f8:	0e 94 95 2c 	call	0x592a	; 0x592a <xTaskGenericNotify>
    39fc:	ef 81       	ldd	r30, Y+7	; 0x07
    39fe:	f8 85       	ldd	r31, Y+8	; 0x08
    3a00:	11 86       	std	Z+9, r1	; 0x09
    3a02:	10 86       	std	Z+8, r1	; 0x08
    3a04:	0e 94 84 26 	call	0x4d08	; 0x4d08 <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
    3a08:	8d 81       	ldd	r24, Y+5	; 0x05
    3a0a:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3a0c:	63 96       	adiw	r28, 0x13	; 19
    3a0e:	0f b6       	in	r0, 0x3f	; 63
    3a10:	f8 94       	cli
    3a12:	de bf       	out	0x3e, r29	; 62
    3a14:	0f be       	out	0x3f, r0	; 63
    3a16:	cd bf       	out	0x3d, r28	; 61
    3a18:	cf 91       	pop	r28
    3a1a:	df 91       	pop	r29
    3a1c:	1f 91       	pop	r17
    3a1e:	0f 91       	pop	r16
    3a20:	ff 90       	pop	r15
    3a22:	ef 90       	pop	r14
    3a24:	08 95       	ret

00003a26 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
    3a26:	ef 92       	push	r14
    3a28:	ff 92       	push	r15
    3a2a:	0f 93       	push	r16
    3a2c:	1f 93       	push	r17
    3a2e:	df 93       	push	r29
    3a30:	cf 93       	push	r28
    3a32:	cd b7       	in	r28, 0x3d	; 61
    3a34:	de b7       	in	r29, 0x3e	; 62
    3a36:	61 97       	sbiw	r28, 0x11	; 17
    3a38:	0f b6       	in	r0, 0x3f	; 63
    3a3a:	f8 94       	cli
    3a3c:	de bf       	out	0x3e, r29	; 62
    3a3e:	0f be       	out	0x3f, r0	; 63
    3a40:	cd bf       	out	0x3d, r28	; 61
    3a42:	9b 87       	std	Y+11, r25	; 0x0b
    3a44:	8a 87       	std	Y+10, r24	; 0x0a
    3a46:	7d 87       	std	Y+13, r23	; 0x0d
    3a48:	6c 87       	std	Y+12, r22	; 0x0c
    3a4a:	5f 87       	std	Y+15, r21	; 0x0f
    3a4c:	4e 87       	std	Y+14, r20	; 0x0e
    3a4e:	39 8b       	std	Y+17, r19	; 0x11
    3a50:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3a52:	8a 85       	ldd	r24, Y+10	; 0x0a
    3a54:	9b 85       	ldd	r25, Y+11	; 0x0b
    3a56:	99 87       	std	Y+9, r25	; 0x09
    3a58:	88 87       	std	Y+8, r24	; 0x08
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
    3a5a:	8e 85       	ldd	r24, Y+14	; 0x0e
    3a5c:	9f 85       	ldd	r25, Y+15	; 0x0f
    3a5e:	9b 83       	std	Y+3, r25	; 0x03
    3a60:	8a 83       	std	Y+2, r24	; 0x02

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3a62:	e8 85       	ldd	r30, Y+8	; 0x08
    3a64:	f9 85       	ldd	r31, Y+9	; 0x09
    3a66:	86 85       	ldd	r24, Z+14	; 0x0e
    3a68:	88 2f       	mov	r24, r24
    3a6a:	90 e0       	ldi	r25, 0x00	; 0
    3a6c:	81 70       	andi	r24, 0x01	; 1
    3a6e:	90 70       	andi	r25, 0x00	; 0
    3a70:	88 23       	and	r24, r24
    3a72:	29 f0       	breq	.+10     	; 0x3a7e <xStreamBufferSendFromISR+0x58>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3a74:	8a 81       	ldd	r24, Y+2	; 0x02
    3a76:	9b 81       	ldd	r25, Y+3	; 0x03
    3a78:	02 96       	adiw	r24, 0x02	; 2
    3a7a:	9b 83       	std	Y+3, r25	; 0x03
    3a7c:	8a 83       	std	Y+2, r24	; 0x02
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3a7e:	88 85       	ldd	r24, Y+8	; 0x08
    3a80:	99 85       	ldd	r25, Y+9	; 0x09
    3a82:	0e 94 e7 1b 	call	0x37ce	; 0x37ce <xStreamBufferSpacesAvailable>
    3a86:	9d 83       	std	Y+5, r25	; 0x05
    3a88:	8c 83       	std	Y+4, r24	; 0x04
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    3a8a:	88 85       	ldd	r24, Y+8	; 0x08
    3a8c:	99 85       	ldd	r25, Y+9	; 0x09
    3a8e:	2c 85       	ldd	r18, Y+12	; 0x0c
    3a90:	3d 85       	ldd	r19, Y+13	; 0x0d
    3a92:	4e 85       	ldd	r20, Y+14	; 0x0e
    3a94:	5f 85       	ldd	r21, Y+15	; 0x0f
    3a96:	ec 81       	ldd	r30, Y+4	; 0x04
    3a98:	fd 81       	ldd	r31, Y+5	; 0x05
    3a9a:	aa 81       	ldd	r26, Y+2	; 0x02
    3a9c:	bb 81       	ldd	r27, Y+3	; 0x03
    3a9e:	b9 01       	movw	r22, r18
    3aa0:	9f 01       	movw	r18, r30
    3aa2:	8d 01       	movw	r16, r26
    3aa4:	0e 94 90 1d 	call	0x3b20	; 0x3b20 <prvWriteMessageToBuffer>
    3aa8:	9f 83       	std	Y+7, r25	; 0x07
    3aaa:	8e 83       	std	Y+6, r24	; 0x06

	if( xReturn > ( size_t ) 0 )
    3aac:	8e 81       	ldd	r24, Y+6	; 0x06
    3aae:	9f 81       	ldd	r25, Y+7	; 0x07
    3ab0:	00 97       	sbiw	r24, 0x00	; 0
    3ab2:	39 f1       	breq	.+78     	; 0x3b02 <xStreamBufferSendFromISR+0xdc>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    3ab4:	88 85       	ldd	r24, Y+8	; 0x08
    3ab6:	99 85       	ldd	r25, Y+9	; 0x09
    3ab8:	0e 94 17 22 	call	0x442e	; 0x442e <prvBytesInBuffer>
    3abc:	9c 01       	movw	r18, r24
    3abe:	e8 85       	ldd	r30, Y+8	; 0x08
    3ac0:	f9 85       	ldd	r31, Y+9	; 0x09
    3ac2:	86 81       	ldd	r24, Z+6	; 0x06
    3ac4:	97 81       	ldd	r25, Z+7	; 0x07
    3ac6:	28 17       	cp	r18, r24
    3ac8:	39 07       	cpc	r19, r25
    3aca:	d8 f0       	brcs	.+54     	; 0x3b02 <xStreamBufferSendFromISR+0xdc>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    3acc:	19 82       	std	Y+1, r1	; 0x01
    3ace:	e8 85       	ldd	r30, Y+8	; 0x08
    3ad0:	f9 85       	ldd	r31, Y+9	; 0x09
    3ad2:	80 85       	ldd	r24, Z+8	; 0x08
    3ad4:	91 85       	ldd	r25, Z+9	; 0x09
    3ad6:	00 97       	sbiw	r24, 0x00	; 0
    3ad8:	a1 f0       	breq	.+40     	; 0x3b02 <xStreamBufferSendFromISR+0xdc>
    3ada:	e8 85       	ldd	r30, Y+8	; 0x08
    3adc:	f9 85       	ldd	r31, Y+9	; 0x09
    3ade:	80 85       	ldd	r24, Z+8	; 0x08
    3ae0:	91 85       	ldd	r25, Z+9	; 0x09
    3ae2:	e8 89       	ldd	r30, Y+16	; 0x10
    3ae4:	f9 89       	ldd	r31, Y+17	; 0x11
    3ae6:	40 e0       	ldi	r20, 0x00	; 0
    3ae8:	50 e0       	ldi	r21, 0x00	; 0
    3aea:	60 e0       	ldi	r22, 0x00	; 0
    3aec:	70 e0       	ldi	r23, 0x00	; 0
    3aee:	20 e0       	ldi	r18, 0x00	; 0
    3af0:	00 e0       	ldi	r16, 0x00	; 0
    3af2:	10 e0       	ldi	r17, 0x00	; 0
    3af4:	7f 01       	movw	r14, r30
    3af6:	0e 94 72 2d 	call	0x5ae4	; 0x5ae4 <xTaskGenericNotifyFromISR>
    3afa:	e8 85       	ldd	r30, Y+8	; 0x08
    3afc:	f9 85       	ldd	r31, Y+9	; 0x09
    3afe:	11 86       	std	Z+9, r1	; 0x09
    3b00:	10 86       	std	Z+8, r1	; 0x08
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
    3b02:	8e 81       	ldd	r24, Y+6	; 0x06
    3b04:	9f 81       	ldd	r25, Y+7	; 0x07
}
    3b06:	61 96       	adiw	r28, 0x11	; 17
    3b08:	0f b6       	in	r0, 0x3f	; 63
    3b0a:	f8 94       	cli
    3b0c:	de bf       	out	0x3e, r29	; 62
    3b0e:	0f be       	out	0x3f, r0	; 63
    3b10:	cd bf       	out	0x3d, r28	; 61
    3b12:	cf 91       	pop	r28
    3b14:	df 91       	pop	r29
    3b16:	1f 91       	pop	r17
    3b18:	0f 91       	pop	r16
    3b1a:	ff 90       	pop	r15
    3b1c:	ef 90       	pop	r14
    3b1e:	08 95       	ret

00003b20 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
    3b20:	0f 93       	push	r16
    3b22:	1f 93       	push	r17
    3b24:	df 93       	push	r29
    3b26:	cf 93       	push	r28
    3b28:	cd b7       	in	r28, 0x3d	; 61
    3b2a:	de b7       	in	r29, 0x3e	; 62
    3b2c:	61 97       	sbiw	r28, 0x11	; 17
    3b2e:	0f b6       	in	r0, 0x3f	; 63
    3b30:	f8 94       	cli
    3b32:	de bf       	out	0x3e, r29	; 62
    3b34:	0f be       	out	0x3f, r0	; 63
    3b36:	cd bf       	out	0x3d, r28	; 61
    3b38:	9d 83       	std	Y+5, r25	; 0x05
    3b3a:	8c 83       	std	Y+4, r24	; 0x04
    3b3c:	7f 83       	std	Y+7, r23	; 0x07
    3b3e:	6e 83       	std	Y+6, r22	; 0x06
    3b40:	59 87       	std	Y+9, r21	; 0x09
    3b42:	48 87       	std	Y+8, r20	; 0x08
    3b44:	3b 87       	std	Y+11, r19	; 0x0b
    3b46:	2a 87       	std	Y+10, r18	; 0x0a
    3b48:	1d 87       	std	Y+13, r17	; 0x0d
    3b4a:	0c 87       	std	Y+12, r16	; 0x0c
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
    3b4c:	8a 85       	ldd	r24, Y+10	; 0x0a
    3b4e:	9b 85       	ldd	r25, Y+11	; 0x0b
    3b50:	00 97       	sbiw	r24, 0x00	; 0
    3b52:	11 f4       	brne	.+4      	; 0x3b58 <prvWriteMessageToBuffer+0x38>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
    3b54:	1b 82       	std	Y+3, r1	; 0x03
    3b56:	38 c0       	rjmp	.+112    	; 0x3bc8 <prvWriteMessageToBuffer+0xa8>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
    3b58:	ec 81       	ldd	r30, Y+4	; 0x04
    3b5a:	fd 81       	ldd	r31, Y+5	; 0x05
    3b5c:	86 85       	ldd	r24, Z+14	; 0x0e
    3b5e:	88 2f       	mov	r24, r24
    3b60:	90 e0       	ldi	r25, 0x00	; 0
    3b62:	81 70       	andi	r24, 0x01	; 1
    3b64:	90 70       	andi	r25, 0x00	; 0
    3b66:	00 97       	sbiw	r24, 0x00	; 0
    3b68:	d1 f4       	brne	.+52     	; 0x3b9e <prvWriteMessageToBuffer+0x7e>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
    3b6a:	81 e0       	ldi	r24, 0x01	; 1
    3b6c:	8b 83       	std	Y+3, r24	; 0x03
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    3b6e:	28 85       	ldd	r18, Y+8	; 0x08
    3b70:	39 85       	ldd	r19, Y+9	; 0x09
    3b72:	39 8b       	std	Y+17, r19	; 0x11
    3b74:	28 8b       	std	Y+16, r18	; 0x10
    3b76:	8a 85       	ldd	r24, Y+10	; 0x0a
    3b78:	9b 85       	ldd	r25, Y+11	; 0x0b
    3b7a:	9f 87       	std	Y+15, r25	; 0x0f
    3b7c:	8e 87       	std	Y+14, r24	; 0x0e
    3b7e:	2e 85       	ldd	r18, Y+14	; 0x0e
    3b80:	3f 85       	ldd	r19, Y+15	; 0x0f
    3b82:	88 89       	ldd	r24, Y+16	; 0x10
    3b84:	99 89       	ldd	r25, Y+17	; 0x11
    3b86:	82 17       	cp	r24, r18
    3b88:	93 07       	cpc	r25, r19
    3b8a:	20 f4       	brcc	.+8      	; 0x3b94 <prvWriteMessageToBuffer+0x74>
    3b8c:	28 89       	ldd	r18, Y+16	; 0x10
    3b8e:	39 89       	ldd	r19, Y+17	; 0x11
    3b90:	3f 87       	std	Y+15, r19	; 0x0f
    3b92:	2e 87       	std	Y+14, r18	; 0x0e
    3b94:	8e 85       	ldd	r24, Y+14	; 0x0e
    3b96:	9f 85       	ldd	r25, Y+15	; 0x0f
    3b98:	99 87       	std	Y+9, r25	; 0x09
    3b9a:	88 87       	std	Y+8, r24	; 0x08
    3b9c:	15 c0       	rjmp	.+42     	; 0x3bc8 <prvWriteMessageToBuffer+0xa8>
	}
	else if( xSpace >= xRequiredSpace )
    3b9e:	2a 85       	ldd	r18, Y+10	; 0x0a
    3ba0:	3b 85       	ldd	r19, Y+11	; 0x0b
    3ba2:	8c 85       	ldd	r24, Y+12	; 0x0c
    3ba4:	9d 85       	ldd	r25, Y+13	; 0x0d
    3ba6:	28 17       	cp	r18, r24
    3ba8:	39 07       	cpc	r19, r25
    3baa:	68 f0       	brcs	.+26     	; 0x3bc6 <prvWriteMessageToBuffer+0xa6>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
    3bac:	81 e0       	ldi	r24, 0x01	; 1
    3bae:	8b 83       	std	Y+3, r24	; 0x03
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
    3bb0:	9e 01       	movw	r18, r28
    3bb2:	28 5f       	subi	r18, 0xF8	; 248
    3bb4:	3f 4f       	sbci	r19, 0xFF	; 255
    3bb6:	8c 81       	ldd	r24, Y+4	; 0x04
    3bb8:	9d 81       	ldd	r25, Y+5	; 0x05
    3bba:	b9 01       	movw	r22, r18
    3bbc:	42 e0       	ldi	r20, 0x02	; 2
    3bbe:	50 e0       	ldi	r21, 0x00	; 0
    3bc0:	0e 94 dd 20 	call	0x41ba	; 0x41ba <prvWriteBytesToBuffer>
    3bc4:	01 c0       	rjmp	.+2      	; 0x3bc8 <prvWriteMessageToBuffer+0xa8>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
    3bc6:	1b 82       	std	Y+3, r1	; 0x03
	}

	if( xShouldWrite != pdFALSE )
    3bc8:	8b 81       	ldd	r24, Y+3	; 0x03
    3bca:	88 23       	and	r24, r24
    3bcc:	61 f0       	breq	.+24     	; 0x3be6 <prvWriteMessageToBuffer+0xc6>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
    3bce:	2e 81       	ldd	r18, Y+6	; 0x06
    3bd0:	3f 81       	ldd	r19, Y+7	; 0x07
    3bd2:	48 85       	ldd	r20, Y+8	; 0x08
    3bd4:	59 85       	ldd	r21, Y+9	; 0x09
    3bd6:	8c 81       	ldd	r24, Y+4	; 0x04
    3bd8:	9d 81       	ldd	r25, Y+5	; 0x05
    3bda:	b9 01       	movw	r22, r18
    3bdc:	0e 94 dd 20 	call	0x41ba	; 0x41ba <prvWriteBytesToBuffer>
    3be0:	9a 83       	std	Y+2, r25	; 0x02
    3be2:	89 83       	std	Y+1, r24	; 0x01
    3be4:	02 c0       	rjmp	.+4      	; 0x3bea <prvWriteMessageToBuffer+0xca>
	}
	else
	{
		xReturn = 0;
    3be6:	1a 82       	std	Y+2, r1	; 0x02
    3be8:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3bea:	89 81       	ldd	r24, Y+1	; 0x01
    3bec:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3bee:	61 96       	adiw	r28, 0x11	; 17
    3bf0:	0f b6       	in	r0, 0x3f	; 63
    3bf2:	f8 94       	cli
    3bf4:	de bf       	out	0x3e, r29	; 62
    3bf6:	0f be       	out	0x3f, r0	; 63
    3bf8:	cd bf       	out	0x3d, r28	; 61
    3bfa:	cf 91       	pop	r28
    3bfc:	df 91       	pop	r29
    3bfe:	1f 91       	pop	r17
    3c00:	0f 91       	pop	r16
    3c02:	08 95       	ret

00003c04 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
    3c04:	ef 92       	push	r14
    3c06:	ff 92       	push	r15
    3c08:	0f 93       	push	r16
    3c0a:	1f 93       	push	r17
    3c0c:	df 93       	push	r29
    3c0e:	cf 93       	push	r28
    3c10:	cd b7       	in	r28, 0x3d	; 61
    3c12:	de b7       	in	r29, 0x3e	; 62
    3c14:	60 97       	sbiw	r28, 0x10	; 16
    3c16:	0f b6       	in	r0, 0x3f	; 63
    3c18:	f8 94       	cli
    3c1a:	de bf       	out	0x3e, r29	; 62
    3c1c:	0f be       	out	0x3f, r0	; 63
    3c1e:	cd bf       	out	0x3d, r28	; 61
    3c20:	9a 87       	std	Y+10, r25	; 0x0a
    3c22:	89 87       	std	Y+9, r24	; 0x09
    3c24:	7c 87       	std	Y+12, r23	; 0x0c
    3c26:	6b 87       	std	Y+11, r22	; 0x0b
    3c28:	5e 87       	std	Y+14, r21	; 0x0e
    3c2a:	4d 87       	std	Y+13, r20	; 0x0d
    3c2c:	38 8b       	std	Y+16, r19	; 0x10
    3c2e:	2f 87       	std	Y+15, r18	; 0x0f
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3c30:	89 85       	ldd	r24, Y+9	; 0x09
    3c32:	9a 85       	ldd	r25, Y+10	; 0x0a
    3c34:	98 87       	std	Y+8, r25	; 0x08
    3c36:	8f 83       	std	Y+7, r24	; 0x07
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    3c38:	1e 82       	std	Y+6, r1	; 0x06
    3c3a:	1d 82       	std	Y+5, r1	; 0x05
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3c3c:	ef 81       	ldd	r30, Y+7	; 0x07
    3c3e:	f8 85       	ldd	r31, Y+8	; 0x08
    3c40:	86 85       	ldd	r24, Z+14	; 0x0e
    3c42:	88 2f       	mov	r24, r24
    3c44:	90 e0       	ldi	r25, 0x00	; 0
    3c46:	81 70       	andi	r24, 0x01	; 1
    3c48:	90 70       	andi	r25, 0x00	; 0
    3c4a:	88 23       	and	r24, r24
    3c4c:	29 f0       	breq	.+10     	; 0x3c58 <xStreamBufferReceive+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3c4e:	82 e0       	ldi	r24, 0x02	; 2
    3c50:	90 e0       	ldi	r25, 0x00	; 0
    3c52:	9a 83       	std	Y+2, r25	; 0x02
    3c54:	89 83       	std	Y+1, r24	; 0x01
    3c56:	02 c0       	rjmp	.+4      	; 0x3c5c <xStreamBufferReceive+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    3c58:	1a 82       	std	Y+2, r1	; 0x02
    3c5a:	19 82       	std	Y+1, r1	; 0x01
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    3c5c:	8f 85       	ldd	r24, Y+15	; 0x0f
    3c5e:	98 89       	ldd	r25, Y+16	; 0x10
    3c60:	00 97       	sbiw	r24, 0x00	; 0
    3c62:	09 f4       	brne	.+2      	; 0x3c66 <xStreamBufferReceive+0x62>
    3c64:	3d c0       	rjmp	.+122    	; 0x3ce0 <xStreamBufferReceive+0xdc>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
    3c66:	0f b6       	in	r0, 0x3f	; 63
    3c68:	f8 94       	cli
    3c6a:	0f 92       	push	r0
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3c6c:	8f 81       	ldd	r24, Y+7	; 0x07
    3c6e:	98 85       	ldd	r25, Y+8	; 0x08
    3c70:	0e 94 17 22 	call	0x442e	; 0x442e <prvBytesInBuffer>
    3c74:	9c 83       	std	Y+4, r25	; 0x04
    3c76:	8b 83       	std	Y+3, r24	; 0x03
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
    3c78:	2b 81       	ldd	r18, Y+3	; 0x03
    3c7a:	3c 81       	ldd	r19, Y+4	; 0x04
    3c7c:	89 81       	ldd	r24, Y+1	; 0x01
    3c7e:	9a 81       	ldd	r25, Y+2	; 0x02
    3c80:	82 17       	cp	r24, r18
    3c82:	93 07       	cpc	r25, r19
    3c84:	50 f0       	brcs	.+20     	; 0x3c9a <xStreamBufferReceive+0x96>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
    3c86:	80 e0       	ldi	r24, 0x00	; 0
    3c88:	90 e0       	ldi	r25, 0x00	; 0
    3c8a:	0e 94 f0 2e 	call	0x5de0	; 0x5de0 <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    3c8e:	0e 94 49 2b 	call	0x5692	; 0x5692 <xTaskGetCurrentTaskHandle>
    3c92:	ef 81       	ldd	r30, Y+7	; 0x07
    3c94:	f8 85       	ldd	r31, Y+8	; 0x08
    3c96:	91 87       	std	Z+9, r25	; 0x09
    3c98:	80 87       	std	Z+8, r24	; 0x08
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3c9a:	0f 90       	pop	r0
    3c9c:	0f be       	out	0x3f, r0	; 63

		if( xBytesAvailable <= xBytesToStoreMessageLength )
    3c9e:	2b 81       	ldd	r18, Y+3	; 0x03
    3ca0:	3c 81       	ldd	r19, Y+4	; 0x04
    3ca2:	89 81       	ldd	r24, Y+1	; 0x01
    3ca4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ca6:	82 17       	cp	r24, r18
    3ca8:	93 07       	cpc	r25, r19
    3caa:	00 f1       	brcs	.+64     	; 0x3cec <xStreamBufferReceive+0xe8>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    3cac:	ef 85       	ldd	r30, Y+15	; 0x0f
    3cae:	f8 89       	ldd	r31, Y+16	; 0x10
    3cb0:	60 e0       	ldi	r22, 0x00	; 0
    3cb2:	70 e0       	ldi	r23, 0x00	; 0
    3cb4:	80 e0       	ldi	r24, 0x00	; 0
    3cb6:	90 e0       	ldi	r25, 0x00	; 0
    3cb8:	20 e0       	ldi	r18, 0x00	; 0
    3cba:	30 e0       	ldi	r19, 0x00	; 0
    3cbc:	40 e0       	ldi	r20, 0x00	; 0
    3cbe:	50 e0       	ldi	r21, 0x00	; 0
    3cc0:	00 e0       	ldi	r16, 0x00	; 0
    3cc2:	10 e0       	ldi	r17, 0x00	; 0
    3cc4:	7f 01       	movw	r14, r30
    3cc6:	0e 94 f9 2b 	call	0x57f2	; 0x57f2 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
    3cca:	ef 81       	ldd	r30, Y+7	; 0x07
    3ccc:	f8 85       	ldd	r31, Y+8	; 0x08
    3cce:	11 86       	std	Z+9, r1	; 0x09
    3cd0:	10 86       	std	Z+8, r1	; 0x08

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3cd2:	8f 81       	ldd	r24, Y+7	; 0x07
    3cd4:	98 85       	ldd	r25, Y+8	; 0x08
    3cd6:	0e 94 17 22 	call	0x442e	; 0x442e <prvBytesInBuffer>
    3cda:	9c 83       	std	Y+4, r25	; 0x04
    3cdc:	8b 83       	std	Y+3, r24	; 0x03
    3cde:	06 c0       	rjmp	.+12     	; 0x3cec <xStreamBufferReceive+0xe8>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3ce0:	8f 81       	ldd	r24, Y+7	; 0x07
    3ce2:	98 85       	ldd	r25, Y+8	; 0x08
    3ce4:	0e 94 17 22 	call	0x442e	; 0x442e <prvBytesInBuffer>
    3ce8:	9c 83       	std	Y+4, r25	; 0x04
    3cea:	8b 83       	std	Y+3, r24	; 0x03
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    3cec:	2b 81       	ldd	r18, Y+3	; 0x03
    3cee:	3c 81       	ldd	r19, Y+4	; 0x04
    3cf0:	89 81       	ldd	r24, Y+1	; 0x01
    3cf2:	9a 81       	ldd	r25, Y+2	; 0x02
    3cf4:	82 17       	cp	r24, r18
    3cf6:	93 07       	cpc	r25, r19
    3cf8:	80 f5       	brcc	.+96     	; 0x3d5a <xStreamBufferReceive+0x156>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    3cfa:	8f 81       	ldd	r24, Y+7	; 0x07
    3cfc:	98 85       	ldd	r25, Y+8	; 0x08
    3cfe:	2b 85       	ldd	r18, Y+11	; 0x0b
    3d00:	3c 85       	ldd	r19, Y+12	; 0x0c
    3d02:	4d 85       	ldd	r20, Y+13	; 0x0d
    3d04:	5e 85       	ldd	r21, Y+14	; 0x0e
    3d06:	eb 81       	ldd	r30, Y+3	; 0x03
    3d08:	fc 81       	ldd	r31, Y+4	; 0x04
    3d0a:	a9 81       	ldd	r26, Y+1	; 0x01
    3d0c:	ba 81       	ldd	r27, Y+2	; 0x02
    3d0e:	b9 01       	movw	r22, r18
    3d10:	9f 01       	movw	r18, r30
    3d12:	8d 01       	movw	r16, r26
    3d14:	0e 94 86 1f 	call	0x3f0c	; 0x3f0c <prvReadMessageFromBuffer>
    3d18:	9e 83       	std	Y+6, r25	; 0x06
    3d1a:	8d 83       	std	Y+5, r24	; 0x05

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    3d1c:	8d 81       	ldd	r24, Y+5	; 0x05
    3d1e:	9e 81       	ldd	r25, Y+6	; 0x06
    3d20:	00 97       	sbiw	r24, 0x00	; 0
    3d22:	d9 f0       	breq	.+54     	; 0x3d5a <xStreamBufferReceive+0x156>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
    3d24:	0e 94 78 26 	call	0x4cf0	; 0x4cf0 <vTaskSuspendAll>
    3d28:	ef 81       	ldd	r30, Y+7	; 0x07
    3d2a:	f8 85       	ldd	r31, Y+8	; 0x08
    3d2c:	82 85       	ldd	r24, Z+10	; 0x0a
    3d2e:	93 85       	ldd	r25, Z+11	; 0x0b
    3d30:	00 97       	sbiw	r24, 0x00	; 0
    3d32:	89 f0       	breq	.+34     	; 0x3d56 <xStreamBufferReceive+0x152>
    3d34:	ef 81       	ldd	r30, Y+7	; 0x07
    3d36:	f8 85       	ldd	r31, Y+8	; 0x08
    3d38:	82 85       	ldd	r24, Z+10	; 0x0a
    3d3a:	93 85       	ldd	r25, Z+11	; 0x0b
    3d3c:	40 e0       	ldi	r20, 0x00	; 0
    3d3e:	50 e0       	ldi	r21, 0x00	; 0
    3d40:	60 e0       	ldi	r22, 0x00	; 0
    3d42:	70 e0       	ldi	r23, 0x00	; 0
    3d44:	20 e0       	ldi	r18, 0x00	; 0
    3d46:	00 e0       	ldi	r16, 0x00	; 0
    3d48:	10 e0       	ldi	r17, 0x00	; 0
    3d4a:	0e 94 95 2c 	call	0x592a	; 0x592a <xTaskGenericNotify>
    3d4e:	ef 81       	ldd	r30, Y+7	; 0x07
    3d50:	f8 85       	ldd	r31, Y+8	; 0x08
    3d52:	13 86       	std	Z+11, r1	; 0x0b
    3d54:	12 86       	std	Z+10, r1	; 0x0a
    3d56:	0e 94 84 26 	call	0x4d08	; 0x4d08 <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
    3d5a:	8d 81       	ldd	r24, Y+5	; 0x05
    3d5c:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3d5e:	60 96       	adiw	r28, 0x10	; 16
    3d60:	0f b6       	in	r0, 0x3f	; 63
    3d62:	f8 94       	cli
    3d64:	de bf       	out	0x3e, r29	; 62
    3d66:	0f be       	out	0x3f, r0	; 63
    3d68:	cd bf       	out	0x3d, r28	; 61
    3d6a:	cf 91       	pop	r28
    3d6c:	df 91       	pop	r29
    3d6e:	1f 91       	pop	r17
    3d70:	0f 91       	pop	r16
    3d72:	ff 90       	pop	r15
    3d74:	ef 90       	pop	r14
    3d76:	08 95       	ret

00003d78 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    3d78:	df 93       	push	r29
    3d7a:	cf 93       	push	r28
    3d7c:	cd b7       	in	r28, 0x3d	; 61
    3d7e:	de b7       	in	r29, 0x3e	; 62
    3d80:	2c 97       	sbiw	r28, 0x0c	; 12
    3d82:	0f b6       	in	r0, 0x3f	; 63
    3d84:	f8 94       	cli
    3d86:	de bf       	out	0x3e, r29	; 62
    3d88:	0f be       	out	0x3f, r0	; 63
    3d8a:	cd bf       	out	0x3d, r28	; 61
    3d8c:	9c 87       	std	Y+12, r25	; 0x0c
    3d8e:	8b 87       	std	Y+11, r24	; 0x0b
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3d90:	8b 85       	ldd	r24, Y+11	; 0x0b
    3d92:	9c 85       	ldd	r25, Y+12	; 0x0c
    3d94:	98 87       	std	Y+8, r25	; 0x08
    3d96:	8f 83       	std	Y+7, r24	; 0x07
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3d98:	ef 81       	ldd	r30, Y+7	; 0x07
    3d9a:	f8 85       	ldd	r31, Y+8	; 0x08
    3d9c:	86 85       	ldd	r24, Z+14	; 0x0e
    3d9e:	88 2f       	mov	r24, r24
    3da0:	90 e0       	ldi	r25, 0x00	; 0
    3da2:	81 70       	andi	r24, 0x01	; 1
    3da4:	90 70       	andi	r25, 0x00	; 0
    3da6:	88 23       	and	r24, r24
    3da8:	61 f1       	breq	.+88     	; 0x3e02 <xStreamBufferNextMessageLengthBytes+0x8a>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3daa:	8f 81       	ldd	r24, Y+7	; 0x07
    3dac:	98 85       	ldd	r25, Y+8	; 0x08
    3dae:	0e 94 17 22 	call	0x442e	; 0x442e <prvBytesInBuffer>
    3db2:	9c 83       	std	Y+4, r25	; 0x04
    3db4:	8b 83       	std	Y+3, r24	; 0x03
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    3db6:	8b 81       	ldd	r24, Y+3	; 0x03
    3db8:	9c 81       	ldd	r25, Y+4	; 0x04
    3dba:	83 30       	cpi	r24, 0x03	; 3
    3dbc:	91 05       	cpc	r25, r1
    3dbe:	f0 f0       	brcs	.+60     	; 0x3dfc <xStreamBufferNextMessageLengthBytes+0x84>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
    3dc0:	ef 81       	ldd	r30, Y+7	; 0x07
    3dc2:	f8 85       	ldd	r31, Y+8	; 0x08
    3dc4:	80 81       	ld	r24, Z
    3dc6:	91 81       	ldd	r25, Z+1	; 0x01
    3dc8:	9a 83       	std	Y+2, r25	; 0x02
    3dca:	89 83       	std	Y+1, r24	; 0x01
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
    3dcc:	9e 01       	movw	r18, r28
    3dce:	27 5f       	subi	r18, 0xF7	; 247
    3dd0:	3f 4f       	sbci	r19, 0xFF	; 255
    3dd2:	8f 81       	ldd	r24, Y+7	; 0x07
    3dd4:	98 85       	ldd	r25, Y+8	; 0x08
    3dd6:	eb 81       	ldd	r30, Y+3	; 0x03
    3dd8:	fc 81       	ldd	r31, Y+4	; 0x04
    3dda:	b9 01       	movw	r22, r18
    3ddc:	42 e0       	ldi	r20, 0x02	; 2
    3dde:	50 e0       	ldi	r21, 0x00	; 0
    3de0:	9f 01       	movw	r18, r30
    3de2:	0e 94 6a 21 	call	0x42d4	; 0x42d4 <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
    3de6:	89 85       	ldd	r24, Y+9	; 0x09
    3de8:	9a 85       	ldd	r25, Y+10	; 0x0a
    3dea:	9e 83       	std	Y+6, r25	; 0x06
    3dec:	8d 83       	std	Y+5, r24	; 0x05
			pxStreamBuffer->xTail = xOriginalTail;
    3dee:	ef 81       	ldd	r30, Y+7	; 0x07
    3df0:	f8 85       	ldd	r31, Y+8	; 0x08
    3df2:	89 81       	ldd	r24, Y+1	; 0x01
    3df4:	9a 81       	ldd	r25, Y+2	; 0x02
    3df6:	91 83       	std	Z+1, r25	; 0x01
    3df8:	80 83       	st	Z, r24
    3dfa:	05 c0       	rjmp	.+10     	; 0x3e06 <xStreamBufferNextMessageLengthBytes+0x8e>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
    3dfc:	1e 82       	std	Y+6, r1	; 0x06
    3dfe:	1d 82       	std	Y+5, r1	; 0x05
    3e00:	02 c0       	rjmp	.+4      	; 0x3e06 <xStreamBufferNextMessageLengthBytes+0x8e>
		}
	}
	else
	{
		xReturn = 0;
    3e02:	1e 82       	std	Y+6, r1	; 0x06
    3e04:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    3e06:	8d 81       	ldd	r24, Y+5	; 0x05
    3e08:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3e0a:	2c 96       	adiw	r28, 0x0c	; 12
    3e0c:	0f b6       	in	r0, 0x3f	; 63
    3e0e:	f8 94       	cli
    3e10:	de bf       	out	0x3e, r29	; 62
    3e12:	0f be       	out	0x3f, r0	; 63
    3e14:	cd bf       	out	0x3d, r28	; 61
    3e16:	cf 91       	pop	r28
    3e18:	df 91       	pop	r29
    3e1a:	08 95       	ret

00003e1c <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
    3e1c:	ef 92       	push	r14
    3e1e:	ff 92       	push	r15
    3e20:	0f 93       	push	r16
    3e22:	1f 93       	push	r17
    3e24:	df 93       	push	r29
    3e26:	cf 93       	push	r28
    3e28:	cd b7       	in	r28, 0x3d	; 61
    3e2a:	de b7       	in	r29, 0x3e	; 62
    3e2c:	61 97       	sbiw	r28, 0x11	; 17
    3e2e:	0f b6       	in	r0, 0x3f	; 63
    3e30:	f8 94       	cli
    3e32:	de bf       	out	0x3e, r29	; 62
    3e34:	0f be       	out	0x3f, r0	; 63
    3e36:	cd bf       	out	0x3d, r28	; 61
    3e38:	9b 87       	std	Y+11, r25	; 0x0b
    3e3a:	8a 87       	std	Y+10, r24	; 0x0a
    3e3c:	7d 87       	std	Y+13, r23	; 0x0d
    3e3e:	6c 87       	std	Y+12, r22	; 0x0c
    3e40:	5f 87       	std	Y+15, r21	; 0x0f
    3e42:	4e 87       	std	Y+14, r20	; 0x0e
    3e44:	39 8b       	std	Y+17, r19	; 0x11
    3e46:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3e48:	8a 85       	ldd	r24, Y+10	; 0x0a
    3e4a:	9b 85       	ldd	r25, Y+11	; 0x0b
    3e4c:	99 87       	std	Y+9, r25	; 0x09
    3e4e:	88 87       	std	Y+8, r24	; 0x08
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    3e50:	1f 82       	std	Y+7, r1	; 0x07
    3e52:	1e 82       	std	Y+6, r1	; 0x06
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3e54:	e8 85       	ldd	r30, Y+8	; 0x08
    3e56:	f9 85       	ldd	r31, Y+9	; 0x09
    3e58:	86 85       	ldd	r24, Z+14	; 0x0e
    3e5a:	88 2f       	mov	r24, r24
    3e5c:	90 e0       	ldi	r25, 0x00	; 0
    3e5e:	81 70       	andi	r24, 0x01	; 1
    3e60:	90 70       	andi	r25, 0x00	; 0
    3e62:	88 23       	and	r24, r24
    3e64:	29 f0       	breq	.+10     	; 0x3e70 <xStreamBufferReceiveFromISR+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3e66:	82 e0       	ldi	r24, 0x02	; 2
    3e68:	90 e0       	ldi	r25, 0x00	; 0
    3e6a:	9b 83       	std	Y+3, r25	; 0x03
    3e6c:	8a 83       	std	Y+2, r24	; 0x02
    3e6e:	02 c0       	rjmp	.+4      	; 0x3e74 <xStreamBufferReceiveFromISR+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    3e70:	1b 82       	std	Y+3, r1	; 0x03
    3e72:	1a 82       	std	Y+2, r1	; 0x02
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3e74:	88 85       	ldd	r24, Y+8	; 0x08
    3e76:	99 85       	ldd	r25, Y+9	; 0x09
    3e78:	0e 94 17 22 	call	0x442e	; 0x442e <prvBytesInBuffer>
    3e7c:	9d 83       	std	Y+5, r25	; 0x05
    3e7e:	8c 83       	std	Y+4, r24	; 0x04
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    3e80:	2c 81       	ldd	r18, Y+4	; 0x04
    3e82:	3d 81       	ldd	r19, Y+5	; 0x05
    3e84:	8a 81       	ldd	r24, Y+2	; 0x02
    3e86:	9b 81       	ldd	r25, Y+3	; 0x03
    3e88:	82 17       	cp	r24, r18
    3e8a:	93 07       	cpc	r25, r19
    3e8c:	80 f5       	brcc	.+96     	; 0x3eee <xStreamBufferReceiveFromISR+0xd2>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    3e8e:	88 85       	ldd	r24, Y+8	; 0x08
    3e90:	99 85       	ldd	r25, Y+9	; 0x09
    3e92:	2c 85       	ldd	r18, Y+12	; 0x0c
    3e94:	3d 85       	ldd	r19, Y+13	; 0x0d
    3e96:	4e 85       	ldd	r20, Y+14	; 0x0e
    3e98:	5f 85       	ldd	r21, Y+15	; 0x0f
    3e9a:	ec 81       	ldd	r30, Y+4	; 0x04
    3e9c:	fd 81       	ldd	r31, Y+5	; 0x05
    3e9e:	aa 81       	ldd	r26, Y+2	; 0x02
    3ea0:	bb 81       	ldd	r27, Y+3	; 0x03
    3ea2:	b9 01       	movw	r22, r18
    3ea4:	9f 01       	movw	r18, r30
    3ea6:	8d 01       	movw	r16, r26
    3ea8:	0e 94 86 1f 	call	0x3f0c	; 0x3f0c <prvReadMessageFromBuffer>
    3eac:	9f 83       	std	Y+7, r25	; 0x07
    3eae:	8e 83       	std	Y+6, r24	; 0x06

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    3eb0:	8e 81       	ldd	r24, Y+6	; 0x06
    3eb2:	9f 81       	ldd	r25, Y+7	; 0x07
    3eb4:	00 97       	sbiw	r24, 0x00	; 0
    3eb6:	d9 f0       	breq	.+54     	; 0x3eee <xStreamBufferReceiveFromISR+0xd2>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    3eb8:	19 82       	std	Y+1, r1	; 0x01
    3eba:	e8 85       	ldd	r30, Y+8	; 0x08
    3ebc:	f9 85       	ldd	r31, Y+9	; 0x09
    3ebe:	82 85       	ldd	r24, Z+10	; 0x0a
    3ec0:	93 85       	ldd	r25, Z+11	; 0x0b
    3ec2:	00 97       	sbiw	r24, 0x00	; 0
    3ec4:	a1 f0       	breq	.+40     	; 0x3eee <xStreamBufferReceiveFromISR+0xd2>
    3ec6:	e8 85       	ldd	r30, Y+8	; 0x08
    3ec8:	f9 85       	ldd	r31, Y+9	; 0x09
    3eca:	82 85       	ldd	r24, Z+10	; 0x0a
    3ecc:	93 85       	ldd	r25, Z+11	; 0x0b
    3ece:	e8 89       	ldd	r30, Y+16	; 0x10
    3ed0:	f9 89       	ldd	r31, Y+17	; 0x11
    3ed2:	40 e0       	ldi	r20, 0x00	; 0
    3ed4:	50 e0       	ldi	r21, 0x00	; 0
    3ed6:	60 e0       	ldi	r22, 0x00	; 0
    3ed8:	70 e0       	ldi	r23, 0x00	; 0
    3eda:	20 e0       	ldi	r18, 0x00	; 0
    3edc:	00 e0       	ldi	r16, 0x00	; 0
    3ede:	10 e0       	ldi	r17, 0x00	; 0
    3ee0:	7f 01       	movw	r14, r30
    3ee2:	0e 94 72 2d 	call	0x5ae4	; 0x5ae4 <xTaskGenericNotifyFromISR>
    3ee6:	e8 85       	ldd	r30, Y+8	; 0x08
    3ee8:	f9 85       	ldd	r31, Y+9	; 0x09
    3eea:	13 86       	std	Z+11, r1	; 0x0b
    3eec:	12 86       	std	Z+10, r1	; 0x0a
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
    3eee:	8e 81       	ldd	r24, Y+6	; 0x06
    3ef0:	9f 81       	ldd	r25, Y+7	; 0x07
}
    3ef2:	61 96       	adiw	r28, 0x11	; 17
    3ef4:	0f b6       	in	r0, 0x3f	; 63
    3ef6:	f8 94       	cli
    3ef8:	de bf       	out	0x3e, r29	; 62
    3efa:	0f be       	out	0x3f, r0	; 63
    3efc:	cd bf       	out	0x3d, r28	; 61
    3efe:	cf 91       	pop	r28
    3f00:	df 91       	pop	r29
    3f02:	1f 91       	pop	r17
    3f04:	0f 91       	pop	r16
    3f06:	ff 90       	pop	r15
    3f08:	ef 90       	pop	r14
    3f0a:	08 95       	ret

00003f0c <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
    3f0c:	0f 93       	push	r16
    3f0e:	1f 93       	push	r17
    3f10:	df 93       	push	r29
    3f12:	cf 93       	push	r28
    3f14:	cd b7       	in	r28, 0x3d	; 61
    3f16:	de b7       	in	r29, 0x3e	; 62
    3f18:	62 97       	sbiw	r28, 0x12	; 18
    3f1a:	0f b6       	in	r0, 0x3f	; 63
    3f1c:	f8 94       	cli
    3f1e:	de bf       	out	0x3e, r29	; 62
    3f20:	0f be       	out	0x3f, r0	; 63
    3f22:	cd bf       	out	0x3d, r28	; 61
    3f24:	9a 87       	std	Y+10, r25	; 0x0a
    3f26:	89 87       	std	Y+9, r24	; 0x09
    3f28:	7c 87       	std	Y+12, r23	; 0x0c
    3f2a:	6b 87       	std	Y+11, r22	; 0x0b
    3f2c:	5e 87       	std	Y+14, r21	; 0x0e
    3f2e:	4d 87       	std	Y+13, r20	; 0x0d
    3f30:	38 8b       	std	Y+16, r19	; 0x10
    3f32:	2f 87       	std	Y+15, r18	; 0x0f
    3f34:	1a 8b       	std	Y+18, r17	; 0x12
    3f36:	09 8b       	std	Y+17, r16	; 0x11
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
    3f38:	89 89       	ldd	r24, Y+17	; 0x11
    3f3a:	9a 89       	ldd	r25, Y+18	; 0x12
    3f3c:	00 97       	sbiw	r24, 0x00	; 0
    3f3e:	91 f1       	breq	.+100    	; 0x3fa4 <prvReadMessageFromBuffer+0x98>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
    3f40:	e9 85       	ldd	r30, Y+9	; 0x09
    3f42:	fa 85       	ldd	r31, Y+10	; 0x0a
    3f44:	80 81       	ld	r24, Z
    3f46:	91 81       	ldd	r25, Z+1	; 0x01
    3f48:	9e 83       	std	Y+6, r25	; 0x06
    3f4a:	8d 83       	std	Y+5, r24	; 0x05
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    3f4c:	ae 01       	movw	r20, r28
    3f4e:	49 5f       	subi	r20, 0xF9	; 249
    3f50:	5f 4f       	sbci	r21, 0xFF	; 255
    3f52:	89 85       	ldd	r24, Y+9	; 0x09
    3f54:	9a 85       	ldd	r25, Y+10	; 0x0a
    3f56:	29 89       	ldd	r18, Y+17	; 0x11
    3f58:	3a 89       	ldd	r19, Y+18	; 0x12
    3f5a:	ef 85       	ldd	r30, Y+15	; 0x0f
    3f5c:	f8 89       	ldd	r31, Y+16	; 0x10
    3f5e:	ba 01       	movw	r22, r20
    3f60:	a9 01       	movw	r20, r18
    3f62:	9f 01       	movw	r18, r30
    3f64:	0e 94 6a 21 	call	0x42d4	; 0x42d4 <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
    3f68:	8f 81       	ldd	r24, Y+7	; 0x07
    3f6a:	98 85       	ldd	r25, Y+8	; 0x08
    3f6c:	9a 83       	std	Y+2, r25	; 0x02
    3f6e:	89 83       	std	Y+1, r24	; 0x01

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
    3f70:	2f 85       	ldd	r18, Y+15	; 0x0f
    3f72:	38 89       	ldd	r19, Y+16	; 0x10
    3f74:	89 89       	ldd	r24, Y+17	; 0x11
    3f76:	9a 89       	ldd	r25, Y+18	; 0x12
    3f78:	a9 01       	movw	r20, r18
    3f7a:	48 1b       	sub	r20, r24
    3f7c:	59 0b       	sbc	r21, r25
    3f7e:	ca 01       	movw	r24, r20
    3f80:	98 8b       	std	Y+16, r25	; 0x10
    3f82:	8f 87       	std	Y+15, r24	; 0x0f

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
    3f84:	29 81       	ldd	r18, Y+1	; 0x01
    3f86:	3a 81       	ldd	r19, Y+2	; 0x02
    3f88:	8d 85       	ldd	r24, Y+13	; 0x0d
    3f8a:	9e 85       	ldd	r25, Y+14	; 0x0e
    3f8c:	82 17       	cp	r24, r18
    3f8e:	93 07       	cpc	r25, r19
    3f90:	68 f4       	brcc	.+26     	; 0x3fac <prvReadMessageFromBuffer+0xa0>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
    3f92:	e9 85       	ldd	r30, Y+9	; 0x09
    3f94:	fa 85       	ldd	r31, Y+10	; 0x0a
    3f96:	8d 81       	ldd	r24, Y+5	; 0x05
    3f98:	9e 81       	ldd	r25, Y+6	; 0x06
    3f9a:	91 83       	std	Z+1, r25	; 0x01
    3f9c:	80 83       	st	Z, r24
			xNextMessageLength = 0;
    3f9e:	1a 82       	std	Y+2, r1	; 0x02
    3fa0:	19 82       	std	Y+1, r1	; 0x01
    3fa2:	04 c0       	rjmp	.+8      	; 0x3fac <prvReadMessageFromBuffer+0xa0>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
    3fa4:	8d 85       	ldd	r24, Y+13	; 0x0d
    3fa6:	9e 85       	ldd	r25, Y+14	; 0x0e
    3fa8:	9a 83       	std	Y+2, r25	; 0x02
    3faa:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    3fac:	4b 85       	ldd	r20, Y+11	; 0x0b
    3fae:	5c 85       	ldd	r21, Y+12	; 0x0c
    3fb0:	89 85       	ldd	r24, Y+9	; 0x09
    3fb2:	9a 85       	ldd	r25, Y+10	; 0x0a
    3fb4:	29 81       	ldd	r18, Y+1	; 0x01
    3fb6:	3a 81       	ldd	r19, Y+2	; 0x02
    3fb8:	ef 85       	ldd	r30, Y+15	; 0x0f
    3fba:	f8 89       	ldd	r31, Y+16	; 0x10
    3fbc:	ba 01       	movw	r22, r20
    3fbe:	a9 01       	movw	r20, r18
    3fc0:	9f 01       	movw	r18, r30
    3fc2:	0e 94 6a 21 	call	0x42d4	; 0x42d4 <prvReadBytesFromBuffer>
    3fc6:	9c 83       	std	Y+4, r25	; 0x04
    3fc8:	8b 83       	std	Y+3, r24	; 0x03

	return xReceivedLength;
    3fca:	8b 81       	ldd	r24, Y+3	; 0x03
    3fcc:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3fce:	62 96       	adiw	r28, 0x12	; 18
    3fd0:	0f b6       	in	r0, 0x3f	; 63
    3fd2:	f8 94       	cli
    3fd4:	de bf       	out	0x3e, r29	; 62
    3fd6:	0f be       	out	0x3f, r0	; 63
    3fd8:	cd bf       	out	0x3d, r28	; 61
    3fda:	cf 91       	pop	r28
    3fdc:	df 91       	pop	r29
    3fde:	1f 91       	pop	r17
    3fe0:	0f 91       	pop	r16
    3fe2:	08 95       	ret

00003fe4 <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    3fe4:	df 93       	push	r29
    3fe6:	cf 93       	push	r28
    3fe8:	cd b7       	in	r28, 0x3d	; 61
    3fea:	de b7       	in	r29, 0x3e	; 62
    3fec:	27 97       	sbiw	r28, 0x07	; 7
    3fee:	0f b6       	in	r0, 0x3f	; 63
    3ff0:	f8 94       	cli
    3ff2:	de bf       	out	0x3e, r29	; 62
    3ff4:	0f be       	out	0x3f, r0	; 63
    3ff6:	cd bf       	out	0x3d, r28	; 61
    3ff8:	9f 83       	std	Y+7, r25	; 0x07
    3ffa:	8e 83       	std	Y+6, r24	; 0x06
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3ffc:	8e 81       	ldd	r24, Y+6	; 0x06
    3ffe:	9f 81       	ldd	r25, Y+7	; 0x07
    4000:	9d 83       	std	Y+5, r25	; 0x05
    4002:	8c 83       	std	Y+4, r24	; 0x04
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
    4004:	ec 81       	ldd	r30, Y+4	; 0x04
    4006:	fd 81       	ldd	r31, Y+5	; 0x05
    4008:	80 81       	ld	r24, Z
    400a:	91 81       	ldd	r25, Z+1	; 0x01
    400c:	9a 83       	std	Y+2, r25	; 0x02
    400e:	89 83       	std	Y+1, r24	; 0x01
	if( pxStreamBuffer->xHead == xTail )
    4010:	ec 81       	ldd	r30, Y+4	; 0x04
    4012:	fd 81       	ldd	r31, Y+5	; 0x05
    4014:	22 81       	ldd	r18, Z+2	; 0x02
    4016:	33 81       	ldd	r19, Z+3	; 0x03
    4018:	89 81       	ldd	r24, Y+1	; 0x01
    401a:	9a 81       	ldd	r25, Y+2	; 0x02
    401c:	28 17       	cp	r18, r24
    401e:	39 07       	cpc	r19, r25
    4020:	19 f4       	brne	.+6      	; 0x4028 <xStreamBufferIsEmpty+0x44>
	{
		xReturn = pdTRUE;
    4022:	81 e0       	ldi	r24, 0x01	; 1
    4024:	8b 83       	std	Y+3, r24	; 0x03
    4026:	01 c0       	rjmp	.+2      	; 0x402a <xStreamBufferIsEmpty+0x46>
	}
	else
	{
		xReturn = pdFALSE;
    4028:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    402a:	8b 81       	ldd	r24, Y+3	; 0x03
}
    402c:	27 96       	adiw	r28, 0x07	; 7
    402e:	0f b6       	in	r0, 0x3f	; 63
    4030:	f8 94       	cli
    4032:	de bf       	out	0x3e, r29	; 62
    4034:	0f be       	out	0x3f, r0	; 63
    4036:	cd bf       	out	0x3d, r28	; 61
    4038:	cf 91       	pop	r28
    403a:	df 91       	pop	r29
    403c:	08 95       	ret

0000403e <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    403e:	df 93       	push	r29
    4040:	cf 93       	push	r28
    4042:	cd b7       	in	r28, 0x3d	; 61
    4044:	de b7       	in	r29, 0x3e	; 62
    4046:	27 97       	sbiw	r28, 0x07	; 7
    4048:	0f b6       	in	r0, 0x3f	; 63
    404a:	f8 94       	cli
    404c:	de bf       	out	0x3e, r29	; 62
    404e:	0f be       	out	0x3f, r0	; 63
    4050:	cd bf       	out	0x3d, r28	; 61
    4052:	9f 83       	std	Y+7, r25	; 0x07
    4054:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4056:	8e 81       	ldd	r24, Y+6	; 0x06
    4058:	9f 81       	ldd	r25, Y+7	; 0x07
    405a:	9a 83       	std	Y+2, r25	; 0x02
    405c:	89 83       	std	Y+1, r24	; 0x01

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    405e:	e9 81       	ldd	r30, Y+1	; 0x01
    4060:	fa 81       	ldd	r31, Y+2	; 0x02
    4062:	86 85       	ldd	r24, Z+14	; 0x0e
    4064:	88 2f       	mov	r24, r24
    4066:	90 e0       	ldi	r25, 0x00	; 0
    4068:	81 70       	andi	r24, 0x01	; 1
    406a:	90 70       	andi	r25, 0x00	; 0
    406c:	88 23       	and	r24, r24
    406e:	29 f0       	breq	.+10     	; 0x407a <xStreamBufferIsFull+0x3c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    4070:	82 e0       	ldi	r24, 0x02	; 2
    4072:	90 e0       	ldi	r25, 0x00	; 0
    4074:	9c 83       	std	Y+4, r25	; 0x04
    4076:	8b 83       	std	Y+3, r24	; 0x03
    4078:	02 c0       	rjmp	.+4      	; 0x407e <xStreamBufferIsFull+0x40>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    407a:	1c 82       	std	Y+4, r1	; 0x04
    407c:	1b 82       	std	Y+3, r1	; 0x03
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    407e:	8e 81       	ldd	r24, Y+6	; 0x06
    4080:	9f 81       	ldd	r25, Y+7	; 0x07
    4082:	0e 94 e7 1b 	call	0x37ce	; 0x37ce <xStreamBufferSpacesAvailable>
    4086:	9c 01       	movw	r18, r24
    4088:	8b 81       	ldd	r24, Y+3	; 0x03
    408a:	9c 81       	ldd	r25, Y+4	; 0x04
    408c:	82 17       	cp	r24, r18
    408e:	93 07       	cpc	r25, r19
    4090:	18 f0       	brcs	.+6      	; 0x4098 <xStreamBufferIsFull+0x5a>
	{
		xReturn = pdTRUE;
    4092:	81 e0       	ldi	r24, 0x01	; 1
    4094:	8d 83       	std	Y+5, r24	; 0x05
    4096:	01 c0       	rjmp	.+2      	; 0x409a <xStreamBufferIsFull+0x5c>
	}
	else
	{
		xReturn = pdFALSE;
    4098:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    409a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    409c:	27 96       	adiw	r28, 0x07	; 7
    409e:	0f b6       	in	r0, 0x3f	; 63
    40a0:	f8 94       	cli
    40a2:	de bf       	out	0x3e, r29	; 62
    40a4:	0f be       	out	0x3f, r0	; 63
    40a6:	cd bf       	out	0x3d, r28	; 61
    40a8:	cf 91       	pop	r28
    40aa:	df 91       	pop	r29
    40ac:	08 95       	ret

000040ae <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    40ae:	ef 92       	push	r14
    40b0:	ff 92       	push	r15
    40b2:	0f 93       	push	r16
    40b4:	1f 93       	push	r17
    40b6:	df 93       	push	r29
    40b8:	cf 93       	push	r28
    40ba:	cd b7       	in	r28, 0x3d	; 61
    40bc:	de b7       	in	r29, 0x3e	; 62
    40be:	28 97       	sbiw	r28, 0x08	; 8
    40c0:	0f b6       	in	r0, 0x3f	; 63
    40c2:	f8 94       	cli
    40c4:	de bf       	out	0x3e, r29	; 62
    40c6:	0f be       	out	0x3f, r0	; 63
    40c8:	cd bf       	out	0x3d, r28	; 61
    40ca:	9e 83       	std	Y+6, r25	; 0x06
    40cc:	8d 83       	std	Y+5, r24	; 0x05
    40ce:	78 87       	std	Y+8, r23	; 0x08
    40d0:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    40d2:	8d 81       	ldd	r24, Y+5	; 0x05
    40d4:	9e 81       	ldd	r25, Y+6	; 0x06
    40d6:	9c 83       	std	Y+4, r25	; 0x04
    40d8:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    40da:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    40dc:	eb 81       	ldd	r30, Y+3	; 0x03
    40de:	fc 81       	ldd	r31, Y+4	; 0x04
    40e0:	80 85       	ldd	r24, Z+8	; 0x08
    40e2:	91 85       	ldd	r25, Z+9	; 0x09
    40e4:	00 97       	sbiw	r24, 0x00	; 0
    40e6:	b9 f0       	breq	.+46     	; 0x4116 <xStreamBufferSendCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    40e8:	eb 81       	ldd	r30, Y+3	; 0x03
    40ea:	fc 81       	ldd	r31, Y+4	; 0x04
    40ec:	80 85       	ldd	r24, Z+8	; 0x08
    40ee:	91 85       	ldd	r25, Z+9	; 0x09
    40f0:	ef 81       	ldd	r30, Y+7	; 0x07
    40f2:	f8 85       	ldd	r31, Y+8	; 0x08
    40f4:	40 e0       	ldi	r20, 0x00	; 0
    40f6:	50 e0       	ldi	r21, 0x00	; 0
    40f8:	60 e0       	ldi	r22, 0x00	; 0
    40fa:	70 e0       	ldi	r23, 0x00	; 0
    40fc:	20 e0       	ldi	r18, 0x00	; 0
    40fe:	00 e0       	ldi	r16, 0x00	; 0
    4100:	10 e0       	ldi	r17, 0x00	; 0
    4102:	7f 01       	movw	r14, r30
    4104:	0e 94 72 2d 	call	0x5ae4	; 0x5ae4 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    4108:	eb 81       	ldd	r30, Y+3	; 0x03
    410a:	fc 81       	ldd	r31, Y+4	; 0x04
    410c:	11 86       	std	Z+9, r1	; 0x09
    410e:	10 86       	std	Z+8, r1	; 0x08
			xReturn = pdTRUE;
    4110:	81 e0       	ldi	r24, 0x01	; 1
    4112:	8a 83       	std	Y+2, r24	; 0x02
    4114:	01 c0       	rjmp	.+2      	; 0x4118 <xStreamBufferSendCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    4116:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4118:	8a 81       	ldd	r24, Y+2	; 0x02
}
    411a:	28 96       	adiw	r28, 0x08	; 8
    411c:	0f b6       	in	r0, 0x3f	; 63
    411e:	f8 94       	cli
    4120:	de bf       	out	0x3e, r29	; 62
    4122:	0f be       	out	0x3f, r0	; 63
    4124:	cd bf       	out	0x3d, r28	; 61
    4126:	cf 91       	pop	r28
    4128:	df 91       	pop	r29
    412a:	1f 91       	pop	r17
    412c:	0f 91       	pop	r16
    412e:	ff 90       	pop	r15
    4130:	ef 90       	pop	r14
    4132:	08 95       	ret

00004134 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    4134:	ef 92       	push	r14
    4136:	ff 92       	push	r15
    4138:	0f 93       	push	r16
    413a:	1f 93       	push	r17
    413c:	df 93       	push	r29
    413e:	cf 93       	push	r28
    4140:	cd b7       	in	r28, 0x3d	; 61
    4142:	de b7       	in	r29, 0x3e	; 62
    4144:	28 97       	sbiw	r28, 0x08	; 8
    4146:	0f b6       	in	r0, 0x3f	; 63
    4148:	f8 94       	cli
    414a:	de bf       	out	0x3e, r29	; 62
    414c:	0f be       	out	0x3f, r0	; 63
    414e:	cd bf       	out	0x3d, r28	; 61
    4150:	9e 83       	std	Y+6, r25	; 0x06
    4152:	8d 83       	std	Y+5, r24	; 0x05
    4154:	78 87       	std	Y+8, r23	; 0x08
    4156:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4158:	8d 81       	ldd	r24, Y+5	; 0x05
    415a:	9e 81       	ldd	r25, Y+6	; 0x06
    415c:	9c 83       	std	Y+4, r25	; 0x04
    415e:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    4160:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    4162:	eb 81       	ldd	r30, Y+3	; 0x03
    4164:	fc 81       	ldd	r31, Y+4	; 0x04
    4166:	82 85       	ldd	r24, Z+10	; 0x0a
    4168:	93 85       	ldd	r25, Z+11	; 0x0b
    416a:	00 97       	sbiw	r24, 0x00	; 0
    416c:	b9 f0       	breq	.+46     	; 0x419c <xStreamBufferReceiveCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    416e:	eb 81       	ldd	r30, Y+3	; 0x03
    4170:	fc 81       	ldd	r31, Y+4	; 0x04
    4172:	82 85       	ldd	r24, Z+10	; 0x0a
    4174:	93 85       	ldd	r25, Z+11	; 0x0b
    4176:	ef 81       	ldd	r30, Y+7	; 0x07
    4178:	f8 85       	ldd	r31, Y+8	; 0x08
    417a:	40 e0       	ldi	r20, 0x00	; 0
    417c:	50 e0       	ldi	r21, 0x00	; 0
    417e:	60 e0       	ldi	r22, 0x00	; 0
    4180:	70 e0       	ldi	r23, 0x00	; 0
    4182:	20 e0       	ldi	r18, 0x00	; 0
    4184:	00 e0       	ldi	r16, 0x00	; 0
    4186:	10 e0       	ldi	r17, 0x00	; 0
    4188:	7f 01       	movw	r14, r30
    418a:	0e 94 72 2d 	call	0x5ae4	; 0x5ae4 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    418e:	eb 81       	ldd	r30, Y+3	; 0x03
    4190:	fc 81       	ldd	r31, Y+4	; 0x04
    4192:	13 86       	std	Z+11, r1	; 0x0b
    4194:	12 86       	std	Z+10, r1	; 0x0a
			xReturn = pdTRUE;
    4196:	81 e0       	ldi	r24, 0x01	; 1
    4198:	8a 83       	std	Y+2, r24	; 0x02
    419a:	01 c0       	rjmp	.+2      	; 0x419e <xStreamBufferReceiveCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    419c:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    419e:	8a 81       	ldd	r24, Y+2	; 0x02
}
    41a0:	28 96       	adiw	r28, 0x08	; 8
    41a2:	0f b6       	in	r0, 0x3f	; 63
    41a4:	f8 94       	cli
    41a6:	de bf       	out	0x3e, r29	; 62
    41a8:	0f be       	out	0x3f, r0	; 63
    41aa:	cd bf       	out	0x3d, r28	; 61
    41ac:	cf 91       	pop	r28
    41ae:	df 91       	pop	r29
    41b0:	1f 91       	pop	r17
    41b2:	0f 91       	pop	r16
    41b4:	ff 90       	pop	r15
    41b6:	ef 90       	pop	r14
    41b8:	08 95       	ret

000041ba <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
    41ba:	df 93       	push	r29
    41bc:	cf 93       	push	r28
    41be:	cd b7       	in	r28, 0x3d	; 61
    41c0:	de b7       	in	r29, 0x3e	; 62
    41c2:	2e 97       	sbiw	r28, 0x0e	; 14
    41c4:	0f b6       	in	r0, 0x3f	; 63
    41c6:	f8 94       	cli
    41c8:	de bf       	out	0x3e, r29	; 62
    41ca:	0f be       	out	0x3f, r0	; 63
    41cc:	cd bf       	out	0x3d, r28	; 61
    41ce:	9e 83       	std	Y+6, r25	; 0x06
    41d0:	8d 83       	std	Y+5, r24	; 0x05
    41d2:	78 87       	std	Y+8, r23	; 0x08
    41d4:	6f 83       	std	Y+7, r22	; 0x07
    41d6:	5a 87       	std	Y+10, r21	; 0x0a
    41d8:	49 87       	std	Y+9, r20	; 0x09
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
    41da:	ed 81       	ldd	r30, Y+5	; 0x05
    41dc:	fe 81       	ldd	r31, Y+6	; 0x06
    41de:	82 81       	ldd	r24, Z+2	; 0x02
    41e0:	93 81       	ldd	r25, Z+3	; 0x03
    41e2:	9c 83       	std	Y+4, r25	; 0x04
    41e4:	8b 83       	std	Y+3, r24	; 0x03

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
    41e6:	ed 81       	ldd	r30, Y+5	; 0x05
    41e8:	fe 81       	ldd	r31, Y+6	; 0x06
    41ea:	24 81       	ldd	r18, Z+4	; 0x04
    41ec:	35 81       	ldd	r19, Z+5	; 0x05
    41ee:	8b 81       	ldd	r24, Y+3	; 0x03
    41f0:	9c 81       	ldd	r25, Y+4	; 0x04
    41f2:	a9 01       	movw	r20, r18
    41f4:	48 1b       	sub	r20, r24
    41f6:	59 0b       	sbc	r21, r25
    41f8:	ca 01       	movw	r24, r20
    41fa:	29 85       	ldd	r18, Y+9	; 0x09
    41fc:	3a 85       	ldd	r19, Y+10	; 0x0a
    41fe:	3e 87       	std	Y+14, r19	; 0x0e
    4200:	2d 87       	std	Y+13, r18	; 0x0d
    4202:	9c 87       	std	Y+12, r25	; 0x0c
    4204:	8b 87       	std	Y+11, r24	; 0x0b
    4206:	4b 85       	ldd	r20, Y+11	; 0x0b
    4208:	5c 85       	ldd	r21, Y+12	; 0x0c
    420a:	8d 85       	ldd	r24, Y+13	; 0x0d
    420c:	9e 85       	ldd	r25, Y+14	; 0x0e
    420e:	84 17       	cp	r24, r20
    4210:	95 07       	cpc	r25, r21
    4212:	20 f4       	brcc	.+8      	; 0x421c <prvWriteBytesToBuffer+0x62>
    4214:	2d 85       	ldd	r18, Y+13	; 0x0d
    4216:	3e 85       	ldd	r19, Y+14	; 0x0e
    4218:	3c 87       	std	Y+12, r19	; 0x0c
    421a:	2b 87       	std	Y+11, r18	; 0x0b
    421c:	4b 85       	ldd	r20, Y+11	; 0x0b
    421e:	5c 85       	ldd	r21, Y+12	; 0x0c
    4220:	5a 83       	std	Y+2, r21	; 0x02
    4222:	49 83       	std	Y+1, r20	; 0x01

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    4224:	ed 81       	ldd	r30, Y+5	; 0x05
    4226:	fe 81       	ldd	r31, Y+6	; 0x06
    4228:	24 85       	ldd	r18, Z+12	; 0x0c
    422a:	35 85       	ldd	r19, Z+13	; 0x0d
    422c:	8b 81       	ldd	r24, Y+3	; 0x03
    422e:	9c 81       	ldd	r25, Y+4	; 0x04
    4230:	82 0f       	add	r24, r18
    4232:	93 1f       	adc	r25, r19
    4234:	2f 81       	ldd	r18, Y+7	; 0x07
    4236:	38 85       	ldd	r19, Y+8	; 0x08
    4238:	49 81       	ldd	r20, Y+1	; 0x01
    423a:	5a 81       	ldd	r21, Y+2	; 0x02
    423c:	b9 01       	movw	r22, r18
    423e:	0e 94 a6 2f 	call	0x5f4c	; 0x5f4c <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
    4242:	29 85       	ldd	r18, Y+9	; 0x09
    4244:	3a 85       	ldd	r19, Y+10	; 0x0a
    4246:	89 81       	ldd	r24, Y+1	; 0x01
    4248:	9a 81       	ldd	r25, Y+2	; 0x02
    424a:	82 17       	cp	r24, r18
    424c:	93 07       	cpc	r25, r19
    424e:	b0 f4       	brcc	.+44     	; 0x427c <prvWriteBytesToBuffer+0xc2>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    4250:	ed 81       	ldd	r30, Y+5	; 0x05
    4252:	fe 81       	ldd	r31, Y+6	; 0x06
    4254:	64 85       	ldd	r22, Z+12	; 0x0c
    4256:	75 85       	ldd	r23, Z+13	; 0x0d
    4258:	2f 81       	ldd	r18, Y+7	; 0x07
    425a:	38 85       	ldd	r19, Y+8	; 0x08
    425c:	89 81       	ldd	r24, Y+1	; 0x01
    425e:	9a 81       	ldd	r25, Y+2	; 0x02
    4260:	a9 01       	movw	r20, r18
    4262:	48 0f       	add	r20, r24
    4264:	59 1f       	adc	r21, r25
    4266:	29 85       	ldd	r18, Y+9	; 0x09
    4268:	3a 85       	ldd	r19, Y+10	; 0x0a
    426a:	89 81       	ldd	r24, Y+1	; 0x01
    426c:	9a 81       	ldd	r25, Y+2	; 0x02
    426e:	28 1b       	sub	r18, r24
    4270:	39 0b       	sbc	r19, r25
    4272:	cb 01       	movw	r24, r22
    4274:	ba 01       	movw	r22, r20
    4276:	a9 01       	movw	r20, r18
    4278:	0e 94 a6 2f 	call	0x5f4c	; 0x5f4c <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
    427c:	2b 81       	ldd	r18, Y+3	; 0x03
    427e:	3c 81       	ldd	r19, Y+4	; 0x04
    4280:	89 85       	ldd	r24, Y+9	; 0x09
    4282:	9a 85       	ldd	r25, Y+10	; 0x0a
    4284:	82 0f       	add	r24, r18
    4286:	93 1f       	adc	r25, r19
    4288:	9c 83       	std	Y+4, r25	; 0x04
    428a:	8b 83       	std	Y+3, r24	; 0x03
	if( xNextHead >= pxStreamBuffer->xLength )
    428c:	ed 81       	ldd	r30, Y+5	; 0x05
    428e:	fe 81       	ldd	r31, Y+6	; 0x06
    4290:	24 81       	ldd	r18, Z+4	; 0x04
    4292:	35 81       	ldd	r19, Z+5	; 0x05
    4294:	8b 81       	ldd	r24, Y+3	; 0x03
    4296:	9c 81       	ldd	r25, Y+4	; 0x04
    4298:	82 17       	cp	r24, r18
    429a:	93 07       	cpc	r25, r19
    429c:	50 f0       	brcs	.+20     	; 0x42b2 <prvWriteBytesToBuffer+0xf8>
	{
		xNextHead -= pxStreamBuffer->xLength;
    429e:	ed 81       	ldd	r30, Y+5	; 0x05
    42a0:	fe 81       	ldd	r31, Y+6	; 0x06
    42a2:	24 81       	ldd	r18, Z+4	; 0x04
    42a4:	35 81       	ldd	r19, Z+5	; 0x05
    42a6:	8b 81       	ldd	r24, Y+3	; 0x03
    42a8:	9c 81       	ldd	r25, Y+4	; 0x04
    42aa:	82 1b       	sub	r24, r18
    42ac:	93 0b       	sbc	r25, r19
    42ae:	9c 83       	std	Y+4, r25	; 0x04
    42b0:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
    42b2:	ed 81       	ldd	r30, Y+5	; 0x05
    42b4:	fe 81       	ldd	r31, Y+6	; 0x06
    42b6:	8b 81       	ldd	r24, Y+3	; 0x03
    42b8:	9c 81       	ldd	r25, Y+4	; 0x04
    42ba:	93 83       	std	Z+3, r25	; 0x03
    42bc:	82 83       	std	Z+2, r24	; 0x02

	return xCount;
    42be:	89 85       	ldd	r24, Y+9	; 0x09
    42c0:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    42c2:	2e 96       	adiw	r28, 0x0e	; 14
    42c4:	0f b6       	in	r0, 0x3f	; 63
    42c6:	f8 94       	cli
    42c8:	de bf       	out	0x3e, r29	; 62
    42ca:	0f be       	out	0x3f, r0	; 63
    42cc:	cd bf       	out	0x3d, r28	; 61
    42ce:	cf 91       	pop	r28
    42d0:	df 91       	pop	r29
    42d2:	08 95       	ret

000042d4 <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
    42d4:	df 93       	push	r29
    42d6:	cf 93       	push	r28
    42d8:	cd b7       	in	r28, 0x3d	; 61
    42da:	de b7       	in	r29, 0x3e	; 62
    42dc:	66 97       	sbiw	r28, 0x16	; 22
    42de:	0f b6       	in	r0, 0x3f	; 63
    42e0:	f8 94       	cli
    42e2:	de bf       	out	0x3e, r29	; 62
    42e4:	0f be       	out	0x3f, r0	; 63
    42e6:	cd bf       	out	0x3d, r28	; 61
    42e8:	98 87       	std	Y+8, r25	; 0x08
    42ea:	8f 83       	std	Y+7, r24	; 0x07
    42ec:	7a 87       	std	Y+10, r23	; 0x0a
    42ee:	69 87       	std	Y+9, r22	; 0x09
    42f0:	5c 87       	std	Y+12, r21	; 0x0c
    42f2:	4b 87       	std	Y+11, r20	; 0x0b
    42f4:	3e 87       	std	Y+14, r19	; 0x0e
    42f6:	2d 87       	std	Y+13, r18	; 0x0d
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
    42f8:	2d 85       	ldd	r18, Y+13	; 0x0d
    42fa:	3e 85       	ldd	r19, Y+14	; 0x0e
    42fc:	3a 8b       	std	Y+18, r19	; 0x12
    42fe:	29 8b       	std	Y+17, r18	; 0x11
    4300:	4b 85       	ldd	r20, Y+11	; 0x0b
    4302:	5c 85       	ldd	r21, Y+12	; 0x0c
    4304:	58 8b       	std	Y+16, r21	; 0x10
    4306:	4f 87       	std	Y+15, r20	; 0x0f
    4308:	8f 85       	ldd	r24, Y+15	; 0x0f
    430a:	98 89       	ldd	r25, Y+16	; 0x10
    430c:	29 89       	ldd	r18, Y+17	; 0x11
    430e:	3a 89       	ldd	r19, Y+18	; 0x12
    4310:	28 17       	cp	r18, r24
    4312:	39 07       	cpc	r19, r25
    4314:	20 f4       	brcc	.+8      	; 0x431e <prvReadBytesFromBuffer+0x4a>
    4316:	49 89       	ldd	r20, Y+17	; 0x11
    4318:	5a 89       	ldd	r21, Y+18	; 0x12
    431a:	58 8b       	std	Y+16, r21	; 0x10
    431c:	4f 87       	std	Y+15, r20	; 0x0f
    431e:	8f 85       	ldd	r24, Y+15	; 0x0f
    4320:	98 89       	ldd	r25, Y+16	; 0x10
    4322:	9e 83       	std	Y+6, r25	; 0x06
    4324:	8d 83       	std	Y+5, r24	; 0x05

	if( xCount > ( size_t ) 0 )
    4326:	8d 81       	ldd	r24, Y+5	; 0x05
    4328:	9e 81       	ldd	r25, Y+6	; 0x06
    432a:	00 97       	sbiw	r24, 0x00	; 0
    432c:	09 f4       	brne	.+2      	; 0x4330 <prvReadBytesFromBuffer+0x5c>
    432e:	74 c0       	rjmp	.+232    	; 0x4418 <prvReadBytesFromBuffer+0x144>
	{
		xNextTail = pxStreamBuffer->xTail;
    4330:	ef 81       	ldd	r30, Y+7	; 0x07
    4332:	f8 85       	ldd	r31, Y+8	; 0x08
    4334:	80 81       	ld	r24, Z
    4336:	91 81       	ldd	r25, Z+1	; 0x01
    4338:	9a 83       	std	Y+2, r25	; 0x02
    433a:	89 83       	std	Y+1, r24	; 0x01

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
    433c:	ef 81       	ldd	r30, Y+7	; 0x07
    433e:	f8 85       	ldd	r31, Y+8	; 0x08
    4340:	24 81       	ldd	r18, Z+4	; 0x04
    4342:	35 81       	ldd	r19, Z+5	; 0x05
    4344:	89 81       	ldd	r24, Y+1	; 0x01
    4346:	9a 81       	ldd	r25, Y+2	; 0x02
    4348:	a9 01       	movw	r20, r18
    434a:	48 1b       	sub	r20, r24
    434c:	59 0b       	sbc	r21, r25
    434e:	ca 01       	movw	r24, r20
    4350:	2d 81       	ldd	r18, Y+5	; 0x05
    4352:	3e 81       	ldd	r19, Y+6	; 0x06
    4354:	3e 8b       	std	Y+22, r19	; 0x16
    4356:	2d 8b       	std	Y+21, r18	; 0x15
    4358:	9c 8b       	std	Y+20, r25	; 0x14
    435a:	8b 8b       	std	Y+19, r24	; 0x13
    435c:	4b 89       	ldd	r20, Y+19	; 0x13
    435e:	5c 89       	ldd	r21, Y+20	; 0x14
    4360:	8d 89       	ldd	r24, Y+21	; 0x15
    4362:	9e 89       	ldd	r25, Y+22	; 0x16
    4364:	84 17       	cp	r24, r20
    4366:	95 07       	cpc	r25, r21
    4368:	20 f4       	brcc	.+8      	; 0x4372 <prvReadBytesFromBuffer+0x9e>
    436a:	2d 89       	ldd	r18, Y+21	; 0x15
    436c:	3e 89       	ldd	r19, Y+22	; 0x16
    436e:	3c 8b       	std	Y+20, r19	; 0x14
    4370:	2b 8b       	std	Y+19, r18	; 0x13
    4372:	4b 89       	ldd	r20, Y+19	; 0x13
    4374:	5c 89       	ldd	r21, Y+20	; 0x14
    4376:	5c 83       	std	Y+4, r21	; 0x04
    4378:	4b 83       	std	Y+3, r20	; 0x03

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    437a:	ef 81       	ldd	r30, Y+7	; 0x07
    437c:	f8 85       	ldd	r31, Y+8	; 0x08
    437e:	24 85       	ldd	r18, Z+12	; 0x0c
    4380:	35 85       	ldd	r19, Z+13	; 0x0d
    4382:	89 81       	ldd	r24, Y+1	; 0x01
    4384:	9a 81       	ldd	r25, Y+2	; 0x02
    4386:	a9 01       	movw	r20, r18
    4388:	48 0f       	add	r20, r24
    438a:	59 1f       	adc	r21, r25
    438c:	89 85       	ldd	r24, Y+9	; 0x09
    438e:	9a 85       	ldd	r25, Y+10	; 0x0a
    4390:	2b 81       	ldd	r18, Y+3	; 0x03
    4392:	3c 81       	ldd	r19, Y+4	; 0x04
    4394:	ba 01       	movw	r22, r20
    4396:	a9 01       	movw	r20, r18
    4398:	0e 94 a6 2f 	call	0x5f4c	; 0x5f4c <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
    439c:	2d 81       	ldd	r18, Y+5	; 0x05
    439e:	3e 81       	ldd	r19, Y+6	; 0x06
    43a0:	8b 81       	ldd	r24, Y+3	; 0x03
    43a2:	9c 81       	ldd	r25, Y+4	; 0x04
    43a4:	82 17       	cp	r24, r18
    43a6:	93 07       	cpc	r25, r19
    43a8:	b0 f4       	brcc	.+44     	; 0x43d6 <prvReadBytesFromBuffer+0x102>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    43aa:	29 85       	ldd	r18, Y+9	; 0x09
    43ac:	3a 85       	ldd	r19, Y+10	; 0x0a
    43ae:	8b 81       	ldd	r24, Y+3	; 0x03
    43b0:	9c 81       	ldd	r25, Y+4	; 0x04
    43b2:	b9 01       	movw	r22, r18
    43b4:	68 0f       	add	r22, r24
    43b6:	79 1f       	adc	r23, r25
    43b8:	ef 81       	ldd	r30, Y+7	; 0x07
    43ba:	f8 85       	ldd	r31, Y+8	; 0x08
    43bc:	44 85       	ldd	r20, Z+12	; 0x0c
    43be:	55 85       	ldd	r21, Z+13	; 0x0d
    43c0:	2d 81       	ldd	r18, Y+5	; 0x05
    43c2:	3e 81       	ldd	r19, Y+6	; 0x06
    43c4:	8b 81       	ldd	r24, Y+3	; 0x03
    43c6:	9c 81       	ldd	r25, Y+4	; 0x04
    43c8:	28 1b       	sub	r18, r24
    43ca:	39 0b       	sbc	r19, r25
    43cc:	cb 01       	movw	r24, r22
    43ce:	ba 01       	movw	r22, r20
    43d0:	a9 01       	movw	r20, r18
    43d2:	0e 94 a6 2f 	call	0x5f4c	; 0x5f4c <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
    43d6:	29 81       	ldd	r18, Y+1	; 0x01
    43d8:	3a 81       	ldd	r19, Y+2	; 0x02
    43da:	8d 81       	ldd	r24, Y+5	; 0x05
    43dc:	9e 81       	ldd	r25, Y+6	; 0x06
    43de:	82 0f       	add	r24, r18
    43e0:	93 1f       	adc	r25, r19
    43e2:	9a 83       	std	Y+2, r25	; 0x02
    43e4:	89 83       	std	Y+1, r24	; 0x01

		if( xNextTail >= pxStreamBuffer->xLength )
    43e6:	ef 81       	ldd	r30, Y+7	; 0x07
    43e8:	f8 85       	ldd	r31, Y+8	; 0x08
    43ea:	24 81       	ldd	r18, Z+4	; 0x04
    43ec:	35 81       	ldd	r19, Z+5	; 0x05
    43ee:	89 81       	ldd	r24, Y+1	; 0x01
    43f0:	9a 81       	ldd	r25, Y+2	; 0x02
    43f2:	82 17       	cp	r24, r18
    43f4:	93 07       	cpc	r25, r19
    43f6:	50 f0       	brcs	.+20     	; 0x440c <prvReadBytesFromBuffer+0x138>
		{
			xNextTail -= pxStreamBuffer->xLength;
    43f8:	ef 81       	ldd	r30, Y+7	; 0x07
    43fa:	f8 85       	ldd	r31, Y+8	; 0x08
    43fc:	24 81       	ldd	r18, Z+4	; 0x04
    43fe:	35 81       	ldd	r19, Z+5	; 0x05
    4400:	89 81       	ldd	r24, Y+1	; 0x01
    4402:	9a 81       	ldd	r25, Y+2	; 0x02
    4404:	82 1b       	sub	r24, r18
    4406:	93 0b       	sbc	r25, r19
    4408:	9a 83       	std	Y+2, r25	; 0x02
    440a:	89 83       	std	Y+1, r24	; 0x01
		}

		pxStreamBuffer->xTail = xNextTail;
    440c:	ef 81       	ldd	r30, Y+7	; 0x07
    440e:	f8 85       	ldd	r31, Y+8	; 0x08
    4410:	89 81       	ldd	r24, Y+1	; 0x01
    4412:	9a 81       	ldd	r25, Y+2	; 0x02
    4414:	91 83       	std	Z+1, r25	; 0x01
    4416:	80 83       	st	Z, r24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    4418:	8d 81       	ldd	r24, Y+5	; 0x05
    441a:	9e 81       	ldd	r25, Y+6	; 0x06
}
    441c:	66 96       	adiw	r28, 0x16	; 22
    441e:	0f b6       	in	r0, 0x3f	; 63
    4420:	f8 94       	cli
    4422:	de bf       	out	0x3e, r29	; 62
    4424:	0f be       	out	0x3f, r0	; 63
    4426:	cd bf       	out	0x3d, r28	; 61
    4428:	cf 91       	pop	r28
    442a:	df 91       	pop	r29
    442c:	08 95       	ret

0000442e <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    442e:	df 93       	push	r29
    4430:	cf 93       	push	r28
    4432:	00 d0       	rcall	.+0      	; 0x4434 <prvBytesInBuffer+0x6>
    4434:	00 d0       	rcall	.+0      	; 0x4436 <prvBytesInBuffer+0x8>
    4436:	cd b7       	in	r28, 0x3d	; 61
    4438:	de b7       	in	r29, 0x3e	; 62
    443a:	9c 83       	std	Y+4, r25	; 0x04
    443c:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    443e:	eb 81       	ldd	r30, Y+3	; 0x03
    4440:	fc 81       	ldd	r31, Y+4	; 0x04
    4442:	24 81       	ldd	r18, Z+4	; 0x04
    4444:	35 81       	ldd	r19, Z+5	; 0x05
    4446:	eb 81       	ldd	r30, Y+3	; 0x03
    4448:	fc 81       	ldd	r31, Y+4	; 0x04
    444a:	82 81       	ldd	r24, Z+2	; 0x02
    444c:	93 81       	ldd	r25, Z+3	; 0x03
    444e:	82 0f       	add	r24, r18
    4450:	93 1f       	adc	r25, r19
    4452:	9a 83       	std	Y+2, r25	; 0x02
    4454:	89 83       	std	Y+1, r24	; 0x01
	xCount -= pxStreamBuffer->xTail;
    4456:	eb 81       	ldd	r30, Y+3	; 0x03
    4458:	fc 81       	ldd	r31, Y+4	; 0x04
    445a:	20 81       	ld	r18, Z
    445c:	31 81       	ldd	r19, Z+1	; 0x01
    445e:	89 81       	ldd	r24, Y+1	; 0x01
    4460:	9a 81       	ldd	r25, Y+2	; 0x02
    4462:	82 1b       	sub	r24, r18
    4464:	93 0b       	sbc	r25, r19
    4466:	9a 83       	std	Y+2, r25	; 0x02
    4468:	89 83       	std	Y+1, r24	; 0x01
	if ( xCount >= pxStreamBuffer->xLength )
    446a:	eb 81       	ldd	r30, Y+3	; 0x03
    446c:	fc 81       	ldd	r31, Y+4	; 0x04
    446e:	24 81       	ldd	r18, Z+4	; 0x04
    4470:	35 81       	ldd	r19, Z+5	; 0x05
    4472:	89 81       	ldd	r24, Y+1	; 0x01
    4474:	9a 81       	ldd	r25, Y+2	; 0x02
    4476:	82 17       	cp	r24, r18
    4478:	93 07       	cpc	r25, r19
    447a:	50 f0       	brcs	.+20     	; 0x4490 <prvBytesInBuffer+0x62>
	{
		xCount -= pxStreamBuffer->xLength;
    447c:	eb 81       	ldd	r30, Y+3	; 0x03
    447e:	fc 81       	ldd	r31, Y+4	; 0x04
    4480:	24 81       	ldd	r18, Z+4	; 0x04
    4482:	35 81       	ldd	r19, Z+5	; 0x05
    4484:	89 81       	ldd	r24, Y+1	; 0x01
    4486:	9a 81       	ldd	r25, Y+2	; 0x02
    4488:	82 1b       	sub	r24, r18
    448a:	93 0b       	sbc	r25, r19
    448c:	9a 83       	std	Y+2, r25	; 0x02
    448e:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    4490:	89 81       	ldd	r24, Y+1	; 0x01
    4492:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4494:	0f 90       	pop	r0
    4496:	0f 90       	pop	r0
    4498:	0f 90       	pop	r0
    449a:	0f 90       	pop	r0
    449c:	cf 91       	pop	r28
    449e:	df 91       	pop	r29
    44a0:	08 95       	ret

000044a2 <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
    44a2:	0f 93       	push	r16
    44a4:	df 93       	push	r29
    44a6:	cf 93       	push	r28
    44a8:	cd b7       	in	r28, 0x3d	; 61
    44aa:	de b7       	in	r29, 0x3e	; 62
    44ac:	29 97       	sbiw	r28, 0x09	; 9
    44ae:	0f b6       	in	r0, 0x3f	; 63
    44b0:	f8 94       	cli
    44b2:	de bf       	out	0x3e, r29	; 62
    44b4:	0f be       	out	0x3f, r0	; 63
    44b6:	cd bf       	out	0x3d, r28	; 61
    44b8:	9a 83       	std	Y+2, r25	; 0x02
    44ba:	89 83       	std	Y+1, r24	; 0x01
    44bc:	7c 83       	std	Y+4, r23	; 0x04
    44be:	6b 83       	std	Y+3, r22	; 0x03
    44c0:	5e 83       	std	Y+6, r21	; 0x06
    44c2:	4d 83       	std	Y+5, r20	; 0x05
    44c4:	38 87       	std	Y+8, r19	; 0x08
    44c6:	2f 83       	std	Y+7, r18	; 0x07
    44c8:	09 87       	std	Y+9, r16	; 0x09
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    44ca:	89 81       	ldd	r24, Y+1	; 0x01
    44cc:	9a 81       	ldd	r25, Y+2	; 0x02
    44ce:	60 e0       	ldi	r22, 0x00	; 0
    44d0:	70 e0       	ldi	r23, 0x00	; 0
    44d2:	4f e0       	ldi	r20, 0x0F	; 15
    44d4:	50 e0       	ldi	r21, 0x00	; 0
    44d6:	0e 94 af 2f 	call	0x5f5e	; 0x5f5e <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
    44da:	e9 81       	ldd	r30, Y+1	; 0x01
    44dc:	fa 81       	ldd	r31, Y+2	; 0x02
    44de:	8b 81       	ldd	r24, Y+3	; 0x03
    44e0:	9c 81       	ldd	r25, Y+4	; 0x04
    44e2:	95 87       	std	Z+13, r25	; 0x0d
    44e4:	84 87       	std	Z+12, r24	; 0x0c
	pxStreamBuffer->xLength = xBufferSizeBytes;
    44e6:	e9 81       	ldd	r30, Y+1	; 0x01
    44e8:	fa 81       	ldd	r31, Y+2	; 0x02
    44ea:	8d 81       	ldd	r24, Y+5	; 0x05
    44ec:	9e 81       	ldd	r25, Y+6	; 0x06
    44ee:	95 83       	std	Z+5, r25	; 0x05
    44f0:	84 83       	std	Z+4, r24	; 0x04
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    44f2:	e9 81       	ldd	r30, Y+1	; 0x01
    44f4:	fa 81       	ldd	r31, Y+2	; 0x02
    44f6:	8f 81       	ldd	r24, Y+7	; 0x07
    44f8:	98 85       	ldd	r25, Y+8	; 0x08
    44fa:	97 83       	std	Z+7, r25	; 0x07
    44fc:	86 83       	std	Z+6, r24	; 0x06
	pxStreamBuffer->ucFlags = ucFlags;
    44fe:	e9 81       	ldd	r30, Y+1	; 0x01
    4500:	fa 81       	ldd	r31, Y+2	; 0x02
    4502:	89 85       	ldd	r24, Y+9	; 0x09
    4504:	86 87       	std	Z+14, r24	; 0x0e
}
    4506:	29 96       	adiw	r28, 0x09	; 9
    4508:	0f b6       	in	r0, 0x3f	; 63
    450a:	f8 94       	cli
    450c:	de bf       	out	0x3e, r29	; 62
    450e:	0f be       	out	0x3f, r0	; 63
    4510:	cd bf       	out	0x3d, r28	; 61
    4512:	cf 91       	pop	r28
    4514:	df 91       	pop	r29
    4516:	0f 91       	pop	r16
    4518:	08 95       	ret

0000451a <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    451a:	8f 92       	push	r8
    451c:	9f 92       	push	r9
    451e:	af 92       	push	r10
    4520:	bf 92       	push	r11
    4522:	cf 92       	push	r12
    4524:	df 92       	push	r13
    4526:	ef 92       	push	r14
    4528:	ff 92       	push	r15
    452a:	0f 93       	push	r16
    452c:	1f 93       	push	r17
    452e:	df 93       	push	r29
    4530:	cf 93       	push	r28
    4532:	cd b7       	in	r28, 0x3d	; 61
    4534:	de b7       	in	r29, 0x3e	; 62
    4536:	60 97       	sbiw	r28, 0x10	; 16
    4538:	0f b6       	in	r0, 0x3f	; 63
    453a:	f8 94       	cli
    453c:	de bf       	out	0x3e, r29	; 62
    453e:	0f be       	out	0x3f, r0	; 63
    4540:	cd bf       	out	0x3d, r28	; 61
    4542:	9f 83       	std	Y+7, r25	; 0x07
    4544:	8e 83       	std	Y+6, r24	; 0x06
    4546:	79 87       	std	Y+9, r23	; 0x09
    4548:	68 87       	std	Y+8, r22	; 0x08
    454a:	5b 87       	std	Y+11, r21	; 0x0b
    454c:	4a 87       	std	Y+10, r20	; 0x0a
    454e:	3d 87       	std	Y+13, r19	; 0x0d
    4550:	2c 87       	std	Y+12, r18	; 0x0c
    4552:	0e 87       	std	Y+14, r16	; 0x0e
    4554:	f8 8a       	std	Y+16, r15	; 0x10
    4556:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    4558:	8a 85       	ldd	r24, Y+10	; 0x0a
    455a:	9b 85       	ldd	r25, Y+11	; 0x0b
    455c:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <pvPortMalloc>
    4560:	9a 83       	std	Y+2, r25	; 0x02
    4562:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    4564:	89 81       	ldd	r24, Y+1	; 0x01
    4566:	9a 81       	ldd	r25, Y+2	; 0x02
    4568:	00 97       	sbiw	r24, 0x00	; 0
    456a:	b1 f0       	breq	.+44     	; 0x4598 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    456c:	82 e3       	ldi	r24, 0x32	; 50
    456e:	90 e0       	ldi	r25, 0x00	; 0
    4570:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <pvPortMalloc>
    4574:	9d 83       	std	Y+5, r25	; 0x05
    4576:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    4578:	8c 81       	ldd	r24, Y+4	; 0x04
    457a:	9d 81       	ldd	r25, Y+5	; 0x05
    457c:	00 97       	sbiw	r24, 0x00	; 0
    457e:	39 f0       	breq	.+14     	; 0x458e <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    4580:	ec 81       	ldd	r30, Y+4	; 0x04
    4582:	fd 81       	ldd	r31, Y+5	; 0x05
    4584:	89 81       	ldd	r24, Y+1	; 0x01
    4586:	9a 81       	ldd	r25, Y+2	; 0x02
    4588:	90 8f       	std	Z+24, r25	; 0x18
    458a:	87 8b       	std	Z+23, r24	; 0x17
    458c:	07 c0       	rjmp	.+14     	; 0x459c <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    458e:	89 81       	ldd	r24, Y+1	; 0x01
    4590:	9a 81       	ldd	r25, Y+2	; 0x02
    4592:	0e 94 c7 0c 	call	0x198e	; 0x198e <vPortFree>
    4596:	02 c0       	rjmp	.+4      	; 0x459c <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    4598:	1d 82       	std	Y+5, r1	; 0x05
    459a:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    459c:	8c 81       	ldd	r24, Y+4	; 0x04
    459e:	9d 81       	ldd	r25, Y+5	; 0x05
    45a0:	00 97       	sbiw	r24, 0x00	; 0
    45a2:	e9 f0       	breq	.+58     	; 0x45de <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    45a4:	8a 85       	ldd	r24, Y+10	; 0x0a
    45a6:	9b 85       	ldd	r25, Y+11	; 0x0b
    45a8:	9c 01       	movw	r18, r24
    45aa:	40 e0       	ldi	r20, 0x00	; 0
    45ac:	50 e0       	ldi	r21, 0x00	; 0
    45ae:	8e 81       	ldd	r24, Y+6	; 0x06
    45b0:	9f 81       	ldd	r25, Y+7	; 0x07
    45b2:	68 85       	ldd	r22, Y+8	; 0x08
    45b4:	79 85       	ldd	r23, Y+9	; 0x09
    45b6:	ec 85       	ldd	r30, Y+12	; 0x0c
    45b8:	fd 85       	ldd	r31, Y+13	; 0x0d
    45ba:	af 85       	ldd	r26, Y+15	; 0x0f
    45bc:	b8 89       	ldd	r27, Y+16	; 0x10
    45be:	ac 80       	ldd	r10, Y+4	; 0x04
    45c0:	bd 80       	ldd	r11, Y+5	; 0x05
    45c2:	8f 01       	movw	r16, r30
    45c4:	ee 84       	ldd	r14, Y+14	; 0x0e
    45c6:	6d 01       	movw	r12, r26
    45c8:	88 24       	eor	r8, r8
    45ca:	99 24       	eor	r9, r9
    45cc:	0e 94 05 23 	call	0x460a	; 0x460a <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    45d0:	8c 81       	ldd	r24, Y+4	; 0x04
    45d2:	9d 81       	ldd	r25, Y+5	; 0x05
    45d4:	0e 94 c1 23 	call	0x4782	; 0x4782 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    45d8:	81 e0       	ldi	r24, 0x01	; 1
    45da:	8b 83       	std	Y+3, r24	; 0x03
    45dc:	02 c0       	rjmp	.+4      	; 0x45e2 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    45de:	8f ef       	ldi	r24, 0xFF	; 255
    45e0:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    45e2:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    45e4:	60 96       	adiw	r28, 0x10	; 16
    45e6:	0f b6       	in	r0, 0x3f	; 63
    45e8:	f8 94       	cli
    45ea:	de bf       	out	0x3e, r29	; 62
    45ec:	0f be       	out	0x3f, r0	; 63
    45ee:	cd bf       	out	0x3d, r28	; 61
    45f0:	cf 91       	pop	r28
    45f2:	df 91       	pop	r29
    45f4:	1f 91       	pop	r17
    45f6:	0f 91       	pop	r16
    45f8:	ff 90       	pop	r15
    45fa:	ef 90       	pop	r14
    45fc:	df 90       	pop	r13
    45fe:	cf 90       	pop	r12
    4600:	bf 90       	pop	r11
    4602:	af 90       	pop	r10
    4604:	9f 90       	pop	r9
    4606:	8f 90       	pop	r8
    4608:	08 95       	ret

0000460a <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    460a:	8f 92       	push	r8
    460c:	9f 92       	push	r9
    460e:	af 92       	push	r10
    4610:	bf 92       	push	r11
    4612:	cf 92       	push	r12
    4614:	df 92       	push	r13
    4616:	ef 92       	push	r14
    4618:	0f 93       	push	r16
    461a:	1f 93       	push	r17
    461c:	df 93       	push	r29
    461e:	cf 93       	push	r28
    4620:	cd b7       	in	r28, 0x3d	; 61
    4622:	de b7       	in	r29, 0x3e	; 62
    4624:	64 97       	sbiw	r28, 0x14	; 20
    4626:	0f b6       	in	r0, 0x3f	; 63
    4628:	f8 94       	cli
    462a:	de bf       	out	0x3e, r29	; 62
    462c:	0f be       	out	0x3f, r0	; 63
    462e:	cd bf       	out	0x3d, r28	; 61
    4630:	9d 83       	std	Y+5, r25	; 0x05
    4632:	8c 83       	std	Y+4, r24	; 0x04
    4634:	7f 83       	std	Y+7, r23	; 0x07
    4636:	6e 83       	std	Y+6, r22	; 0x06
    4638:	28 87       	std	Y+8, r18	; 0x08
    463a:	39 87       	std	Y+9, r19	; 0x09
    463c:	4a 87       	std	Y+10, r20	; 0x0a
    463e:	5b 87       	std	Y+11, r21	; 0x0b
    4640:	1d 87       	std	Y+13, r17	; 0x0d
    4642:	0c 87       	std	Y+12, r16	; 0x0c
    4644:	ee 86       	std	Y+14, r14	; 0x0e
    4646:	d8 8a       	std	Y+16, r13	; 0x10
    4648:	cf 86       	std	Y+15, r12	; 0x0f
    464a:	ba 8a       	std	Y+18, r11	; 0x12
    464c:	a9 8a       	std	Y+17, r10	; 0x11
    464e:	9c 8a       	std	Y+20, r9	; 0x14
    4650:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    4652:	e9 89       	ldd	r30, Y+17	; 0x11
    4654:	fa 89       	ldd	r31, Y+18	; 0x12
    4656:	27 89       	ldd	r18, Z+23	; 0x17
    4658:	30 8d       	ldd	r19, Z+24	; 0x18
    465a:	88 85       	ldd	r24, Y+8	; 0x08
    465c:	99 85       	ldd	r25, Y+9	; 0x09
    465e:	01 97       	sbiw	r24, 0x01	; 1
    4660:	82 0f       	add	r24, r18
    4662:	93 1f       	adc	r25, r19
    4664:	9b 83       	std	Y+3, r25	; 0x03
    4666:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    4668:	8e 81       	ldd	r24, Y+6	; 0x06
    466a:	9f 81       	ldd	r25, Y+7	; 0x07
    466c:	00 97       	sbiw	r24, 0x00	; 0
    466e:	51 f1       	breq	.+84     	; 0x46c4 <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4670:	19 82       	std	Y+1, r1	; 0x01
    4672:	21 c0       	rjmp	.+66     	; 0x46b6 <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    4674:	89 81       	ldd	r24, Y+1	; 0x01
    4676:	48 2f       	mov	r20, r24
    4678:	50 e0       	ldi	r21, 0x00	; 0
    467a:	89 81       	ldd	r24, Y+1	; 0x01
    467c:	28 2f       	mov	r18, r24
    467e:	30 e0       	ldi	r19, 0x00	; 0
    4680:	8e 81       	ldd	r24, Y+6	; 0x06
    4682:	9f 81       	ldd	r25, Y+7	; 0x07
    4684:	fc 01       	movw	r30, r24
    4686:	e2 0f       	add	r30, r18
    4688:	f3 1f       	adc	r31, r19
    468a:	20 81       	ld	r18, Z
    468c:	89 89       	ldd	r24, Y+17	; 0x11
    468e:	9a 89       	ldd	r25, Y+18	; 0x12
    4690:	84 0f       	add	r24, r20
    4692:	95 1f       	adc	r25, r21
    4694:	fc 01       	movw	r30, r24
    4696:	79 96       	adiw	r30, 0x19	; 25
    4698:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    469a:	89 81       	ldd	r24, Y+1	; 0x01
    469c:	28 2f       	mov	r18, r24
    469e:	30 e0       	ldi	r19, 0x00	; 0
    46a0:	8e 81       	ldd	r24, Y+6	; 0x06
    46a2:	9f 81       	ldd	r25, Y+7	; 0x07
    46a4:	fc 01       	movw	r30, r24
    46a6:	e2 0f       	add	r30, r18
    46a8:	f3 1f       	adc	r31, r19
    46aa:	80 81       	ld	r24, Z
    46ac:	88 23       	and	r24, r24
    46ae:	31 f0       	breq	.+12     	; 0x46bc <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    46b0:	89 81       	ldd	r24, Y+1	; 0x01
    46b2:	8f 5f       	subi	r24, 0xFF	; 255
    46b4:	89 83       	std	Y+1, r24	; 0x01
    46b6:	89 81       	ldd	r24, Y+1	; 0x01
    46b8:	84 31       	cpi	r24, 0x14	; 20
    46ba:	e0 f2       	brcs	.-72     	; 0x4674 <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    46bc:	e9 89       	ldd	r30, Y+17	; 0x11
    46be:	fa 89       	ldd	r31, Y+18	; 0x12
    46c0:	14 a6       	std	Z+44, r1	; 0x2c
    46c2:	03 c0       	rjmp	.+6      	; 0x46ca <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    46c4:	e9 89       	ldd	r30, Y+17	; 0x11
    46c6:	fa 89       	ldd	r31, Y+18	; 0x12
    46c8:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    46ca:	8e 85       	ldd	r24, Y+14	; 0x0e
    46cc:	85 30       	cpi	r24, 0x05	; 5
    46ce:	10 f0       	brcs	.+4      	; 0x46d4 <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    46d0:	84 e0       	ldi	r24, 0x04	; 4
    46d2:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    46d4:	e9 89       	ldd	r30, Y+17	; 0x11
    46d6:	fa 89       	ldd	r31, Y+18	; 0x12
    46d8:	8e 85       	ldd	r24, Y+14	; 0x0e
    46da:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    46dc:	89 89       	ldd	r24, Y+17	; 0x11
    46de:	9a 89       	ldd	r25, Y+18	; 0x12
    46e0:	02 96       	adiw	r24, 0x02	; 2
    46e2:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    46e6:	89 89       	ldd	r24, Y+17	; 0x11
    46e8:	9a 89       	ldd	r25, Y+18	; 0x12
    46ea:	0c 96       	adiw	r24, 0x0c	; 12
    46ec:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    46f0:	e9 89       	ldd	r30, Y+17	; 0x11
    46f2:	fa 89       	ldd	r31, Y+18	; 0x12
    46f4:	89 89       	ldd	r24, Y+17	; 0x11
    46f6:	9a 89       	ldd	r25, Y+18	; 0x12
    46f8:	91 87       	std	Z+9, r25	; 0x09
    46fa:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    46fc:	8e 85       	ldd	r24, Y+14	; 0x0e
    46fe:	28 2f       	mov	r18, r24
    4700:	30 e0       	ldi	r19, 0x00	; 0
    4702:	85 e0       	ldi	r24, 0x05	; 5
    4704:	90 e0       	ldi	r25, 0x00	; 0
    4706:	82 1b       	sub	r24, r18
    4708:	93 0b       	sbc	r25, r19
    470a:	e9 89       	ldd	r30, Y+17	; 0x11
    470c:	fa 89       	ldd	r31, Y+18	; 0x12
    470e:	95 87       	std	Z+13, r25	; 0x0d
    4710:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    4712:	e9 89       	ldd	r30, Y+17	; 0x11
    4714:	fa 89       	ldd	r31, Y+18	; 0x12
    4716:	89 89       	ldd	r24, Y+17	; 0x11
    4718:	9a 89       	ldd	r25, Y+18	; 0x12
    471a:	93 8b       	std	Z+19, r25	; 0x13
    471c:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    471e:	e9 89       	ldd	r30, Y+17	; 0x11
    4720:	fa 89       	ldd	r31, Y+18	; 0x12
    4722:	15 a6       	std	Z+45, r1	; 0x2d
    4724:	16 a6       	std	Z+46, r1	; 0x2e
    4726:	17 a6       	std	Z+47, r1	; 0x2f
    4728:	10 aa       	std	Z+48, r1	; 0x30
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    472a:	e9 89       	ldd	r30, Y+17	; 0x11
    472c:	fa 89       	ldd	r31, Y+18	; 0x12
    472e:	11 aa       	std	Z+49, r1	; 0x31
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    4730:	8a 81       	ldd	r24, Y+2	; 0x02
    4732:	9b 81       	ldd	r25, Y+3	; 0x03
    4734:	2c 81       	ldd	r18, Y+4	; 0x04
    4736:	3d 81       	ldd	r19, Y+5	; 0x05
    4738:	4c 85       	ldd	r20, Y+12	; 0x0c
    473a:	5d 85       	ldd	r21, Y+13	; 0x0d
    473c:	b9 01       	movw	r22, r18
    473e:	0e 94 03 11 	call	0x2206	; 0x2206 <pxPortInitialiseStack>
    4742:	e9 89       	ldd	r30, Y+17	; 0x11
    4744:	fa 89       	ldd	r31, Y+18	; 0x12
    4746:	91 83       	std	Z+1, r25	; 0x01
    4748:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    474a:	8f 85       	ldd	r24, Y+15	; 0x0f
    474c:	98 89       	ldd	r25, Y+16	; 0x10
    474e:	00 97       	sbiw	r24, 0x00	; 0
    4750:	31 f0       	breq	.+12     	; 0x475e <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    4752:	ef 85       	ldd	r30, Y+15	; 0x0f
    4754:	f8 89       	ldd	r31, Y+16	; 0x10
    4756:	89 89       	ldd	r24, Y+17	; 0x11
    4758:	9a 89       	ldd	r25, Y+18	; 0x12
    475a:	91 83       	std	Z+1, r25	; 0x01
    475c:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    475e:	64 96       	adiw	r28, 0x14	; 20
    4760:	0f b6       	in	r0, 0x3f	; 63
    4762:	f8 94       	cli
    4764:	de bf       	out	0x3e, r29	; 62
    4766:	0f be       	out	0x3f, r0	; 63
    4768:	cd bf       	out	0x3d, r28	; 61
    476a:	cf 91       	pop	r28
    476c:	df 91       	pop	r29
    476e:	1f 91       	pop	r17
    4770:	0f 91       	pop	r16
    4772:	ef 90       	pop	r14
    4774:	df 90       	pop	r13
    4776:	cf 90       	pop	r12
    4778:	bf 90       	pop	r11
    477a:	af 90       	pop	r10
    477c:	9f 90       	pop	r9
    477e:	8f 90       	pop	r8
    4780:	08 95       	ret

00004782 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    4782:	df 93       	push	r29
    4784:	cf 93       	push	r28
    4786:	00 d0       	rcall	.+0      	; 0x4788 <prvAddNewTaskToReadyList+0x6>
    4788:	cd b7       	in	r28, 0x3d	; 61
    478a:	de b7       	in	r29, 0x3e	; 62
    478c:	9a 83       	std	Y+2, r25	; 0x02
    478e:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    4790:	0f b6       	in	r0, 0x3f	; 63
    4792:	f8 94       	cli
    4794:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    4796:	80 91 d1 06 	lds	r24, 0x06D1
    479a:	8f 5f       	subi	r24, 0xFF	; 255
    479c:	80 93 d1 06 	sts	0x06D1, r24
		if( pxCurrentTCB == NULL )
    47a0:	80 91 ce 06 	lds	r24, 0x06CE
    47a4:	90 91 cf 06 	lds	r25, 0x06CF
    47a8:	00 97       	sbiw	r24, 0x00	; 0
    47aa:	69 f4       	brne	.+26     	; 0x47c6 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    47ac:	89 81       	ldd	r24, Y+1	; 0x01
    47ae:	9a 81       	ldd	r25, Y+2	; 0x02
    47b0:	90 93 cf 06 	sts	0x06CF, r25
    47b4:	80 93 ce 06 	sts	0x06CE, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    47b8:	80 91 d1 06 	lds	r24, 0x06D1
    47bc:	81 30       	cpi	r24, 0x01	; 1
    47be:	b9 f4       	brne	.+46     	; 0x47ee <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    47c0:	0e 94 98 2a 	call	0x5530	; 0x5530 <prvInitialiseTaskLists>
    47c4:	14 c0       	rjmp	.+40     	; 0x47ee <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    47c6:	80 91 d5 06 	lds	r24, 0x06D5
    47ca:	88 23       	and	r24, r24
    47cc:	81 f4       	brne	.+32     	; 0x47ee <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    47ce:	e0 91 ce 06 	lds	r30, 0x06CE
    47d2:	f0 91 cf 06 	lds	r31, 0x06CF
    47d6:	96 89       	ldd	r25, Z+22	; 0x16
    47d8:	e9 81       	ldd	r30, Y+1	; 0x01
    47da:	fa 81       	ldd	r31, Y+2	; 0x02
    47dc:	86 89       	ldd	r24, Z+22	; 0x16
    47de:	89 17       	cp	r24, r25
    47e0:	30 f0       	brcs	.+12     	; 0x47ee <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    47e2:	89 81       	ldd	r24, Y+1	; 0x01
    47e4:	9a 81       	ldd	r25, Y+2	; 0x02
    47e6:	90 93 cf 06 	sts	0x06CF, r25
    47ea:	80 93 ce 06 	sts	0x06CE, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    47ee:	80 91 d9 06 	lds	r24, 0x06D9
    47f2:	8f 5f       	subi	r24, 0xFF	; 255
    47f4:	80 93 d9 06 	sts	0x06D9, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    47f8:	e9 81       	ldd	r30, Y+1	; 0x01
    47fa:	fa 81       	ldd	r31, Y+2	; 0x02
    47fc:	96 89       	ldd	r25, Z+22	; 0x16
    47fe:	80 91 d4 06 	lds	r24, 0x06D4
    4802:	89 17       	cp	r24, r25
    4804:	28 f4       	brcc	.+10     	; 0x4810 <prvAddNewTaskToReadyList+0x8e>
    4806:	e9 81       	ldd	r30, Y+1	; 0x01
    4808:	fa 81       	ldd	r31, Y+2	; 0x02
    480a:	86 89       	ldd	r24, Z+22	; 0x16
    480c:	80 93 d4 06 	sts	0x06D4, r24
    4810:	e9 81       	ldd	r30, Y+1	; 0x01
    4812:	fa 81       	ldd	r31, Y+2	; 0x02
    4814:	86 89       	ldd	r24, Z+22	; 0x16
    4816:	28 2f       	mov	r18, r24
    4818:	30 e0       	ldi	r19, 0x00	; 0
    481a:	c9 01       	movw	r24, r18
    481c:	88 0f       	add	r24, r24
    481e:	99 1f       	adc	r25, r25
    4820:	88 0f       	add	r24, r24
    4822:	99 1f       	adc	r25, r25
    4824:	88 0f       	add	r24, r24
    4826:	99 1f       	adc	r25, r25
    4828:	82 0f       	add	r24, r18
    482a:	93 1f       	adc	r25, r19
    482c:	ac 01       	movw	r20, r24
    482e:	41 52       	subi	r20, 0x21	; 33
    4830:	59 4f       	sbci	r21, 0xF9	; 249
    4832:	89 81       	ldd	r24, Y+1	; 0x01
    4834:	9a 81       	ldd	r25, Y+2	; 0x02
    4836:	9c 01       	movw	r18, r24
    4838:	2e 5f       	subi	r18, 0xFE	; 254
    483a:	3f 4f       	sbci	r19, 0xFF	; 255
    483c:	ca 01       	movw	r24, r20
    483e:	b9 01       	movw	r22, r18
    4840:	0e 94 ea 0f 	call	0x1fd4	; 0x1fd4 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    4844:	0f 90       	pop	r0
    4846:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    4848:	80 91 d5 06 	lds	r24, 0x06D5
    484c:	88 23       	and	r24, r24
    484e:	61 f0       	breq	.+24     	; 0x4868 <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    4850:	e0 91 ce 06 	lds	r30, 0x06CE
    4854:	f0 91 cf 06 	lds	r31, 0x06CF
    4858:	96 89       	ldd	r25, Z+22	; 0x16
    485a:	e9 81       	ldd	r30, Y+1	; 0x01
    485c:	fa 81       	ldd	r31, Y+2	; 0x02
    485e:	86 89       	ldd	r24, Z+22	; 0x16
    4860:	98 17       	cp	r25, r24
    4862:	10 f4       	brcc	.+4      	; 0x4868 <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    4864:	0e 94 c2 12 	call	0x2584	; 0x2584 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    4868:	0f 90       	pop	r0
    486a:	0f 90       	pop	r0
    486c:	cf 91       	pop	r28
    486e:	df 91       	pop	r29
    4870:	08 95       	ret

00004872 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    4872:	df 93       	push	r29
    4874:	cf 93       	push	r28
    4876:	00 d0       	rcall	.+0      	; 0x4878 <vTaskDelete+0x6>
    4878:	00 d0       	rcall	.+0      	; 0x487a <vTaskDelete+0x8>
    487a:	00 d0       	rcall	.+0      	; 0x487c <vTaskDelete+0xa>
    487c:	cd b7       	in	r28, 0x3d	; 61
    487e:	de b7       	in	r29, 0x3e	; 62
    4880:	9c 83       	std	Y+4, r25	; 0x04
    4882:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    4884:	0f b6       	in	r0, 0x3f	; 63
    4886:	f8 94       	cli
    4888:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    488a:	8b 81       	ldd	r24, Y+3	; 0x03
    488c:	9c 81       	ldd	r25, Y+4	; 0x04
    488e:	00 97       	sbiw	r24, 0x00	; 0
    4890:	39 f4       	brne	.+14     	; 0x48a0 <vTaskDelete+0x2e>
    4892:	80 91 ce 06 	lds	r24, 0x06CE
    4896:	90 91 cf 06 	lds	r25, 0x06CF
    489a:	9e 83       	std	Y+6, r25	; 0x06
    489c:	8d 83       	std	Y+5, r24	; 0x05
    489e:	04 c0       	rjmp	.+8      	; 0x48a8 <vTaskDelete+0x36>
    48a0:	8b 81       	ldd	r24, Y+3	; 0x03
    48a2:	9c 81       	ldd	r25, Y+4	; 0x04
    48a4:	9e 83       	std	Y+6, r25	; 0x06
    48a6:	8d 83       	std	Y+5, r24	; 0x05
    48a8:	8d 81       	ldd	r24, Y+5	; 0x05
    48aa:	9e 81       	ldd	r25, Y+6	; 0x06
    48ac:	9a 83       	std	Y+2, r25	; 0x02
    48ae:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    48b0:	89 81       	ldd	r24, Y+1	; 0x01
    48b2:	9a 81       	ldd	r25, Y+2	; 0x02
    48b4:	02 96       	adiw	r24, 0x02	; 2
    48b6:	0e 94 9a 10 	call	0x2134	; 0x2134 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    48ba:	e9 81       	ldd	r30, Y+1	; 0x01
    48bc:	fa 81       	ldd	r31, Y+2	; 0x02
    48be:	84 89       	ldd	r24, Z+20	; 0x14
    48c0:	95 89       	ldd	r25, Z+21	; 0x15
    48c2:	00 97       	sbiw	r24, 0x00	; 0
    48c4:	29 f0       	breq	.+10     	; 0x48d0 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    48c6:	89 81       	ldd	r24, Y+1	; 0x01
    48c8:	9a 81       	ldd	r25, Y+2	; 0x02
    48ca:	0c 96       	adiw	r24, 0x0c	; 12
    48cc:	0e 94 9a 10 	call	0x2134	; 0x2134 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    48d0:	80 91 d9 06 	lds	r24, 0x06D9
    48d4:	8f 5f       	subi	r24, 0xFF	; 255
    48d6:	80 93 d9 06 	sts	0x06D9, r24

			if( pxTCB == pxCurrentTCB )
    48da:	20 91 ce 06 	lds	r18, 0x06CE
    48de:	30 91 cf 06 	lds	r19, 0x06CF
    48e2:	89 81       	ldd	r24, Y+1	; 0x01
    48e4:	9a 81       	ldd	r25, Y+2	; 0x02
    48e6:	82 17       	cp	r24, r18
    48e8:	93 07       	cpc	r25, r19
    48ea:	81 f4       	brne	.+32     	; 0x490c <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    48ec:	89 81       	ldd	r24, Y+1	; 0x01
    48ee:	9a 81       	ldd	r25, Y+2	; 0x02
    48f0:	9c 01       	movw	r18, r24
    48f2:	2e 5f       	subi	r18, 0xFE	; 254
    48f4:	3f 4f       	sbci	r19, 0xFF	; 255
    48f6:	8b e2       	ldi	r24, 0x2B	; 43
    48f8:	97 e0       	ldi	r25, 0x07	; 7
    48fa:	b9 01       	movw	r22, r18
    48fc:	0e 94 ea 0f 	call	0x1fd4	; 0x1fd4 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    4900:	80 91 d0 06 	lds	r24, 0x06D0
    4904:	8f 5f       	subi	r24, 0xFF	; 255
    4906:	80 93 d0 06 	sts	0x06D0, r24
    490a:	0b c0       	rjmp	.+22     	; 0x4922 <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    490c:	80 91 d1 06 	lds	r24, 0x06D1
    4910:	81 50       	subi	r24, 0x01	; 1
    4912:	80 93 d1 06 	sts	0x06D1, r24
				prvDeleteTCB( pxTCB );
    4916:	89 81       	ldd	r24, Y+1	; 0x01
    4918:	9a 81       	ldd	r25, Y+2	; 0x02
    491a:	0e 94 08 2b 	call	0x5610	; 0x5610 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    491e:	0e 94 1e 2b 	call	0x563c	; 0x563c <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    4922:	0f 90       	pop	r0
    4924:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    4926:	80 91 d5 06 	lds	r24, 0x06D5
    492a:	88 23       	and	r24, r24
    492c:	59 f0       	breq	.+22     	; 0x4944 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    492e:	20 91 ce 06 	lds	r18, 0x06CE
    4932:	30 91 cf 06 	lds	r19, 0x06CF
    4936:	89 81       	ldd	r24, Y+1	; 0x01
    4938:	9a 81       	ldd	r25, Y+2	; 0x02
    493a:	82 17       	cp	r24, r18
    493c:	93 07       	cpc	r25, r19
    493e:	11 f4       	brne	.+4      	; 0x4944 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    4940:	0e 94 c2 12 	call	0x2584	; 0x2584 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    4944:	26 96       	adiw	r28, 0x06	; 6
    4946:	0f b6       	in	r0, 0x3f	; 63
    4948:	f8 94       	cli
    494a:	de bf       	out	0x3e, r29	; 62
    494c:	0f be       	out	0x3f, r0	; 63
    494e:	cd bf       	out	0x3d, r28	; 61
    4950:	cf 91       	pop	r28
    4952:	df 91       	pop	r29
    4954:	08 95       	ret

00004956 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    4956:	df 93       	push	r29
    4958:	cf 93       	push	r28
    495a:	00 d0       	rcall	.+0      	; 0x495c <vTaskDelay+0x6>
    495c:	0f 92       	push	r0
    495e:	cd b7       	in	r28, 0x3d	; 61
    4960:	de b7       	in	r29, 0x3e	; 62
    4962:	9b 83       	std	Y+3, r25	; 0x03
    4964:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    4966:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    4968:	8a 81       	ldd	r24, Y+2	; 0x02
    496a:	9b 81       	ldd	r25, Y+3	; 0x03
    496c:	00 97       	sbiw	r24, 0x00	; 0
    496e:	51 f0       	breq	.+20     	; 0x4984 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    4970:	0e 94 78 26 	call	0x4cf0	; 0x4cf0 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    4974:	8a 81       	ldd	r24, Y+2	; 0x02
    4976:	9b 81       	ldd	r25, Y+3	; 0x03
    4978:	60 e0       	ldi	r22, 0x00	; 0
    497a:	0e 94 2a 2f 	call	0x5e54	; 0x5e54 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    497e:	0e 94 84 26 	call	0x4d08	; 0x4d08 <xTaskResumeAll>
    4982:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4984:	89 81       	ldd	r24, Y+1	; 0x01
    4986:	88 23       	and	r24, r24
    4988:	11 f4       	brne	.+4      	; 0x498e <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    498a:	0e 94 c2 12 	call	0x2584	; 0x2584 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    498e:	0f 90       	pop	r0
    4990:	0f 90       	pop	r0
    4992:	0f 90       	pop	r0
    4994:	cf 91       	pop	r28
    4996:	df 91       	pop	r29
    4998:	08 95       	ret

0000499a <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    499a:	df 93       	push	r29
    499c:	cf 93       	push	r28
    499e:	00 d0       	rcall	.+0      	; 0x49a0 <vTaskSuspend+0x6>
    49a0:	00 d0       	rcall	.+0      	; 0x49a2 <vTaskSuspend+0x8>
    49a2:	00 d0       	rcall	.+0      	; 0x49a4 <vTaskSuspend+0xa>
    49a4:	cd b7       	in	r28, 0x3d	; 61
    49a6:	de b7       	in	r29, 0x3e	; 62
    49a8:	9c 83       	std	Y+4, r25	; 0x04
    49aa:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    49ac:	0f b6       	in	r0, 0x3f	; 63
    49ae:	f8 94       	cli
    49b0:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    49b2:	8b 81       	ldd	r24, Y+3	; 0x03
    49b4:	9c 81       	ldd	r25, Y+4	; 0x04
    49b6:	00 97       	sbiw	r24, 0x00	; 0
    49b8:	39 f4       	brne	.+14     	; 0x49c8 <vTaskSuspend+0x2e>
    49ba:	80 91 ce 06 	lds	r24, 0x06CE
    49be:	90 91 cf 06 	lds	r25, 0x06CF
    49c2:	9e 83       	std	Y+6, r25	; 0x06
    49c4:	8d 83       	std	Y+5, r24	; 0x05
    49c6:	04 c0       	rjmp	.+8      	; 0x49d0 <vTaskSuspend+0x36>
    49c8:	8b 81       	ldd	r24, Y+3	; 0x03
    49ca:	9c 81       	ldd	r25, Y+4	; 0x04
    49cc:	9e 83       	std	Y+6, r25	; 0x06
    49ce:	8d 83       	std	Y+5, r24	; 0x05
    49d0:	8d 81       	ldd	r24, Y+5	; 0x05
    49d2:	9e 81       	ldd	r25, Y+6	; 0x06
    49d4:	9a 83       	std	Y+2, r25	; 0x02
    49d6:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    49d8:	89 81       	ldd	r24, Y+1	; 0x01
    49da:	9a 81       	ldd	r25, Y+2	; 0x02
    49dc:	02 96       	adiw	r24, 0x02	; 2
    49de:	0e 94 9a 10 	call	0x2134	; 0x2134 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    49e2:	e9 81       	ldd	r30, Y+1	; 0x01
    49e4:	fa 81       	ldd	r31, Y+2	; 0x02
    49e6:	84 89       	ldd	r24, Z+20	; 0x14
    49e8:	95 89       	ldd	r25, Z+21	; 0x15
    49ea:	00 97       	sbiw	r24, 0x00	; 0
    49ec:	29 f0       	breq	.+10     	; 0x49f8 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    49ee:	89 81       	ldd	r24, Y+1	; 0x01
    49f0:	9a 81       	ldd	r25, Y+2	; 0x02
    49f2:	0c 96       	adiw	r24, 0x0c	; 12
    49f4:	0e 94 9a 10 	call	0x2134	; 0x2134 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    49f8:	89 81       	ldd	r24, Y+1	; 0x01
    49fa:	9a 81       	ldd	r25, Y+2	; 0x02
    49fc:	9c 01       	movw	r18, r24
    49fe:	2e 5f       	subi	r18, 0xFE	; 254
    4a00:	3f 4f       	sbci	r19, 0xFF	; 255
    4a02:	84 e3       	ldi	r24, 0x34	; 52
    4a04:	97 e0       	ldi	r25, 0x07	; 7
    4a06:	b9 01       	movw	r22, r18
    4a08:	0e 94 ea 0f 	call	0x1fd4	; 0x1fd4 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    4a0c:	e9 81       	ldd	r30, Y+1	; 0x01
    4a0e:	fa 81       	ldd	r31, Y+2	; 0x02
    4a10:	81 a9       	ldd	r24, Z+49	; 0x31
    4a12:	81 30       	cpi	r24, 0x01	; 1
    4a14:	19 f4       	brne	.+6      	; 0x4a1c <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4a16:	e9 81       	ldd	r30, Y+1	; 0x01
    4a18:	fa 81       	ldd	r31, Y+2	; 0x02
    4a1a:	11 aa       	std	Z+49, r1	; 0x31
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    4a1c:	0f 90       	pop	r0
    4a1e:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    4a20:	80 91 d5 06 	lds	r24, 0x06D5
    4a24:	88 23       	and	r24, r24
    4a26:	39 f0       	breq	.+14     	; 0x4a36 <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    4a28:	0f b6       	in	r0, 0x3f	; 63
    4a2a:	f8 94       	cli
    4a2c:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    4a2e:	0e 94 1e 2b 	call	0x563c	; 0x563c <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    4a32:	0f 90       	pop	r0
    4a34:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    4a36:	20 91 ce 06 	lds	r18, 0x06CE
    4a3a:	30 91 cf 06 	lds	r19, 0x06CF
    4a3e:	89 81       	ldd	r24, Y+1	; 0x01
    4a40:	9a 81       	ldd	r25, Y+2	; 0x02
    4a42:	82 17       	cp	r24, r18
    4a44:	93 07       	cpc	r25, r19
    4a46:	a1 f4       	brne	.+40     	; 0x4a70 <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    4a48:	80 91 d5 06 	lds	r24, 0x06D5
    4a4c:	88 23       	and	r24, r24
    4a4e:	19 f0       	breq	.+6      	; 0x4a56 <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    4a50:	0e 94 c2 12 	call	0x2584	; 0x2584 <vPortYield>
    4a54:	0d c0       	rjmp	.+26     	; 0x4a70 <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    4a56:	90 91 34 07 	lds	r25, 0x0734
    4a5a:	80 91 d1 06 	lds	r24, 0x06D1
    4a5e:	98 17       	cp	r25, r24
    4a60:	29 f4       	brne	.+10     	; 0x4a6c <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    4a62:	10 92 cf 06 	sts	0x06CF, r1
    4a66:	10 92 ce 06 	sts	0x06CE, r1
    4a6a:	02 c0       	rjmp	.+4      	; 0x4a70 <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    4a6c:	0e 94 59 28 	call	0x50b2	; 0x50b2 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4a70:	26 96       	adiw	r28, 0x06	; 6
    4a72:	0f b6       	in	r0, 0x3f	; 63
    4a74:	f8 94       	cli
    4a76:	de bf       	out	0x3e, r29	; 62
    4a78:	0f be       	out	0x3f, r0	; 63
    4a7a:	cd bf       	out	0x3d, r28	; 61
    4a7c:	cf 91       	pop	r28
    4a7e:	df 91       	pop	r29
    4a80:	08 95       	ret

00004a82 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    4a82:	df 93       	push	r29
    4a84:	cf 93       	push	r28
    4a86:	00 d0       	rcall	.+0      	; 0x4a88 <prvTaskIsTaskSuspended+0x6>
    4a88:	00 d0       	rcall	.+0      	; 0x4a8a <prvTaskIsTaskSuspended+0x8>
    4a8a:	0f 92       	push	r0
    4a8c:	cd b7       	in	r28, 0x3d	; 61
    4a8e:	de b7       	in	r29, 0x3e	; 62
    4a90:	9d 83       	std	Y+5, r25	; 0x05
    4a92:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    4a94:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    4a96:	8c 81       	ldd	r24, Y+4	; 0x04
    4a98:	9d 81       	ldd	r25, Y+5	; 0x05
    4a9a:	9a 83       	std	Y+2, r25	; 0x02
    4a9c:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    4a9e:	e9 81       	ldd	r30, Y+1	; 0x01
    4aa0:	fa 81       	ldd	r31, Y+2	; 0x02
    4aa2:	82 85       	ldd	r24, Z+10	; 0x0a
    4aa4:	93 85       	ldd	r25, Z+11	; 0x0b
    4aa6:	27 e0       	ldi	r18, 0x07	; 7
    4aa8:	84 33       	cpi	r24, 0x34	; 52
    4aaa:	92 07       	cpc	r25, r18
    4aac:	81 f4       	brne	.+32     	; 0x4ace <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    4aae:	e9 81       	ldd	r30, Y+1	; 0x01
    4ab0:	fa 81       	ldd	r31, Y+2	; 0x02
    4ab2:	84 89       	ldd	r24, Z+20	; 0x14
    4ab4:	95 89       	ldd	r25, Z+21	; 0x15
    4ab6:	27 e0       	ldi	r18, 0x07	; 7
    4ab8:	82 32       	cpi	r24, 0x22	; 34
    4aba:	92 07       	cpc	r25, r18
    4abc:	41 f0       	breq	.+16     	; 0x4ace <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    4abe:	e9 81       	ldd	r30, Y+1	; 0x01
    4ac0:	fa 81       	ldd	r31, Y+2	; 0x02
    4ac2:	84 89       	ldd	r24, Z+20	; 0x14
    4ac4:	95 89       	ldd	r25, Z+21	; 0x15
    4ac6:	00 97       	sbiw	r24, 0x00	; 0
    4ac8:	11 f4       	brne	.+4      	; 0x4ace <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    4aca:	81 e0       	ldi	r24, 0x01	; 1
    4acc:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    4ace:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    4ad0:	0f 90       	pop	r0
    4ad2:	0f 90       	pop	r0
    4ad4:	0f 90       	pop	r0
    4ad6:	0f 90       	pop	r0
    4ad8:	0f 90       	pop	r0
    4ada:	cf 91       	pop	r28
    4adc:	df 91       	pop	r29
    4ade:	08 95       	ret

00004ae0 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    4ae0:	df 93       	push	r29
    4ae2:	cf 93       	push	r28
    4ae4:	00 d0       	rcall	.+0      	; 0x4ae6 <vTaskResume+0x6>
    4ae6:	00 d0       	rcall	.+0      	; 0x4ae8 <vTaskResume+0x8>
    4ae8:	cd b7       	in	r28, 0x3d	; 61
    4aea:	de b7       	in	r29, 0x3e	; 62
    4aec:	9c 83       	std	Y+4, r25	; 0x04
    4aee:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    4af0:	8b 81       	ldd	r24, Y+3	; 0x03
    4af2:	9c 81       	ldd	r25, Y+4	; 0x04
    4af4:	9a 83       	std	Y+2, r25	; 0x02
    4af6:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    4af8:	20 91 ce 06 	lds	r18, 0x06CE
    4afc:	30 91 cf 06 	lds	r19, 0x06CF
    4b00:	89 81       	ldd	r24, Y+1	; 0x01
    4b02:	9a 81       	ldd	r25, Y+2	; 0x02
    4b04:	82 17       	cp	r24, r18
    4b06:	93 07       	cpc	r25, r19
    4b08:	09 f4       	brne	.+2      	; 0x4b0c <vTaskResume+0x2c>
    4b0a:	47 c0       	rjmp	.+142    	; 0x4b9a <vTaskResume+0xba>
    4b0c:	89 81       	ldd	r24, Y+1	; 0x01
    4b0e:	9a 81       	ldd	r25, Y+2	; 0x02
    4b10:	00 97       	sbiw	r24, 0x00	; 0
    4b12:	09 f4       	brne	.+2      	; 0x4b16 <vTaskResume+0x36>
    4b14:	42 c0       	rjmp	.+132    	; 0x4b9a <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    4b16:	0f b6       	in	r0, 0x3f	; 63
    4b18:	f8 94       	cli
    4b1a:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    4b1c:	89 81       	ldd	r24, Y+1	; 0x01
    4b1e:	9a 81       	ldd	r25, Y+2	; 0x02
    4b20:	0e 94 41 25 	call	0x4a82	; 0x4a82 <prvTaskIsTaskSuspended>
    4b24:	88 23       	and	r24, r24
    4b26:	b9 f1       	breq	.+110    	; 0x4b96 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    4b28:	89 81       	ldd	r24, Y+1	; 0x01
    4b2a:	9a 81       	ldd	r25, Y+2	; 0x02
    4b2c:	02 96       	adiw	r24, 0x02	; 2
    4b2e:	0e 94 9a 10 	call	0x2134	; 0x2134 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4b32:	e9 81       	ldd	r30, Y+1	; 0x01
    4b34:	fa 81       	ldd	r31, Y+2	; 0x02
    4b36:	96 89       	ldd	r25, Z+22	; 0x16
    4b38:	80 91 d4 06 	lds	r24, 0x06D4
    4b3c:	89 17       	cp	r24, r25
    4b3e:	28 f4       	brcc	.+10     	; 0x4b4a <vTaskResume+0x6a>
    4b40:	e9 81       	ldd	r30, Y+1	; 0x01
    4b42:	fa 81       	ldd	r31, Y+2	; 0x02
    4b44:	86 89       	ldd	r24, Z+22	; 0x16
    4b46:	80 93 d4 06 	sts	0x06D4, r24
    4b4a:	e9 81       	ldd	r30, Y+1	; 0x01
    4b4c:	fa 81       	ldd	r31, Y+2	; 0x02
    4b4e:	86 89       	ldd	r24, Z+22	; 0x16
    4b50:	28 2f       	mov	r18, r24
    4b52:	30 e0       	ldi	r19, 0x00	; 0
    4b54:	c9 01       	movw	r24, r18
    4b56:	88 0f       	add	r24, r24
    4b58:	99 1f       	adc	r25, r25
    4b5a:	88 0f       	add	r24, r24
    4b5c:	99 1f       	adc	r25, r25
    4b5e:	88 0f       	add	r24, r24
    4b60:	99 1f       	adc	r25, r25
    4b62:	82 0f       	add	r24, r18
    4b64:	93 1f       	adc	r25, r19
    4b66:	ac 01       	movw	r20, r24
    4b68:	41 52       	subi	r20, 0x21	; 33
    4b6a:	59 4f       	sbci	r21, 0xF9	; 249
    4b6c:	89 81       	ldd	r24, Y+1	; 0x01
    4b6e:	9a 81       	ldd	r25, Y+2	; 0x02
    4b70:	9c 01       	movw	r18, r24
    4b72:	2e 5f       	subi	r18, 0xFE	; 254
    4b74:	3f 4f       	sbci	r19, 0xFF	; 255
    4b76:	ca 01       	movw	r24, r20
    4b78:	b9 01       	movw	r22, r18
    4b7a:	0e 94 ea 0f 	call	0x1fd4	; 0x1fd4 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4b7e:	e9 81       	ldd	r30, Y+1	; 0x01
    4b80:	fa 81       	ldd	r31, Y+2	; 0x02
    4b82:	96 89       	ldd	r25, Z+22	; 0x16
    4b84:	e0 91 ce 06 	lds	r30, 0x06CE
    4b88:	f0 91 cf 06 	lds	r31, 0x06CF
    4b8c:	86 89       	ldd	r24, Z+22	; 0x16
    4b8e:	98 17       	cp	r25, r24
    4b90:	10 f0       	brcs	.+4      	; 0x4b96 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    4b92:	0e 94 c2 12 	call	0x2584	; 0x2584 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    4b96:	0f 90       	pop	r0
    4b98:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4b9a:	0f 90       	pop	r0
    4b9c:	0f 90       	pop	r0
    4b9e:	0f 90       	pop	r0
    4ba0:	0f 90       	pop	r0
    4ba2:	cf 91       	pop	r28
    4ba4:	df 91       	pop	r29
    4ba6:	08 95       	ret

00004ba8 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    4ba8:	df 93       	push	r29
    4baa:	cf 93       	push	r28
    4bac:	00 d0       	rcall	.+0      	; 0x4bae <xTaskResumeFromISR+0x6>
    4bae:	00 d0       	rcall	.+0      	; 0x4bb0 <xTaskResumeFromISR+0x8>
    4bb0:	00 d0       	rcall	.+0      	; 0x4bb2 <xTaskResumeFromISR+0xa>
    4bb2:	cd b7       	in	r28, 0x3d	; 61
    4bb4:	de b7       	in	r29, 0x3e	; 62
    4bb6:	9e 83       	std	Y+6, r25	; 0x06
    4bb8:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    4bba:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    4bbc:	8d 81       	ldd	r24, Y+5	; 0x05
    4bbe:	9e 81       	ldd	r25, Y+6	; 0x06
    4bc0:	9b 83       	std	Y+3, r25	; 0x03
    4bc2:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4bc4:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    4bc6:	8a 81       	ldd	r24, Y+2	; 0x02
    4bc8:	9b 81       	ldd	r25, Y+3	; 0x03
    4bca:	0e 94 41 25 	call	0x4a82	; 0x4a82 <prvTaskIsTaskSuspended>
    4bce:	88 23       	and	r24, r24
    4bd0:	09 f4       	brne	.+2      	; 0x4bd4 <xTaskResumeFromISR+0x2c>
    4bd2:	46 c0       	rjmp	.+140    	; 0x4c60 <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4bd4:	80 91 de 06 	lds	r24, 0x06DE
    4bd8:	88 23       	and	r24, r24
    4bda:	c1 f5       	brne	.+112    	; 0x4c4c <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4bdc:	ea 81       	ldd	r30, Y+2	; 0x02
    4bde:	fb 81       	ldd	r31, Y+3	; 0x03
    4be0:	96 89       	ldd	r25, Z+22	; 0x16
    4be2:	e0 91 ce 06 	lds	r30, 0x06CE
    4be6:	f0 91 cf 06 	lds	r31, 0x06CF
    4bea:	86 89       	ldd	r24, Z+22	; 0x16
    4bec:	98 17       	cp	r25, r24
    4bee:	10 f0       	brcs	.+4      	; 0x4bf4 <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    4bf0:	81 e0       	ldi	r24, 0x01	; 1
    4bf2:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4bf4:	8a 81       	ldd	r24, Y+2	; 0x02
    4bf6:	9b 81       	ldd	r25, Y+3	; 0x03
    4bf8:	02 96       	adiw	r24, 0x02	; 2
    4bfa:	0e 94 9a 10 	call	0x2134	; 0x2134 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4bfe:	ea 81       	ldd	r30, Y+2	; 0x02
    4c00:	fb 81       	ldd	r31, Y+3	; 0x03
    4c02:	96 89       	ldd	r25, Z+22	; 0x16
    4c04:	80 91 d4 06 	lds	r24, 0x06D4
    4c08:	89 17       	cp	r24, r25
    4c0a:	28 f4       	brcc	.+10     	; 0x4c16 <xTaskResumeFromISR+0x6e>
    4c0c:	ea 81       	ldd	r30, Y+2	; 0x02
    4c0e:	fb 81       	ldd	r31, Y+3	; 0x03
    4c10:	86 89       	ldd	r24, Z+22	; 0x16
    4c12:	80 93 d4 06 	sts	0x06D4, r24
    4c16:	ea 81       	ldd	r30, Y+2	; 0x02
    4c18:	fb 81       	ldd	r31, Y+3	; 0x03
    4c1a:	86 89       	ldd	r24, Z+22	; 0x16
    4c1c:	28 2f       	mov	r18, r24
    4c1e:	30 e0       	ldi	r19, 0x00	; 0
    4c20:	c9 01       	movw	r24, r18
    4c22:	88 0f       	add	r24, r24
    4c24:	99 1f       	adc	r25, r25
    4c26:	88 0f       	add	r24, r24
    4c28:	99 1f       	adc	r25, r25
    4c2a:	88 0f       	add	r24, r24
    4c2c:	99 1f       	adc	r25, r25
    4c2e:	82 0f       	add	r24, r18
    4c30:	93 1f       	adc	r25, r19
    4c32:	ac 01       	movw	r20, r24
    4c34:	41 52       	subi	r20, 0x21	; 33
    4c36:	59 4f       	sbci	r21, 0xF9	; 249
    4c38:	8a 81       	ldd	r24, Y+2	; 0x02
    4c3a:	9b 81       	ldd	r25, Y+3	; 0x03
    4c3c:	9c 01       	movw	r18, r24
    4c3e:	2e 5f       	subi	r18, 0xFE	; 254
    4c40:	3f 4f       	sbci	r19, 0xFF	; 255
    4c42:	ca 01       	movw	r24, r20
    4c44:	b9 01       	movw	r22, r18
    4c46:	0e 94 ea 0f 	call	0x1fd4	; 0x1fd4 <vListInsertEnd>
    4c4a:	0a c0       	rjmp	.+20     	; 0x4c60 <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4c4c:	8a 81       	ldd	r24, Y+2	; 0x02
    4c4e:	9b 81       	ldd	r25, Y+3	; 0x03
    4c50:	9c 01       	movw	r18, r24
    4c52:	24 5f       	subi	r18, 0xF4	; 244
    4c54:	3f 4f       	sbci	r19, 0xFF	; 255
    4c56:	82 e2       	ldi	r24, 0x22	; 34
    4c58:	97 e0       	ldi	r25, 0x07	; 7
    4c5a:	b9 01       	movw	r22, r18
    4c5c:	0e 94 ea 0f 	call	0x1fd4	; 0x1fd4 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    4c60:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    4c62:	26 96       	adiw	r28, 0x06	; 6
    4c64:	0f b6       	in	r0, 0x3f	; 63
    4c66:	f8 94       	cli
    4c68:	de bf       	out	0x3e, r29	; 62
    4c6a:	0f be       	out	0x3f, r0	; 63
    4c6c:	cd bf       	out	0x3d, r28	; 61
    4c6e:	cf 91       	pop	r28
    4c70:	df 91       	pop	r29
    4c72:	08 95       	ret

00004c74 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    4c74:	ef 92       	push	r14
    4c76:	ff 92       	push	r15
    4c78:	0f 93       	push	r16
    4c7a:	df 93       	push	r29
    4c7c:	cf 93       	push	r28
    4c7e:	0f 92       	push	r0
    4c80:	cd b7       	in	r28, 0x3d	; 61
    4c82:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    4c84:	8e e8       	ldi	r24, 0x8E	; 142
    4c86:	9a e2       	ldi	r25, 0x2A	; 42
    4c88:	23 ed       	ldi	r18, 0xD3	; 211
    4c8a:	30 e0       	ldi	r19, 0x00	; 0
    4c8c:	ec ed       	ldi	r30, 0xDC	; 220
    4c8e:	f6 e0       	ldi	r31, 0x06	; 6
    4c90:	b9 01       	movw	r22, r18
    4c92:	46 e9       	ldi	r20, 0x96	; 150
    4c94:	50 e0       	ldi	r21, 0x00	; 0
    4c96:	20 e0       	ldi	r18, 0x00	; 0
    4c98:	30 e0       	ldi	r19, 0x00	; 0
    4c9a:	00 e0       	ldi	r16, 0x00	; 0
    4c9c:	7f 01       	movw	r14, r30
    4c9e:	0e 94 8d 22 	call	0x451a	; 0x451a <xTaskCreate>
    4ca2:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    4ca4:	89 81       	ldd	r24, Y+1	; 0x01
    4ca6:	81 30       	cpi	r24, 0x01	; 1
    4ca8:	81 f4       	brne	.+32     	; 0x4cca <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    4caa:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    4cac:	8f ef       	ldi	r24, 0xFF	; 255
    4cae:	9f ef       	ldi	r25, 0xFF	; 255
    4cb0:	90 93 db 06 	sts	0x06DB, r25
    4cb4:	80 93 da 06 	sts	0x06DA, r24
		xSchedulerRunning = pdTRUE;
    4cb8:	81 e0       	ldi	r24, 0x01	; 1
    4cba:	80 93 d5 06 	sts	0x06D5, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    4cbe:	10 92 d3 06 	sts	0x06D3, r1
    4cc2:	10 92 d2 06 	sts	0x06D2, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    4cc6:	0e 94 86 12 	call	0x250c	; 0x250c <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    4cca:	0f 90       	pop	r0
    4ccc:	cf 91       	pop	r28
    4cce:	df 91       	pop	r29
    4cd0:	0f 91       	pop	r16
    4cd2:	ff 90       	pop	r15
    4cd4:	ef 90       	pop	r14
    4cd6:	08 95       	ret

00004cd8 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    4cd8:	df 93       	push	r29
    4cda:	cf 93       	push	r28
    4cdc:	cd b7       	in	r28, 0x3d	; 61
    4cde:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    4ce0:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    4ce2:	10 92 d5 06 	sts	0x06D5, r1
	vPortEndScheduler();
    4ce6:	0e 94 bb 12 	call	0x2576	; 0x2576 <vPortEndScheduler>
}
    4cea:	cf 91       	pop	r28
    4cec:	df 91       	pop	r29
    4cee:	08 95       	ret

00004cf0 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    4cf0:	df 93       	push	r29
    4cf2:	cf 93       	push	r28
    4cf4:	cd b7       	in	r28, 0x3d	; 61
    4cf6:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    4cf8:	80 91 de 06 	lds	r24, 0x06DE
    4cfc:	8f 5f       	subi	r24, 0xFF	; 255
    4cfe:	80 93 de 06 	sts	0x06DE, r24
}
    4d02:	cf 91       	pop	r28
    4d04:	df 91       	pop	r29
    4d06:	08 95       	ret

00004d08 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    4d08:	df 93       	push	r29
    4d0a:	cf 93       	push	r28
    4d0c:	00 d0       	rcall	.+0      	; 0x4d0e <xTaskResumeAll+0x6>
    4d0e:	00 d0       	rcall	.+0      	; 0x4d10 <xTaskResumeAll+0x8>
    4d10:	cd b7       	in	r28, 0x3d	; 61
    4d12:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    4d14:	1c 82       	std	Y+4, r1	; 0x04
    4d16:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    4d18:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    4d1a:	0f b6       	in	r0, 0x3f	; 63
    4d1c:	f8 94       	cli
    4d1e:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    4d20:	80 91 de 06 	lds	r24, 0x06DE
    4d24:	81 50       	subi	r24, 0x01	; 1
    4d26:	80 93 de 06 	sts	0x06DE, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4d2a:	80 91 de 06 	lds	r24, 0x06DE
    4d2e:	88 23       	and	r24, r24
    4d30:	09 f0       	breq	.+2      	; 0x4d34 <xTaskResumeAll+0x2c>
    4d32:	73 c0       	rjmp	.+230    	; 0x4e1a <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    4d34:	80 91 d1 06 	lds	r24, 0x06D1
    4d38:	88 23       	and	r24, r24
    4d3a:	09 f4       	brne	.+2      	; 0x4d3e <xTaskResumeAll+0x36>
    4d3c:	6e c0       	rjmp	.+220    	; 0x4e1a <xTaskResumeAll+0x112>
    4d3e:	45 c0       	rjmp	.+138    	; 0x4dca <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4d40:	e0 91 27 07 	lds	r30, 0x0727
    4d44:	f0 91 28 07 	lds	r31, 0x0728
    4d48:	86 81       	ldd	r24, Z+6	; 0x06
    4d4a:	97 81       	ldd	r25, Z+7	; 0x07
    4d4c:	9c 83       	std	Y+4, r25	; 0x04
    4d4e:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4d50:	8b 81       	ldd	r24, Y+3	; 0x03
    4d52:	9c 81       	ldd	r25, Y+4	; 0x04
    4d54:	0c 96       	adiw	r24, 0x0c	; 12
    4d56:	0e 94 9a 10 	call	0x2134	; 0x2134 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4d5a:	8b 81       	ldd	r24, Y+3	; 0x03
    4d5c:	9c 81       	ldd	r25, Y+4	; 0x04
    4d5e:	02 96       	adiw	r24, 0x02	; 2
    4d60:	0e 94 9a 10 	call	0x2134	; 0x2134 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4d64:	eb 81       	ldd	r30, Y+3	; 0x03
    4d66:	fc 81       	ldd	r31, Y+4	; 0x04
    4d68:	96 89       	ldd	r25, Z+22	; 0x16
    4d6a:	80 91 d4 06 	lds	r24, 0x06D4
    4d6e:	89 17       	cp	r24, r25
    4d70:	28 f4       	brcc	.+10     	; 0x4d7c <xTaskResumeAll+0x74>
    4d72:	eb 81       	ldd	r30, Y+3	; 0x03
    4d74:	fc 81       	ldd	r31, Y+4	; 0x04
    4d76:	86 89       	ldd	r24, Z+22	; 0x16
    4d78:	80 93 d4 06 	sts	0x06D4, r24
    4d7c:	eb 81       	ldd	r30, Y+3	; 0x03
    4d7e:	fc 81       	ldd	r31, Y+4	; 0x04
    4d80:	86 89       	ldd	r24, Z+22	; 0x16
    4d82:	28 2f       	mov	r18, r24
    4d84:	30 e0       	ldi	r19, 0x00	; 0
    4d86:	c9 01       	movw	r24, r18
    4d88:	88 0f       	add	r24, r24
    4d8a:	99 1f       	adc	r25, r25
    4d8c:	88 0f       	add	r24, r24
    4d8e:	99 1f       	adc	r25, r25
    4d90:	88 0f       	add	r24, r24
    4d92:	99 1f       	adc	r25, r25
    4d94:	82 0f       	add	r24, r18
    4d96:	93 1f       	adc	r25, r19
    4d98:	ac 01       	movw	r20, r24
    4d9a:	41 52       	subi	r20, 0x21	; 33
    4d9c:	59 4f       	sbci	r21, 0xF9	; 249
    4d9e:	8b 81       	ldd	r24, Y+3	; 0x03
    4da0:	9c 81       	ldd	r25, Y+4	; 0x04
    4da2:	9c 01       	movw	r18, r24
    4da4:	2e 5f       	subi	r18, 0xFE	; 254
    4da6:	3f 4f       	sbci	r19, 0xFF	; 255
    4da8:	ca 01       	movw	r24, r20
    4daa:	b9 01       	movw	r22, r18
    4dac:	0e 94 ea 0f 	call	0x1fd4	; 0x1fd4 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4db0:	eb 81       	ldd	r30, Y+3	; 0x03
    4db2:	fc 81       	ldd	r31, Y+4	; 0x04
    4db4:	96 89       	ldd	r25, Z+22	; 0x16
    4db6:	e0 91 ce 06 	lds	r30, 0x06CE
    4dba:	f0 91 cf 06 	lds	r31, 0x06CF
    4dbe:	86 89       	ldd	r24, Z+22	; 0x16
    4dc0:	98 17       	cp	r25, r24
    4dc2:	18 f0       	brcs	.+6      	; 0x4dca <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    4dc4:	81 e0       	ldi	r24, 0x01	; 1
    4dc6:	80 93 d7 06 	sts	0x06D7, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    4dca:	80 91 22 07 	lds	r24, 0x0722
    4dce:	88 23       	and	r24, r24
    4dd0:	09 f0       	breq	.+2      	; 0x4dd4 <xTaskResumeAll+0xcc>
    4dd2:	b6 cf       	rjmp	.-148    	; 0x4d40 <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    4dd4:	8b 81       	ldd	r24, Y+3	; 0x03
    4dd6:	9c 81       	ldd	r25, Y+4	; 0x04
    4dd8:	00 97       	sbiw	r24, 0x00	; 0
    4dda:	11 f0       	breq	.+4      	; 0x4de0 <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    4ddc:	0e 94 1e 2b 	call	0x563c	; 0x563c <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    4de0:	80 91 d6 06 	lds	r24, 0x06D6
    4de4:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    4de6:	89 81       	ldd	r24, Y+1	; 0x01
    4de8:	88 23       	and	r24, r24
    4dea:	79 f0       	breq	.+30     	; 0x4e0a <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    4dec:	0e 94 74 27 	call	0x4ee8	; 0x4ee8 <xTaskIncrementTick>
    4df0:	88 23       	and	r24, r24
    4df2:	19 f0       	breq	.+6      	; 0x4dfa <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    4df4:	81 e0       	ldi	r24, 0x01	; 1
    4df6:	80 93 d7 06 	sts	0x06D7, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    4dfa:	89 81       	ldd	r24, Y+1	; 0x01
    4dfc:	81 50       	subi	r24, 0x01	; 1
    4dfe:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    4e00:	89 81       	ldd	r24, Y+1	; 0x01
    4e02:	88 23       	and	r24, r24
    4e04:	99 f7       	brne	.-26     	; 0x4dec <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    4e06:	10 92 d6 06 	sts	0x06D6, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    4e0a:	80 91 d7 06 	lds	r24, 0x06D7
    4e0e:	88 23       	and	r24, r24
    4e10:	21 f0       	breq	.+8      	; 0x4e1a <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    4e12:	81 e0       	ldi	r24, 0x01	; 1
    4e14:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    4e16:	0e 94 c2 12 	call	0x2584	; 0x2584 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    4e1a:	0f 90       	pop	r0
    4e1c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    4e1e:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4e20:	0f 90       	pop	r0
    4e22:	0f 90       	pop	r0
    4e24:	0f 90       	pop	r0
    4e26:	0f 90       	pop	r0
    4e28:	cf 91       	pop	r28
    4e2a:	df 91       	pop	r29
    4e2c:	08 95       	ret

00004e2e <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    4e2e:	df 93       	push	r29
    4e30:	cf 93       	push	r28
    4e32:	00 d0       	rcall	.+0      	; 0x4e34 <xTaskGetTickCount+0x6>
    4e34:	cd b7       	in	r28, 0x3d	; 61
    4e36:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    4e38:	0f b6       	in	r0, 0x3f	; 63
    4e3a:	f8 94       	cli
    4e3c:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    4e3e:	80 91 d2 06 	lds	r24, 0x06D2
    4e42:	90 91 d3 06 	lds	r25, 0x06D3
    4e46:	9a 83       	std	Y+2, r25	; 0x02
    4e48:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    4e4a:	0f 90       	pop	r0
    4e4c:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    4e4e:	89 81       	ldd	r24, Y+1	; 0x01
    4e50:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4e52:	0f 90       	pop	r0
    4e54:	0f 90       	pop	r0
    4e56:	cf 91       	pop	r28
    4e58:	df 91       	pop	r29
    4e5a:	08 95       	ret

00004e5c <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    4e5c:	df 93       	push	r29
    4e5e:	cf 93       	push	r28
    4e60:	00 d0       	rcall	.+0      	; 0x4e62 <xTaskGetTickCountFromISR+0x6>
    4e62:	0f 92       	push	r0
    4e64:	cd b7       	in	r28, 0x3d	; 61
    4e66:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    4e68:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    4e6a:	80 91 d2 06 	lds	r24, 0x06D2
    4e6e:	90 91 d3 06 	lds	r25, 0x06D3
    4e72:	9b 83       	std	Y+3, r25	; 0x03
    4e74:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4e76:	8a 81       	ldd	r24, Y+2	; 0x02
    4e78:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4e7a:	0f 90       	pop	r0
    4e7c:	0f 90       	pop	r0
    4e7e:	0f 90       	pop	r0
    4e80:	cf 91       	pop	r28
    4e82:	df 91       	pop	r29
    4e84:	08 95       	ret

00004e86 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    4e86:	df 93       	push	r29
    4e88:	cf 93       	push	r28
    4e8a:	cd b7       	in	r28, 0x3d	; 61
    4e8c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    4e8e:	80 91 d1 06 	lds	r24, 0x06D1
}
    4e92:	cf 91       	pop	r28
    4e94:	df 91       	pop	r29
    4e96:	08 95       	ret

00004e98 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    4e98:	df 93       	push	r29
    4e9a:	cf 93       	push	r28
    4e9c:	00 d0       	rcall	.+0      	; 0x4e9e <pcTaskGetName+0x6>
    4e9e:	00 d0       	rcall	.+0      	; 0x4ea0 <pcTaskGetName+0x8>
    4ea0:	00 d0       	rcall	.+0      	; 0x4ea2 <pcTaskGetName+0xa>
    4ea2:	cd b7       	in	r28, 0x3d	; 61
    4ea4:	de b7       	in	r29, 0x3e	; 62
    4ea6:	9c 83       	std	Y+4, r25	; 0x04
    4ea8:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    4eaa:	8b 81       	ldd	r24, Y+3	; 0x03
    4eac:	9c 81       	ldd	r25, Y+4	; 0x04
    4eae:	00 97       	sbiw	r24, 0x00	; 0
    4eb0:	39 f4       	brne	.+14     	; 0x4ec0 <pcTaskGetName+0x28>
    4eb2:	80 91 ce 06 	lds	r24, 0x06CE
    4eb6:	90 91 cf 06 	lds	r25, 0x06CF
    4eba:	9e 83       	std	Y+6, r25	; 0x06
    4ebc:	8d 83       	std	Y+5, r24	; 0x05
    4ebe:	04 c0       	rjmp	.+8      	; 0x4ec8 <pcTaskGetName+0x30>
    4ec0:	8b 81       	ldd	r24, Y+3	; 0x03
    4ec2:	9c 81       	ldd	r25, Y+4	; 0x04
    4ec4:	9e 83       	std	Y+6, r25	; 0x06
    4ec6:	8d 83       	std	Y+5, r24	; 0x05
    4ec8:	8d 81       	ldd	r24, Y+5	; 0x05
    4eca:	9e 81       	ldd	r25, Y+6	; 0x06
    4ecc:	9a 83       	std	Y+2, r25	; 0x02
    4ece:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    4ed0:	89 81       	ldd	r24, Y+1	; 0x01
    4ed2:	9a 81       	ldd	r25, Y+2	; 0x02
    4ed4:	49 96       	adiw	r24, 0x19	; 25
}
    4ed6:	26 96       	adiw	r28, 0x06	; 6
    4ed8:	0f b6       	in	r0, 0x3f	; 63
    4eda:	f8 94       	cli
    4edc:	de bf       	out	0x3e, r29	; 62
    4ede:	0f be       	out	0x3f, r0	; 63
    4ee0:	cd bf       	out	0x3d, r28	; 61
    4ee2:	cf 91       	pop	r28
    4ee4:	df 91       	pop	r29
    4ee6:	08 95       	ret

00004ee8 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    4ee8:	df 93       	push	r29
    4eea:	cf 93       	push	r28
    4eec:	cd b7       	in	r28, 0x3d	; 61
    4eee:	de b7       	in	r29, 0x3e	; 62
    4ef0:	29 97       	sbiw	r28, 0x09	; 9
    4ef2:	0f b6       	in	r0, 0x3f	; 63
    4ef4:	f8 94       	cli
    4ef6:	de bf       	out	0x3e, r29	; 62
    4ef8:	0f be       	out	0x3f, r0	; 63
    4efa:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    4efc:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4efe:	80 91 de 06 	lds	r24, 0x06DE
    4f02:	88 23       	and	r24, r24
    4f04:	09 f0       	breq	.+2      	; 0x4f08 <xTaskIncrementTick+0x20>
    4f06:	c0 c0       	rjmp	.+384    	; 0x5088 <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    4f08:	80 91 d2 06 	lds	r24, 0x06D2
    4f0c:	90 91 d3 06 	lds	r25, 0x06D3
    4f10:	01 96       	adiw	r24, 0x01	; 1
    4f12:	9c 83       	std	Y+4, r25	; 0x04
    4f14:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    4f16:	8b 81       	ldd	r24, Y+3	; 0x03
    4f18:	9c 81       	ldd	r25, Y+4	; 0x04
    4f1a:	90 93 d3 06 	sts	0x06D3, r25
    4f1e:	80 93 d2 06 	sts	0x06D2, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    4f22:	8b 81       	ldd	r24, Y+3	; 0x03
    4f24:	9c 81       	ldd	r25, Y+4	; 0x04
    4f26:	00 97       	sbiw	r24, 0x00	; 0
    4f28:	d9 f4       	brne	.+54     	; 0x4f60 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    4f2a:	80 91 1e 07 	lds	r24, 0x071E
    4f2e:	90 91 1f 07 	lds	r25, 0x071F
    4f32:	9a 83       	std	Y+2, r25	; 0x02
    4f34:	89 83       	std	Y+1, r24	; 0x01
    4f36:	80 91 20 07 	lds	r24, 0x0720
    4f3a:	90 91 21 07 	lds	r25, 0x0721
    4f3e:	90 93 1f 07 	sts	0x071F, r25
    4f42:	80 93 1e 07 	sts	0x071E, r24
    4f46:	89 81       	ldd	r24, Y+1	; 0x01
    4f48:	9a 81       	ldd	r25, Y+2	; 0x02
    4f4a:	90 93 21 07 	sts	0x0721, r25
    4f4e:	80 93 20 07 	sts	0x0720, r24
    4f52:	80 91 d8 06 	lds	r24, 0x06D8
    4f56:	8f 5f       	subi	r24, 0xFF	; 255
    4f58:	80 93 d8 06 	sts	0x06D8, r24
    4f5c:	0e 94 1e 2b 	call	0x563c	; 0x563c <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    4f60:	20 91 da 06 	lds	r18, 0x06DA
    4f64:	30 91 db 06 	lds	r19, 0x06DB
    4f68:	8b 81       	ldd	r24, Y+3	; 0x03
    4f6a:	9c 81       	ldd	r25, Y+4	; 0x04
    4f6c:	82 17       	cp	r24, r18
    4f6e:	93 07       	cpc	r25, r19
    4f70:	08 f4       	brcc	.+2      	; 0x4f74 <xTaskIncrementTick+0x8c>
    4f72:	71 c0       	rjmp	.+226    	; 0x5056 <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4f74:	e0 91 1e 07 	lds	r30, 0x071E
    4f78:	f0 91 1f 07 	lds	r31, 0x071F
    4f7c:	80 81       	ld	r24, Z
    4f7e:	88 23       	and	r24, r24
    4f80:	39 f4       	brne	.+14     	; 0x4f90 <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4f82:	8f ef       	ldi	r24, 0xFF	; 255
    4f84:	9f ef       	ldi	r25, 0xFF	; 255
    4f86:	90 93 db 06 	sts	0x06DB, r25
    4f8a:	80 93 da 06 	sts	0x06DA, r24
    4f8e:	63 c0       	rjmp	.+198    	; 0x5056 <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4f90:	e0 91 1e 07 	lds	r30, 0x071E
    4f94:	f0 91 1f 07 	lds	r31, 0x071F
    4f98:	05 80       	ldd	r0, Z+5	; 0x05
    4f9a:	f6 81       	ldd	r31, Z+6	; 0x06
    4f9c:	e0 2d       	mov	r30, r0
    4f9e:	86 81       	ldd	r24, Z+6	; 0x06
    4fa0:	97 81       	ldd	r25, Z+7	; 0x07
    4fa2:	99 87       	std	Y+9, r25	; 0x09
    4fa4:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    4fa6:	e8 85       	ldd	r30, Y+8	; 0x08
    4fa8:	f9 85       	ldd	r31, Y+9	; 0x09
    4faa:	82 81       	ldd	r24, Z+2	; 0x02
    4fac:	93 81       	ldd	r25, Z+3	; 0x03
    4fae:	9f 83       	std	Y+7, r25	; 0x07
    4fb0:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    4fb2:	2b 81       	ldd	r18, Y+3	; 0x03
    4fb4:	3c 81       	ldd	r19, Y+4	; 0x04
    4fb6:	8e 81       	ldd	r24, Y+6	; 0x06
    4fb8:	9f 81       	ldd	r25, Y+7	; 0x07
    4fba:	28 17       	cp	r18, r24
    4fbc:	39 07       	cpc	r19, r25
    4fbe:	38 f4       	brcc	.+14     	; 0x4fce <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    4fc0:	8e 81       	ldd	r24, Y+6	; 0x06
    4fc2:	9f 81       	ldd	r25, Y+7	; 0x07
    4fc4:	90 93 db 06 	sts	0x06DB, r25
    4fc8:	80 93 da 06 	sts	0x06DA, r24
    4fcc:	44 c0       	rjmp	.+136    	; 0x5056 <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4fce:	88 85       	ldd	r24, Y+8	; 0x08
    4fd0:	99 85       	ldd	r25, Y+9	; 0x09
    4fd2:	02 96       	adiw	r24, 0x02	; 2
    4fd4:	0e 94 9a 10 	call	0x2134	; 0x2134 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4fd8:	e8 85       	ldd	r30, Y+8	; 0x08
    4fda:	f9 85       	ldd	r31, Y+9	; 0x09
    4fdc:	84 89       	ldd	r24, Z+20	; 0x14
    4fde:	95 89       	ldd	r25, Z+21	; 0x15
    4fe0:	00 97       	sbiw	r24, 0x00	; 0
    4fe2:	29 f0       	breq	.+10     	; 0x4fee <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4fe4:	88 85       	ldd	r24, Y+8	; 0x08
    4fe6:	99 85       	ldd	r25, Y+9	; 0x09
    4fe8:	0c 96       	adiw	r24, 0x0c	; 12
    4fea:	0e 94 9a 10 	call	0x2134	; 0x2134 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    4fee:	e8 85       	ldd	r30, Y+8	; 0x08
    4ff0:	f9 85       	ldd	r31, Y+9	; 0x09
    4ff2:	96 89       	ldd	r25, Z+22	; 0x16
    4ff4:	80 91 d4 06 	lds	r24, 0x06D4
    4ff8:	89 17       	cp	r24, r25
    4ffa:	28 f4       	brcc	.+10     	; 0x5006 <xTaskIncrementTick+0x11e>
    4ffc:	e8 85       	ldd	r30, Y+8	; 0x08
    4ffe:	f9 85       	ldd	r31, Y+9	; 0x09
    5000:	86 89       	ldd	r24, Z+22	; 0x16
    5002:	80 93 d4 06 	sts	0x06D4, r24
    5006:	e8 85       	ldd	r30, Y+8	; 0x08
    5008:	f9 85       	ldd	r31, Y+9	; 0x09
    500a:	86 89       	ldd	r24, Z+22	; 0x16
    500c:	28 2f       	mov	r18, r24
    500e:	30 e0       	ldi	r19, 0x00	; 0
    5010:	c9 01       	movw	r24, r18
    5012:	88 0f       	add	r24, r24
    5014:	99 1f       	adc	r25, r25
    5016:	88 0f       	add	r24, r24
    5018:	99 1f       	adc	r25, r25
    501a:	88 0f       	add	r24, r24
    501c:	99 1f       	adc	r25, r25
    501e:	82 0f       	add	r24, r18
    5020:	93 1f       	adc	r25, r19
    5022:	ac 01       	movw	r20, r24
    5024:	41 52       	subi	r20, 0x21	; 33
    5026:	59 4f       	sbci	r21, 0xF9	; 249
    5028:	88 85       	ldd	r24, Y+8	; 0x08
    502a:	99 85       	ldd	r25, Y+9	; 0x09
    502c:	9c 01       	movw	r18, r24
    502e:	2e 5f       	subi	r18, 0xFE	; 254
    5030:	3f 4f       	sbci	r19, 0xFF	; 255
    5032:	ca 01       	movw	r24, r20
    5034:	b9 01       	movw	r22, r18
    5036:	0e 94 ea 0f 	call	0x1fd4	; 0x1fd4 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    503a:	e8 85       	ldd	r30, Y+8	; 0x08
    503c:	f9 85       	ldd	r31, Y+9	; 0x09
    503e:	96 89       	ldd	r25, Z+22	; 0x16
    5040:	e0 91 ce 06 	lds	r30, 0x06CE
    5044:	f0 91 cf 06 	lds	r31, 0x06CF
    5048:	86 89       	ldd	r24, Z+22	; 0x16
    504a:	98 17       	cp	r25, r24
    504c:	08 f4       	brcc	.+2      	; 0x5050 <xTaskIncrementTick+0x168>
    504e:	92 cf       	rjmp	.-220    	; 0x4f74 <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    5050:	81 e0       	ldi	r24, 0x01	; 1
    5052:	8d 83       	std	Y+5, r24	; 0x05
    5054:	8f cf       	rjmp	.-226    	; 0x4f74 <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    5056:	e0 91 ce 06 	lds	r30, 0x06CE
    505a:	f0 91 cf 06 	lds	r31, 0x06CF
    505e:	86 89       	ldd	r24, Z+22	; 0x16
    5060:	28 2f       	mov	r18, r24
    5062:	30 e0       	ldi	r19, 0x00	; 0
    5064:	c9 01       	movw	r24, r18
    5066:	88 0f       	add	r24, r24
    5068:	99 1f       	adc	r25, r25
    506a:	88 0f       	add	r24, r24
    506c:	99 1f       	adc	r25, r25
    506e:	88 0f       	add	r24, r24
    5070:	99 1f       	adc	r25, r25
    5072:	82 0f       	add	r24, r18
    5074:	93 1f       	adc	r25, r19
    5076:	fc 01       	movw	r30, r24
    5078:	e1 52       	subi	r30, 0x21	; 33
    507a:	f9 4f       	sbci	r31, 0xF9	; 249
    507c:	80 81       	ld	r24, Z
    507e:	82 30       	cpi	r24, 0x02	; 2
    5080:	40 f0       	brcs	.+16     	; 0x5092 <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    5082:	81 e0       	ldi	r24, 0x01	; 1
    5084:	8d 83       	std	Y+5, r24	; 0x05
    5086:	05 c0       	rjmp	.+10     	; 0x5092 <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    5088:	80 91 d6 06 	lds	r24, 0x06D6
    508c:	8f 5f       	subi	r24, 0xFF	; 255
    508e:	80 93 d6 06 	sts	0x06D6, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    5092:	80 91 d7 06 	lds	r24, 0x06D7
    5096:	88 23       	and	r24, r24
    5098:	11 f0       	breq	.+4      	; 0x509e <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    509a:	81 e0       	ldi	r24, 0x01	; 1
    509c:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    509e:	8d 81       	ldd	r24, Y+5	; 0x05
}
    50a0:	29 96       	adiw	r28, 0x09	; 9
    50a2:	0f b6       	in	r0, 0x3f	; 63
    50a4:	f8 94       	cli
    50a6:	de bf       	out	0x3e, r29	; 62
    50a8:	0f be       	out	0x3f, r0	; 63
    50aa:	cd bf       	out	0x3d, r28	; 61
    50ac:	cf 91       	pop	r28
    50ae:	df 91       	pop	r29
    50b0:	08 95       	ret

000050b2 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    50b2:	df 93       	push	r29
    50b4:	cf 93       	push	r28
    50b6:	00 d0       	rcall	.+0      	; 0x50b8 <vTaskSwitchContext+0x6>
    50b8:	0f 92       	push	r0
    50ba:	cd b7       	in	r28, 0x3d	; 61
    50bc:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    50be:	80 91 de 06 	lds	r24, 0x06DE
    50c2:	88 23       	and	r24, r24
    50c4:	21 f0       	breq	.+8      	; 0x50ce <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    50c6:	81 e0       	ldi	r24, 0x01	; 1
    50c8:	80 93 d7 06 	sts	0x06D7, r24
    50cc:	59 c0       	rjmp	.+178    	; 0x5180 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    50ce:	10 92 d7 06 	sts	0x06D7, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    50d2:	80 91 d4 06 	lds	r24, 0x06D4
    50d6:	8b 83       	std	Y+3, r24	; 0x03
    50d8:	03 c0       	rjmp	.+6      	; 0x50e0 <vTaskSwitchContext+0x2e>
    50da:	8b 81       	ldd	r24, Y+3	; 0x03
    50dc:	81 50       	subi	r24, 0x01	; 1
    50de:	8b 83       	std	Y+3, r24	; 0x03
    50e0:	8b 81       	ldd	r24, Y+3	; 0x03
    50e2:	28 2f       	mov	r18, r24
    50e4:	30 e0       	ldi	r19, 0x00	; 0
    50e6:	c9 01       	movw	r24, r18
    50e8:	88 0f       	add	r24, r24
    50ea:	99 1f       	adc	r25, r25
    50ec:	88 0f       	add	r24, r24
    50ee:	99 1f       	adc	r25, r25
    50f0:	88 0f       	add	r24, r24
    50f2:	99 1f       	adc	r25, r25
    50f4:	82 0f       	add	r24, r18
    50f6:	93 1f       	adc	r25, r19
    50f8:	fc 01       	movw	r30, r24
    50fa:	e1 52       	subi	r30, 0x21	; 33
    50fc:	f9 4f       	sbci	r31, 0xF9	; 249
    50fe:	80 81       	ld	r24, Z
    5100:	88 23       	and	r24, r24
    5102:	59 f3       	breq	.-42     	; 0x50da <vTaskSwitchContext+0x28>
    5104:	8b 81       	ldd	r24, Y+3	; 0x03
    5106:	28 2f       	mov	r18, r24
    5108:	30 e0       	ldi	r19, 0x00	; 0
    510a:	c9 01       	movw	r24, r18
    510c:	88 0f       	add	r24, r24
    510e:	99 1f       	adc	r25, r25
    5110:	88 0f       	add	r24, r24
    5112:	99 1f       	adc	r25, r25
    5114:	88 0f       	add	r24, r24
    5116:	99 1f       	adc	r25, r25
    5118:	82 0f       	add	r24, r18
    511a:	93 1f       	adc	r25, r19
    511c:	81 52       	subi	r24, 0x21	; 33
    511e:	99 4f       	sbci	r25, 0xF9	; 249
    5120:	9a 83       	std	Y+2, r25	; 0x02
    5122:	89 83       	std	Y+1, r24	; 0x01
    5124:	e9 81       	ldd	r30, Y+1	; 0x01
    5126:	fa 81       	ldd	r31, Y+2	; 0x02
    5128:	01 80       	ldd	r0, Z+1	; 0x01
    512a:	f2 81       	ldd	r31, Z+2	; 0x02
    512c:	e0 2d       	mov	r30, r0
    512e:	82 81       	ldd	r24, Z+2	; 0x02
    5130:	93 81       	ldd	r25, Z+3	; 0x03
    5132:	e9 81       	ldd	r30, Y+1	; 0x01
    5134:	fa 81       	ldd	r31, Y+2	; 0x02
    5136:	92 83       	std	Z+2, r25	; 0x02
    5138:	81 83       	std	Z+1, r24	; 0x01
    513a:	e9 81       	ldd	r30, Y+1	; 0x01
    513c:	fa 81       	ldd	r31, Y+2	; 0x02
    513e:	21 81       	ldd	r18, Z+1	; 0x01
    5140:	32 81       	ldd	r19, Z+2	; 0x02
    5142:	89 81       	ldd	r24, Y+1	; 0x01
    5144:	9a 81       	ldd	r25, Y+2	; 0x02
    5146:	03 96       	adiw	r24, 0x03	; 3
    5148:	28 17       	cp	r18, r24
    514a:	39 07       	cpc	r19, r25
    514c:	59 f4       	brne	.+22     	; 0x5164 <vTaskSwitchContext+0xb2>
    514e:	e9 81       	ldd	r30, Y+1	; 0x01
    5150:	fa 81       	ldd	r31, Y+2	; 0x02
    5152:	01 80       	ldd	r0, Z+1	; 0x01
    5154:	f2 81       	ldd	r31, Z+2	; 0x02
    5156:	e0 2d       	mov	r30, r0
    5158:	82 81       	ldd	r24, Z+2	; 0x02
    515a:	93 81       	ldd	r25, Z+3	; 0x03
    515c:	e9 81       	ldd	r30, Y+1	; 0x01
    515e:	fa 81       	ldd	r31, Y+2	; 0x02
    5160:	92 83       	std	Z+2, r25	; 0x02
    5162:	81 83       	std	Z+1, r24	; 0x01
    5164:	e9 81       	ldd	r30, Y+1	; 0x01
    5166:	fa 81       	ldd	r31, Y+2	; 0x02
    5168:	01 80       	ldd	r0, Z+1	; 0x01
    516a:	f2 81       	ldd	r31, Z+2	; 0x02
    516c:	e0 2d       	mov	r30, r0
    516e:	86 81       	ldd	r24, Z+6	; 0x06
    5170:	97 81       	ldd	r25, Z+7	; 0x07
    5172:	90 93 cf 06 	sts	0x06CF, r25
    5176:	80 93 ce 06 	sts	0x06CE, r24
    517a:	8b 81       	ldd	r24, Y+3	; 0x03
    517c:	80 93 d4 06 	sts	0x06D4, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    5180:	0f 90       	pop	r0
    5182:	0f 90       	pop	r0
    5184:	0f 90       	pop	r0
    5186:	cf 91       	pop	r28
    5188:	df 91       	pop	r29
    518a:	08 95       	ret

0000518c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    518c:	df 93       	push	r29
    518e:	cf 93       	push	r28
    5190:	00 d0       	rcall	.+0      	; 0x5192 <vTaskPlaceOnEventList+0x6>
    5192:	00 d0       	rcall	.+0      	; 0x5194 <vTaskPlaceOnEventList+0x8>
    5194:	cd b7       	in	r28, 0x3d	; 61
    5196:	de b7       	in	r29, 0x3e	; 62
    5198:	9a 83       	std	Y+2, r25	; 0x02
    519a:	89 83       	std	Y+1, r24	; 0x01
    519c:	7c 83       	std	Y+4, r23	; 0x04
    519e:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    51a0:	80 91 ce 06 	lds	r24, 0x06CE
    51a4:	90 91 cf 06 	lds	r25, 0x06CF
    51a8:	9c 01       	movw	r18, r24
    51aa:	24 5f       	subi	r18, 0xF4	; 244
    51ac:	3f 4f       	sbci	r19, 0xFF	; 255
    51ae:	89 81       	ldd	r24, Y+1	; 0x01
    51b0:	9a 81       	ldd	r25, Y+2	; 0x02
    51b2:	b9 01       	movw	r22, r18
    51b4:	0e 94 2e 10 	call	0x205c	; 0x205c <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    51b8:	8b 81       	ldd	r24, Y+3	; 0x03
    51ba:	9c 81       	ldd	r25, Y+4	; 0x04
    51bc:	61 e0       	ldi	r22, 0x01	; 1
    51be:	0e 94 2a 2f 	call	0x5e54	; 0x5e54 <prvAddCurrentTaskToDelayedList>
}
    51c2:	0f 90       	pop	r0
    51c4:	0f 90       	pop	r0
    51c6:	0f 90       	pop	r0
    51c8:	0f 90       	pop	r0
    51ca:	cf 91       	pop	r28
    51cc:	df 91       	pop	r29
    51ce:	08 95       	ret

000051d0 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    51d0:	df 93       	push	r29
    51d2:	cf 93       	push	r28
    51d4:	00 d0       	rcall	.+0      	; 0x51d6 <vTaskPlaceOnUnorderedEventList+0x6>
    51d6:	00 d0       	rcall	.+0      	; 0x51d8 <vTaskPlaceOnUnorderedEventList+0x8>
    51d8:	00 d0       	rcall	.+0      	; 0x51da <vTaskPlaceOnUnorderedEventList+0xa>
    51da:	cd b7       	in	r28, 0x3d	; 61
    51dc:	de b7       	in	r29, 0x3e	; 62
    51de:	9a 83       	std	Y+2, r25	; 0x02
    51e0:	89 83       	std	Y+1, r24	; 0x01
    51e2:	7c 83       	std	Y+4, r23	; 0x04
    51e4:	6b 83       	std	Y+3, r22	; 0x03
    51e6:	5e 83       	std	Y+6, r21	; 0x06
    51e8:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    51ea:	e0 91 ce 06 	lds	r30, 0x06CE
    51ee:	f0 91 cf 06 	lds	r31, 0x06CF
    51f2:	8b 81       	ldd	r24, Y+3	; 0x03
    51f4:	9c 81       	ldd	r25, Y+4	; 0x04
    51f6:	90 68       	ori	r25, 0x80	; 128
    51f8:	95 87       	std	Z+13, r25	; 0x0d
    51fa:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    51fc:	80 91 ce 06 	lds	r24, 0x06CE
    5200:	90 91 cf 06 	lds	r25, 0x06CF
    5204:	9c 01       	movw	r18, r24
    5206:	24 5f       	subi	r18, 0xF4	; 244
    5208:	3f 4f       	sbci	r19, 0xFF	; 255
    520a:	89 81       	ldd	r24, Y+1	; 0x01
    520c:	9a 81       	ldd	r25, Y+2	; 0x02
    520e:	b9 01       	movw	r22, r18
    5210:	0e 94 ea 0f 	call	0x1fd4	; 0x1fd4 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5214:	8d 81       	ldd	r24, Y+5	; 0x05
    5216:	9e 81       	ldd	r25, Y+6	; 0x06
    5218:	61 e0       	ldi	r22, 0x01	; 1
    521a:	0e 94 2a 2f 	call	0x5e54	; 0x5e54 <prvAddCurrentTaskToDelayedList>
}
    521e:	26 96       	adiw	r28, 0x06	; 6
    5220:	0f b6       	in	r0, 0x3f	; 63
    5222:	f8 94       	cli
    5224:	de bf       	out	0x3e, r29	; 62
    5226:	0f be       	out	0x3f, r0	; 63
    5228:	cd bf       	out	0x3d, r28	; 61
    522a:	cf 91       	pop	r28
    522c:	df 91       	pop	r29
    522e:	08 95       	ret

00005230 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    5230:	df 93       	push	r29
    5232:	cf 93       	push	r28
    5234:	00 d0       	rcall	.+0      	; 0x5236 <xTaskRemoveFromEventList+0x6>
    5236:	00 d0       	rcall	.+0      	; 0x5238 <xTaskRemoveFromEventList+0x8>
    5238:	0f 92       	push	r0
    523a:	cd b7       	in	r28, 0x3d	; 61
    523c:	de b7       	in	r29, 0x3e	; 62
    523e:	9d 83       	std	Y+5, r25	; 0x05
    5240:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5242:	ec 81       	ldd	r30, Y+4	; 0x04
    5244:	fd 81       	ldd	r31, Y+5	; 0x05
    5246:	05 80       	ldd	r0, Z+5	; 0x05
    5248:	f6 81       	ldd	r31, Z+6	; 0x06
    524a:	e0 2d       	mov	r30, r0
    524c:	86 81       	ldd	r24, Z+6	; 0x06
    524e:	97 81       	ldd	r25, Z+7	; 0x07
    5250:	9b 83       	std	Y+3, r25	; 0x03
    5252:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    5254:	8a 81       	ldd	r24, Y+2	; 0x02
    5256:	9b 81       	ldd	r25, Y+3	; 0x03
    5258:	0c 96       	adiw	r24, 0x0c	; 12
    525a:	0e 94 9a 10 	call	0x2134	; 0x2134 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    525e:	80 91 de 06 	lds	r24, 0x06DE
    5262:	88 23       	and	r24, r24
    5264:	61 f5       	brne	.+88     	; 0x52be <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    5266:	8a 81       	ldd	r24, Y+2	; 0x02
    5268:	9b 81       	ldd	r25, Y+3	; 0x03
    526a:	02 96       	adiw	r24, 0x02	; 2
    526c:	0e 94 9a 10 	call	0x2134	; 0x2134 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    5270:	ea 81       	ldd	r30, Y+2	; 0x02
    5272:	fb 81       	ldd	r31, Y+3	; 0x03
    5274:	96 89       	ldd	r25, Z+22	; 0x16
    5276:	80 91 d4 06 	lds	r24, 0x06D4
    527a:	89 17       	cp	r24, r25
    527c:	28 f4       	brcc	.+10     	; 0x5288 <xTaskRemoveFromEventList+0x58>
    527e:	ea 81       	ldd	r30, Y+2	; 0x02
    5280:	fb 81       	ldd	r31, Y+3	; 0x03
    5282:	86 89       	ldd	r24, Z+22	; 0x16
    5284:	80 93 d4 06 	sts	0x06D4, r24
    5288:	ea 81       	ldd	r30, Y+2	; 0x02
    528a:	fb 81       	ldd	r31, Y+3	; 0x03
    528c:	86 89       	ldd	r24, Z+22	; 0x16
    528e:	28 2f       	mov	r18, r24
    5290:	30 e0       	ldi	r19, 0x00	; 0
    5292:	c9 01       	movw	r24, r18
    5294:	88 0f       	add	r24, r24
    5296:	99 1f       	adc	r25, r25
    5298:	88 0f       	add	r24, r24
    529a:	99 1f       	adc	r25, r25
    529c:	88 0f       	add	r24, r24
    529e:	99 1f       	adc	r25, r25
    52a0:	82 0f       	add	r24, r18
    52a2:	93 1f       	adc	r25, r19
    52a4:	ac 01       	movw	r20, r24
    52a6:	41 52       	subi	r20, 0x21	; 33
    52a8:	59 4f       	sbci	r21, 0xF9	; 249
    52aa:	8a 81       	ldd	r24, Y+2	; 0x02
    52ac:	9b 81       	ldd	r25, Y+3	; 0x03
    52ae:	9c 01       	movw	r18, r24
    52b0:	2e 5f       	subi	r18, 0xFE	; 254
    52b2:	3f 4f       	sbci	r19, 0xFF	; 255
    52b4:	ca 01       	movw	r24, r20
    52b6:	b9 01       	movw	r22, r18
    52b8:	0e 94 ea 0f 	call	0x1fd4	; 0x1fd4 <vListInsertEnd>
    52bc:	0a c0       	rjmp	.+20     	; 0x52d2 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    52be:	8a 81       	ldd	r24, Y+2	; 0x02
    52c0:	9b 81       	ldd	r25, Y+3	; 0x03
    52c2:	9c 01       	movw	r18, r24
    52c4:	24 5f       	subi	r18, 0xF4	; 244
    52c6:	3f 4f       	sbci	r19, 0xFF	; 255
    52c8:	82 e2       	ldi	r24, 0x22	; 34
    52ca:	97 e0       	ldi	r25, 0x07	; 7
    52cc:	b9 01       	movw	r22, r18
    52ce:	0e 94 ea 0f 	call	0x1fd4	; 0x1fd4 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    52d2:	ea 81       	ldd	r30, Y+2	; 0x02
    52d4:	fb 81       	ldd	r31, Y+3	; 0x03
    52d6:	96 89       	ldd	r25, Z+22	; 0x16
    52d8:	e0 91 ce 06 	lds	r30, 0x06CE
    52dc:	f0 91 cf 06 	lds	r31, 0x06CF
    52e0:	86 89       	ldd	r24, Z+22	; 0x16
    52e2:	89 17       	cp	r24, r25
    52e4:	30 f4       	brcc	.+12     	; 0x52f2 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    52e6:	81 e0       	ldi	r24, 0x01	; 1
    52e8:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    52ea:	81 e0       	ldi	r24, 0x01	; 1
    52ec:	80 93 d7 06 	sts	0x06D7, r24
    52f0:	01 c0       	rjmp	.+2      	; 0x52f4 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    52f2:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    52f4:	89 81       	ldd	r24, Y+1	; 0x01
}
    52f6:	0f 90       	pop	r0
    52f8:	0f 90       	pop	r0
    52fa:	0f 90       	pop	r0
    52fc:	0f 90       	pop	r0
    52fe:	0f 90       	pop	r0
    5300:	cf 91       	pop	r28
    5302:	df 91       	pop	r29
    5304:	08 95       	ret

00005306 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    5306:	df 93       	push	r29
    5308:	cf 93       	push	r28
    530a:	00 d0       	rcall	.+0      	; 0x530c <vTaskRemoveFromUnorderedEventList+0x6>
    530c:	00 d0       	rcall	.+0      	; 0x530e <vTaskRemoveFromUnorderedEventList+0x8>
    530e:	00 d0       	rcall	.+0      	; 0x5310 <vTaskRemoveFromUnorderedEventList+0xa>
    5310:	cd b7       	in	r28, 0x3d	; 61
    5312:	de b7       	in	r29, 0x3e	; 62
    5314:	9c 83       	std	Y+4, r25	; 0x04
    5316:	8b 83       	std	Y+3, r24	; 0x03
    5318:	7e 83       	std	Y+6, r23	; 0x06
    531a:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    531c:	8d 81       	ldd	r24, Y+5	; 0x05
    531e:	9e 81       	ldd	r25, Y+6	; 0x06
    5320:	90 68       	ori	r25, 0x80	; 128
    5322:	eb 81       	ldd	r30, Y+3	; 0x03
    5324:	fc 81       	ldd	r31, Y+4	; 0x04
    5326:	91 83       	std	Z+1, r25	; 0x01
    5328:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    532a:	eb 81       	ldd	r30, Y+3	; 0x03
    532c:	fc 81       	ldd	r31, Y+4	; 0x04
    532e:	86 81       	ldd	r24, Z+6	; 0x06
    5330:	97 81       	ldd	r25, Z+7	; 0x07
    5332:	9a 83       	std	Y+2, r25	; 0x02
    5334:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    5336:	8b 81       	ldd	r24, Y+3	; 0x03
    5338:	9c 81       	ldd	r25, Y+4	; 0x04
    533a:	0e 94 9a 10 	call	0x2134	; 0x2134 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    533e:	89 81       	ldd	r24, Y+1	; 0x01
    5340:	9a 81       	ldd	r25, Y+2	; 0x02
    5342:	02 96       	adiw	r24, 0x02	; 2
    5344:	0e 94 9a 10 	call	0x2134	; 0x2134 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    5348:	e9 81       	ldd	r30, Y+1	; 0x01
    534a:	fa 81       	ldd	r31, Y+2	; 0x02
    534c:	96 89       	ldd	r25, Z+22	; 0x16
    534e:	80 91 d4 06 	lds	r24, 0x06D4
    5352:	89 17       	cp	r24, r25
    5354:	28 f4       	brcc	.+10     	; 0x5360 <vTaskRemoveFromUnorderedEventList+0x5a>
    5356:	e9 81       	ldd	r30, Y+1	; 0x01
    5358:	fa 81       	ldd	r31, Y+2	; 0x02
    535a:	86 89       	ldd	r24, Z+22	; 0x16
    535c:	80 93 d4 06 	sts	0x06D4, r24
    5360:	e9 81       	ldd	r30, Y+1	; 0x01
    5362:	fa 81       	ldd	r31, Y+2	; 0x02
    5364:	86 89       	ldd	r24, Z+22	; 0x16
    5366:	28 2f       	mov	r18, r24
    5368:	30 e0       	ldi	r19, 0x00	; 0
    536a:	c9 01       	movw	r24, r18
    536c:	88 0f       	add	r24, r24
    536e:	99 1f       	adc	r25, r25
    5370:	88 0f       	add	r24, r24
    5372:	99 1f       	adc	r25, r25
    5374:	88 0f       	add	r24, r24
    5376:	99 1f       	adc	r25, r25
    5378:	82 0f       	add	r24, r18
    537a:	93 1f       	adc	r25, r19
    537c:	ac 01       	movw	r20, r24
    537e:	41 52       	subi	r20, 0x21	; 33
    5380:	59 4f       	sbci	r21, 0xF9	; 249
    5382:	89 81       	ldd	r24, Y+1	; 0x01
    5384:	9a 81       	ldd	r25, Y+2	; 0x02
    5386:	9c 01       	movw	r18, r24
    5388:	2e 5f       	subi	r18, 0xFE	; 254
    538a:	3f 4f       	sbci	r19, 0xFF	; 255
    538c:	ca 01       	movw	r24, r20
    538e:	b9 01       	movw	r22, r18
    5390:	0e 94 ea 0f 	call	0x1fd4	; 0x1fd4 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    5394:	e9 81       	ldd	r30, Y+1	; 0x01
    5396:	fa 81       	ldd	r31, Y+2	; 0x02
    5398:	96 89       	ldd	r25, Z+22	; 0x16
    539a:	e0 91 ce 06 	lds	r30, 0x06CE
    539e:	f0 91 cf 06 	lds	r31, 0x06CF
    53a2:	86 89       	ldd	r24, Z+22	; 0x16
    53a4:	89 17       	cp	r24, r25
    53a6:	18 f4       	brcc	.+6      	; 0x53ae <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    53a8:	81 e0       	ldi	r24, 0x01	; 1
    53aa:	80 93 d7 06 	sts	0x06D7, r24
	}
}
    53ae:	26 96       	adiw	r28, 0x06	; 6
    53b0:	0f b6       	in	r0, 0x3f	; 63
    53b2:	f8 94       	cli
    53b4:	de bf       	out	0x3e, r29	; 62
    53b6:	0f be       	out	0x3f, r0	; 63
    53b8:	cd bf       	out	0x3d, r28	; 61
    53ba:	cf 91       	pop	r28
    53bc:	df 91       	pop	r29
    53be:	08 95       	ret

000053c0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    53c0:	df 93       	push	r29
    53c2:	cf 93       	push	r28
    53c4:	00 d0       	rcall	.+0      	; 0x53c6 <vTaskSetTimeOutState+0x6>
    53c6:	cd b7       	in	r28, 0x3d	; 61
    53c8:	de b7       	in	r29, 0x3e	; 62
    53ca:	9a 83       	std	Y+2, r25	; 0x02
    53cc:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    53ce:	0f b6       	in	r0, 0x3f	; 63
    53d0:	f8 94       	cli
    53d2:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    53d4:	80 91 d8 06 	lds	r24, 0x06D8
    53d8:	e9 81       	ldd	r30, Y+1	; 0x01
    53da:	fa 81       	ldd	r31, Y+2	; 0x02
    53dc:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    53de:	80 91 d2 06 	lds	r24, 0x06D2
    53e2:	90 91 d3 06 	lds	r25, 0x06D3
    53e6:	e9 81       	ldd	r30, Y+1	; 0x01
    53e8:	fa 81       	ldd	r31, Y+2	; 0x02
    53ea:	92 83       	std	Z+2, r25	; 0x02
    53ec:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    53ee:	0f 90       	pop	r0
    53f0:	0f be       	out	0x3f, r0	; 63
}
    53f2:	0f 90       	pop	r0
    53f4:	0f 90       	pop	r0
    53f6:	cf 91       	pop	r28
    53f8:	df 91       	pop	r29
    53fa:	08 95       	ret

000053fc <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    53fc:	df 93       	push	r29
    53fe:	cf 93       	push	r28
    5400:	00 d0       	rcall	.+0      	; 0x5402 <vTaskInternalSetTimeOutState+0x6>
    5402:	cd b7       	in	r28, 0x3d	; 61
    5404:	de b7       	in	r29, 0x3e	; 62
    5406:	9a 83       	std	Y+2, r25	; 0x02
    5408:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    540a:	80 91 d8 06 	lds	r24, 0x06D8
    540e:	e9 81       	ldd	r30, Y+1	; 0x01
    5410:	fa 81       	ldd	r31, Y+2	; 0x02
    5412:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    5414:	80 91 d2 06 	lds	r24, 0x06D2
    5418:	90 91 d3 06 	lds	r25, 0x06D3
    541c:	e9 81       	ldd	r30, Y+1	; 0x01
    541e:	fa 81       	ldd	r31, Y+2	; 0x02
    5420:	92 83       	std	Z+2, r25	; 0x02
    5422:	81 83       	std	Z+1, r24	; 0x01
}
    5424:	0f 90       	pop	r0
    5426:	0f 90       	pop	r0
    5428:	cf 91       	pop	r28
    542a:	df 91       	pop	r29
    542c:	08 95       	ret

0000542e <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    542e:	df 93       	push	r29
    5430:	cf 93       	push	r28
    5432:	cd b7       	in	r28, 0x3d	; 61
    5434:	de b7       	in	r29, 0x3e	; 62
    5436:	29 97       	sbiw	r28, 0x09	; 9
    5438:	0f b6       	in	r0, 0x3f	; 63
    543a:	f8 94       	cli
    543c:	de bf       	out	0x3e, r29	; 62
    543e:	0f be       	out	0x3f, r0	; 63
    5440:	cd bf       	out	0x3d, r28	; 61
    5442:	9f 83       	std	Y+7, r25	; 0x07
    5444:	8e 83       	std	Y+6, r24	; 0x06
    5446:	79 87       	std	Y+9, r23	; 0x09
    5448:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    544a:	0f b6       	in	r0, 0x3f	; 63
    544c:	f8 94       	cli
    544e:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    5450:	80 91 d2 06 	lds	r24, 0x06D2
    5454:	90 91 d3 06 	lds	r25, 0x06D3
    5458:	9c 83       	std	Y+4, r25	; 0x04
    545a:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    545c:	ee 81       	ldd	r30, Y+6	; 0x06
    545e:	ff 81       	ldd	r31, Y+7	; 0x07
    5460:	21 81       	ldd	r18, Z+1	; 0x01
    5462:	32 81       	ldd	r19, Z+2	; 0x02
    5464:	8b 81       	ldd	r24, Y+3	; 0x03
    5466:	9c 81       	ldd	r25, Y+4	; 0x04
    5468:	82 1b       	sub	r24, r18
    546a:	93 0b       	sbc	r25, r19
    546c:	9a 83       	std	Y+2, r25	; 0x02
    546e:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    5470:	e8 85       	ldd	r30, Y+8	; 0x08
    5472:	f9 85       	ldd	r31, Y+9	; 0x09
    5474:	80 81       	ld	r24, Z
    5476:	91 81       	ldd	r25, Z+1	; 0x01
    5478:	2f ef       	ldi	r18, 0xFF	; 255
    547a:	8f 3f       	cpi	r24, 0xFF	; 255
    547c:	92 07       	cpc	r25, r18
    547e:	11 f4       	brne	.+4      	; 0x5484 <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    5480:	1d 82       	std	Y+5, r1	; 0x05
    5482:	36 c0       	rjmp	.+108    	; 0x54f0 <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    5484:	ee 81       	ldd	r30, Y+6	; 0x06
    5486:	ff 81       	ldd	r31, Y+7	; 0x07
    5488:	90 81       	ld	r25, Z
    548a:	80 91 d8 06 	lds	r24, 0x06D8
    548e:	98 17       	cp	r25, r24
    5490:	61 f0       	breq	.+24     	; 0x54aa <xTaskCheckForTimeOut+0x7c>
    5492:	ee 81       	ldd	r30, Y+6	; 0x06
    5494:	ff 81       	ldd	r31, Y+7	; 0x07
    5496:	21 81       	ldd	r18, Z+1	; 0x01
    5498:	32 81       	ldd	r19, Z+2	; 0x02
    549a:	8b 81       	ldd	r24, Y+3	; 0x03
    549c:	9c 81       	ldd	r25, Y+4	; 0x04
    549e:	82 17       	cp	r24, r18
    54a0:	93 07       	cpc	r25, r19
    54a2:	18 f0       	brcs	.+6      	; 0x54aa <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    54a4:	81 e0       	ldi	r24, 0x01	; 1
    54a6:	8d 83       	std	Y+5, r24	; 0x05
    54a8:	23 c0       	rjmp	.+70     	; 0x54f0 <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    54aa:	e8 85       	ldd	r30, Y+8	; 0x08
    54ac:	f9 85       	ldd	r31, Y+9	; 0x09
    54ae:	20 81       	ld	r18, Z
    54b0:	31 81       	ldd	r19, Z+1	; 0x01
    54b2:	89 81       	ldd	r24, Y+1	; 0x01
    54b4:	9a 81       	ldd	r25, Y+2	; 0x02
    54b6:	82 17       	cp	r24, r18
    54b8:	93 07       	cpc	r25, r19
    54ba:	a0 f4       	brcc	.+40     	; 0x54e4 <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    54bc:	e8 85       	ldd	r30, Y+8	; 0x08
    54be:	f9 85       	ldd	r31, Y+9	; 0x09
    54c0:	20 81       	ld	r18, Z
    54c2:	31 81       	ldd	r19, Z+1	; 0x01
    54c4:	89 81       	ldd	r24, Y+1	; 0x01
    54c6:	9a 81       	ldd	r25, Y+2	; 0x02
    54c8:	a9 01       	movw	r20, r18
    54ca:	48 1b       	sub	r20, r24
    54cc:	59 0b       	sbc	r21, r25
    54ce:	ca 01       	movw	r24, r20
    54d0:	e8 85       	ldd	r30, Y+8	; 0x08
    54d2:	f9 85       	ldd	r31, Y+9	; 0x09
    54d4:	91 83       	std	Z+1, r25	; 0x01
    54d6:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    54d8:	8e 81       	ldd	r24, Y+6	; 0x06
    54da:	9f 81       	ldd	r25, Y+7	; 0x07
    54dc:	0e 94 fe 29 	call	0x53fc	; 0x53fc <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    54e0:	1d 82       	std	Y+5, r1	; 0x05
    54e2:	06 c0       	rjmp	.+12     	; 0x54f0 <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    54e4:	e8 85       	ldd	r30, Y+8	; 0x08
    54e6:	f9 85       	ldd	r31, Y+9	; 0x09
    54e8:	11 82       	std	Z+1, r1	; 0x01
    54ea:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    54ec:	81 e0       	ldi	r24, 0x01	; 1
    54ee:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    54f0:	0f 90       	pop	r0
    54f2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    54f4:	8d 81       	ldd	r24, Y+5	; 0x05
}
    54f6:	29 96       	adiw	r28, 0x09	; 9
    54f8:	0f b6       	in	r0, 0x3f	; 63
    54fa:	f8 94       	cli
    54fc:	de bf       	out	0x3e, r29	; 62
    54fe:	0f be       	out	0x3f, r0	; 63
    5500:	cd bf       	out	0x3d, r28	; 61
    5502:	cf 91       	pop	r28
    5504:	df 91       	pop	r29
    5506:	08 95       	ret

00005508 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    5508:	df 93       	push	r29
    550a:	cf 93       	push	r28
    550c:	cd b7       	in	r28, 0x3d	; 61
    550e:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    5510:	81 e0       	ldi	r24, 0x01	; 1
    5512:	80 93 d7 06 	sts	0x06D7, r24
}
    5516:	cf 91       	pop	r28
    5518:	df 91       	pop	r29
    551a:	08 95       	ret

0000551c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    551c:	df 93       	push	r29
    551e:	cf 93       	push	r28
    5520:	00 d0       	rcall	.+0      	; 0x5522 <prvIdleTask+0x6>
    5522:	cd b7       	in	r28, 0x3d	; 61
    5524:	de b7       	in	r29, 0x3e	; 62
    5526:	9a 83       	std	Y+2, r25	; 0x02
    5528:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    552a:	0e 94 d9 2a 	call	0x55b2	; 0x55b2 <prvCheckTasksWaitingTermination>
    552e:	fd cf       	rjmp	.-6      	; 0x552a <prvIdleTask+0xe>

00005530 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    5530:	df 93       	push	r29
    5532:	cf 93       	push	r28
    5534:	0f 92       	push	r0
    5536:	cd b7       	in	r28, 0x3d	; 61
    5538:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    553a:	19 82       	std	Y+1, r1	; 0x01
    553c:	13 c0       	rjmp	.+38     	; 0x5564 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    553e:	89 81       	ldd	r24, Y+1	; 0x01
    5540:	28 2f       	mov	r18, r24
    5542:	30 e0       	ldi	r19, 0x00	; 0
    5544:	c9 01       	movw	r24, r18
    5546:	88 0f       	add	r24, r24
    5548:	99 1f       	adc	r25, r25
    554a:	88 0f       	add	r24, r24
    554c:	99 1f       	adc	r25, r25
    554e:	88 0f       	add	r24, r24
    5550:	99 1f       	adc	r25, r25
    5552:	82 0f       	add	r24, r18
    5554:	93 1f       	adc	r25, r19
    5556:	81 52       	subi	r24, 0x21	; 33
    5558:	99 4f       	sbci	r25, 0xF9	; 249
    555a:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    555e:	89 81       	ldd	r24, Y+1	; 0x01
    5560:	8f 5f       	subi	r24, 0xFF	; 255
    5562:	89 83       	std	Y+1, r24	; 0x01
    5564:	89 81       	ldd	r24, Y+1	; 0x01
    5566:	85 30       	cpi	r24, 0x05	; 5
    5568:	50 f3       	brcs	.-44     	; 0x553e <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    556a:	8c e0       	ldi	r24, 0x0C	; 12
    556c:	97 e0       	ldi	r25, 0x07	; 7
    556e:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    5572:	85 e1       	ldi	r24, 0x15	; 21
    5574:	97 e0       	ldi	r25, 0x07	; 7
    5576:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    557a:	82 e2       	ldi	r24, 0x22	; 34
    557c:	97 e0       	ldi	r25, 0x07	; 7
    557e:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    5582:	8b e2       	ldi	r24, 0x2B	; 43
    5584:	97 e0       	ldi	r25, 0x07	; 7
    5586:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    558a:	84 e3       	ldi	r24, 0x34	; 52
    558c:	97 e0       	ldi	r25, 0x07	; 7
    558e:	0e 94 b0 0f 	call	0x1f60	; 0x1f60 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    5592:	8c e0       	ldi	r24, 0x0C	; 12
    5594:	97 e0       	ldi	r25, 0x07	; 7
    5596:	90 93 1f 07 	sts	0x071F, r25
    559a:	80 93 1e 07 	sts	0x071E, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    559e:	85 e1       	ldi	r24, 0x15	; 21
    55a0:	97 e0       	ldi	r25, 0x07	; 7
    55a2:	90 93 21 07 	sts	0x0721, r25
    55a6:	80 93 20 07 	sts	0x0720, r24
}
    55aa:	0f 90       	pop	r0
    55ac:	cf 91       	pop	r28
    55ae:	df 91       	pop	r29
    55b0:	08 95       	ret

000055b2 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    55b2:	df 93       	push	r29
    55b4:	cf 93       	push	r28
    55b6:	00 d0       	rcall	.+0      	; 0x55b8 <prvCheckTasksWaitingTermination+0x6>
    55b8:	cd b7       	in	r28, 0x3d	; 61
    55ba:	de b7       	in	r29, 0x3e	; 62
    55bc:	20 c0       	rjmp	.+64     	; 0x55fe <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    55be:	0f b6       	in	r0, 0x3f	; 63
    55c0:	f8 94       	cli
    55c2:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    55c4:	e0 91 30 07 	lds	r30, 0x0730
    55c8:	f0 91 31 07 	lds	r31, 0x0731
    55cc:	86 81       	ldd	r24, Z+6	; 0x06
    55ce:	97 81       	ldd	r25, Z+7	; 0x07
    55d0:	9a 83       	std	Y+2, r25	; 0x02
    55d2:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    55d4:	89 81       	ldd	r24, Y+1	; 0x01
    55d6:	9a 81       	ldd	r25, Y+2	; 0x02
    55d8:	02 96       	adiw	r24, 0x02	; 2
    55da:	0e 94 9a 10 	call	0x2134	; 0x2134 <uxListRemove>
				--uxCurrentNumberOfTasks;
    55de:	80 91 d1 06 	lds	r24, 0x06D1
    55e2:	81 50       	subi	r24, 0x01	; 1
    55e4:	80 93 d1 06 	sts	0x06D1, r24
				--uxDeletedTasksWaitingCleanUp;
    55e8:	80 91 d0 06 	lds	r24, 0x06D0
    55ec:	81 50       	subi	r24, 0x01	; 1
    55ee:	80 93 d0 06 	sts	0x06D0, r24
			}
			taskEXIT_CRITICAL();
    55f2:	0f 90       	pop	r0
    55f4:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    55f6:	89 81       	ldd	r24, Y+1	; 0x01
    55f8:	9a 81       	ldd	r25, Y+2	; 0x02
    55fa:	0e 94 08 2b 	call	0x5610	; 0x5610 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    55fe:	80 91 d0 06 	lds	r24, 0x06D0
    5602:	88 23       	and	r24, r24
    5604:	e1 f6       	brne	.-72     	; 0x55be <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    5606:	0f 90       	pop	r0
    5608:	0f 90       	pop	r0
    560a:	cf 91       	pop	r28
    560c:	df 91       	pop	r29
    560e:	08 95       	ret

00005610 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    5610:	df 93       	push	r29
    5612:	cf 93       	push	r28
    5614:	00 d0       	rcall	.+0      	; 0x5616 <prvDeleteTCB+0x6>
    5616:	cd b7       	in	r28, 0x3d	; 61
    5618:	de b7       	in	r29, 0x3e	; 62
    561a:	9a 83       	std	Y+2, r25	; 0x02
    561c:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    561e:	e9 81       	ldd	r30, Y+1	; 0x01
    5620:	fa 81       	ldd	r31, Y+2	; 0x02
    5622:	87 89       	ldd	r24, Z+23	; 0x17
    5624:	90 8d       	ldd	r25, Z+24	; 0x18
    5626:	0e 94 c7 0c 	call	0x198e	; 0x198e <vPortFree>
			vPortFree( pxTCB );
    562a:	89 81       	ldd	r24, Y+1	; 0x01
    562c:	9a 81       	ldd	r25, Y+2	; 0x02
    562e:	0e 94 c7 0c 	call	0x198e	; 0x198e <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    5632:	0f 90       	pop	r0
    5634:	0f 90       	pop	r0
    5636:	cf 91       	pop	r28
    5638:	df 91       	pop	r29
    563a:	08 95       	ret

0000563c <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    563c:	df 93       	push	r29
    563e:	cf 93       	push	r28
    5640:	00 d0       	rcall	.+0      	; 0x5642 <prvResetNextTaskUnblockTime+0x6>
    5642:	cd b7       	in	r28, 0x3d	; 61
    5644:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    5646:	e0 91 1e 07 	lds	r30, 0x071E
    564a:	f0 91 1f 07 	lds	r31, 0x071F
    564e:	80 81       	ld	r24, Z
    5650:	88 23       	and	r24, r24
    5652:	39 f4       	brne	.+14     	; 0x5662 <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    5654:	8f ef       	ldi	r24, 0xFF	; 255
    5656:	9f ef       	ldi	r25, 0xFF	; 255
    5658:	90 93 db 06 	sts	0x06DB, r25
    565c:	80 93 da 06 	sts	0x06DA, r24
    5660:	13 c0       	rjmp	.+38     	; 0x5688 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5662:	e0 91 1e 07 	lds	r30, 0x071E
    5666:	f0 91 1f 07 	lds	r31, 0x071F
    566a:	05 80       	ldd	r0, Z+5	; 0x05
    566c:	f6 81       	ldd	r31, Z+6	; 0x06
    566e:	e0 2d       	mov	r30, r0
    5670:	86 81       	ldd	r24, Z+6	; 0x06
    5672:	97 81       	ldd	r25, Z+7	; 0x07
    5674:	9a 83       	std	Y+2, r25	; 0x02
    5676:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    5678:	e9 81       	ldd	r30, Y+1	; 0x01
    567a:	fa 81       	ldd	r31, Y+2	; 0x02
    567c:	82 81       	ldd	r24, Z+2	; 0x02
    567e:	93 81       	ldd	r25, Z+3	; 0x03
    5680:	90 93 db 06 	sts	0x06DB, r25
    5684:	80 93 da 06 	sts	0x06DA, r24
	}
}
    5688:	0f 90       	pop	r0
    568a:	0f 90       	pop	r0
    568c:	cf 91       	pop	r28
    568e:	df 91       	pop	r29
    5690:	08 95       	ret

00005692 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    5692:	df 93       	push	r29
    5694:	cf 93       	push	r28
    5696:	00 d0       	rcall	.+0      	; 0x5698 <xTaskGetCurrentTaskHandle+0x6>
    5698:	cd b7       	in	r28, 0x3d	; 61
    569a:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    569c:	80 91 ce 06 	lds	r24, 0x06CE
    56a0:	90 91 cf 06 	lds	r25, 0x06CF
    56a4:	9a 83       	std	Y+2, r25	; 0x02
    56a6:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    56a8:	89 81       	ldd	r24, Y+1	; 0x01
    56aa:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    56ac:	0f 90       	pop	r0
    56ae:	0f 90       	pop	r0
    56b0:	cf 91       	pop	r28
    56b2:	df 91       	pop	r29
    56b4:	08 95       	ret

000056b6 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    56b6:	df 93       	push	r29
    56b8:	cf 93       	push	r28
    56ba:	00 d0       	rcall	.+0      	; 0x56bc <uxTaskResetEventItemValue+0x6>
    56bc:	cd b7       	in	r28, 0x3d	; 61
    56be:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    56c0:	e0 91 ce 06 	lds	r30, 0x06CE
    56c4:	f0 91 cf 06 	lds	r31, 0x06CF
    56c8:	84 85       	ldd	r24, Z+12	; 0x0c
    56ca:	95 85       	ldd	r25, Z+13	; 0x0d
    56cc:	9a 83       	std	Y+2, r25	; 0x02
    56ce:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    56d0:	a0 91 ce 06 	lds	r26, 0x06CE
    56d4:	b0 91 cf 06 	lds	r27, 0x06CF
    56d8:	e0 91 ce 06 	lds	r30, 0x06CE
    56dc:	f0 91 cf 06 	lds	r31, 0x06CF
    56e0:	86 89       	ldd	r24, Z+22	; 0x16
    56e2:	28 2f       	mov	r18, r24
    56e4:	30 e0       	ldi	r19, 0x00	; 0
    56e6:	85 e0       	ldi	r24, 0x05	; 5
    56e8:	90 e0       	ldi	r25, 0x00	; 0
    56ea:	82 1b       	sub	r24, r18
    56ec:	93 0b       	sbc	r25, r19
    56ee:	1d 96       	adiw	r26, 0x0d	; 13
    56f0:	9c 93       	st	X, r25
    56f2:	8e 93       	st	-X, r24
    56f4:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    56f6:	89 81       	ldd	r24, Y+1	; 0x01
    56f8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    56fa:	0f 90       	pop	r0
    56fc:	0f 90       	pop	r0
    56fe:	cf 91       	pop	r28
    5700:	df 91       	pop	r29
    5702:	08 95       	ret

00005704 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    5704:	df 93       	push	r29
    5706:	cf 93       	push	r28
    5708:	cd b7       	in	r28, 0x3d	; 61
    570a:	de b7       	in	r29, 0x3e	; 62
    570c:	27 97       	sbiw	r28, 0x07	; 7
    570e:	0f b6       	in	r0, 0x3f	; 63
    5710:	f8 94       	cli
    5712:	de bf       	out	0x3e, r29	; 62
    5714:	0f be       	out	0x3f, r0	; 63
    5716:	cd bf       	out	0x3d, r28	; 61
    5718:	8d 83       	std	Y+5, r24	; 0x05
    571a:	7f 83       	std	Y+7, r23	; 0x07
    571c:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    571e:	0f b6       	in	r0, 0x3f	; 63
    5720:	f8 94       	cli
    5722:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    5724:	e0 91 ce 06 	lds	r30, 0x06CE
    5728:	f0 91 cf 06 	lds	r31, 0x06CF
    572c:	85 a5       	ldd	r24, Z+45	; 0x2d
    572e:	96 a5       	ldd	r25, Z+46	; 0x2e
    5730:	a7 a5       	ldd	r26, Z+47	; 0x2f
    5732:	b0 a9       	ldd	r27, Z+48	; 0x30
    5734:	00 97       	sbiw	r24, 0x00	; 0
    5736:	a1 05       	cpc	r26, r1
    5738:	b1 05       	cpc	r27, r1
    573a:	89 f4       	brne	.+34     	; 0x575e <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    573c:	e0 91 ce 06 	lds	r30, 0x06CE
    5740:	f0 91 cf 06 	lds	r31, 0x06CF
    5744:	81 e0       	ldi	r24, 0x01	; 1
    5746:	81 ab       	std	Z+49, r24	; 0x31

				if( xTicksToWait > ( TickType_t ) 0 )
    5748:	8e 81       	ldd	r24, Y+6	; 0x06
    574a:	9f 81       	ldd	r25, Y+7	; 0x07
    574c:	00 97       	sbiw	r24, 0x00	; 0
    574e:	39 f0       	breq	.+14     	; 0x575e <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5750:	8e 81       	ldd	r24, Y+6	; 0x06
    5752:	9f 81       	ldd	r25, Y+7	; 0x07
    5754:	61 e0       	ldi	r22, 0x01	; 1
    5756:	0e 94 2a 2f 	call	0x5e54	; 0x5e54 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    575a:	0e 94 c2 12 	call	0x2584	; 0x2584 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    575e:	0f 90       	pop	r0
    5760:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    5762:	0f b6       	in	r0, 0x3f	; 63
    5764:	f8 94       	cli
    5766:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    5768:	e0 91 ce 06 	lds	r30, 0x06CE
    576c:	f0 91 cf 06 	lds	r31, 0x06CF
    5770:	85 a5       	ldd	r24, Z+45	; 0x2d
    5772:	96 a5       	ldd	r25, Z+46	; 0x2e
    5774:	a7 a5       	ldd	r26, Z+47	; 0x2f
    5776:	b0 a9       	ldd	r27, Z+48	; 0x30
    5778:	89 83       	std	Y+1, r24	; 0x01
    577a:	9a 83       	std	Y+2, r25	; 0x02
    577c:	ab 83       	std	Y+3, r26	; 0x03
    577e:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    5780:	89 81       	ldd	r24, Y+1	; 0x01
    5782:	9a 81       	ldd	r25, Y+2	; 0x02
    5784:	ab 81       	ldd	r26, Y+3	; 0x03
    5786:	bc 81       	ldd	r27, Y+4	; 0x04
    5788:	00 97       	sbiw	r24, 0x00	; 0
    578a:	a1 05       	cpc	r26, r1
    578c:	b1 05       	cpc	r27, r1
    578e:	d9 f0       	breq	.+54     	; 0x57c6 <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    5790:	8d 81       	ldd	r24, Y+5	; 0x05
    5792:	88 23       	and	r24, r24
    5794:	49 f0       	breq	.+18     	; 0x57a8 <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    5796:	e0 91 ce 06 	lds	r30, 0x06CE
    579a:	f0 91 cf 06 	lds	r31, 0x06CF
    579e:	15 a6       	std	Z+45, r1	; 0x2d
    57a0:	16 a6       	std	Z+46, r1	; 0x2e
    57a2:	17 a6       	std	Z+47, r1	; 0x2f
    57a4:	10 aa       	std	Z+48, r1	; 0x30
    57a6:	0f c0       	rjmp	.+30     	; 0x57c6 <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    57a8:	e0 91 ce 06 	lds	r30, 0x06CE
    57ac:	f0 91 cf 06 	lds	r31, 0x06CF
    57b0:	89 81       	ldd	r24, Y+1	; 0x01
    57b2:	9a 81       	ldd	r25, Y+2	; 0x02
    57b4:	ab 81       	ldd	r26, Y+3	; 0x03
    57b6:	bc 81       	ldd	r27, Y+4	; 0x04
    57b8:	01 97       	sbiw	r24, 0x01	; 1
    57ba:	a1 09       	sbc	r26, r1
    57bc:	b1 09       	sbc	r27, r1
    57be:	85 a7       	std	Z+45, r24	; 0x2d
    57c0:	96 a7       	std	Z+46, r25	; 0x2e
    57c2:	a7 a7       	std	Z+47, r26	; 0x2f
    57c4:	b0 ab       	std	Z+48, r27	; 0x30
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    57c6:	e0 91 ce 06 	lds	r30, 0x06CE
    57ca:	f0 91 cf 06 	lds	r31, 0x06CF
    57ce:	11 aa       	std	Z+49, r1	; 0x31
		}
		taskEXIT_CRITICAL();
    57d0:	0f 90       	pop	r0
    57d2:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    57d4:	89 81       	ldd	r24, Y+1	; 0x01
    57d6:	9a 81       	ldd	r25, Y+2	; 0x02
    57d8:	ab 81       	ldd	r26, Y+3	; 0x03
    57da:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    57dc:	bc 01       	movw	r22, r24
    57de:	cd 01       	movw	r24, r26
    57e0:	27 96       	adiw	r28, 0x07	; 7
    57e2:	0f b6       	in	r0, 0x3f	; 63
    57e4:	f8 94       	cli
    57e6:	de bf       	out	0x3e, r29	; 62
    57e8:	0f be       	out	0x3f, r0	; 63
    57ea:	cd bf       	out	0x3d, r28	; 61
    57ec:	cf 91       	pop	r28
    57ee:	df 91       	pop	r29
    57f0:	08 95       	ret

000057f2 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    57f2:	ef 92       	push	r14
    57f4:	ff 92       	push	r15
    57f6:	0f 93       	push	r16
    57f8:	1f 93       	push	r17
    57fa:	df 93       	push	r29
    57fc:	cf 93       	push	r28
    57fe:	cd b7       	in	r28, 0x3d	; 61
    5800:	de b7       	in	r29, 0x3e	; 62
    5802:	2d 97       	sbiw	r28, 0x0d	; 13
    5804:	0f b6       	in	r0, 0x3f	; 63
    5806:	f8 94       	cli
    5808:	de bf       	out	0x3e, r29	; 62
    580a:	0f be       	out	0x3f, r0	; 63
    580c:	cd bf       	out	0x3d, r28	; 61
    580e:	6a 83       	std	Y+2, r22	; 0x02
    5810:	7b 83       	std	Y+3, r23	; 0x03
    5812:	8c 83       	std	Y+4, r24	; 0x04
    5814:	9d 83       	std	Y+5, r25	; 0x05
    5816:	2e 83       	std	Y+6, r18	; 0x06
    5818:	3f 83       	std	Y+7, r19	; 0x07
    581a:	48 87       	std	Y+8, r20	; 0x08
    581c:	59 87       	std	Y+9, r21	; 0x09
    581e:	1b 87       	std	Y+11, r17	; 0x0b
    5820:	0a 87       	std	Y+10, r16	; 0x0a
    5822:	fd 86       	std	Y+13, r15	; 0x0d
    5824:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    5826:	0f b6       	in	r0, 0x3f	; 63
    5828:	f8 94       	cli
    582a:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    582c:	e0 91 ce 06 	lds	r30, 0x06CE
    5830:	f0 91 cf 06 	lds	r31, 0x06CF
    5834:	81 a9       	ldd	r24, Z+49	; 0x31
    5836:	82 30       	cpi	r24, 0x02	; 2
    5838:	49 f1       	breq	.+82     	; 0x588c <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    583a:	e0 91 ce 06 	lds	r30, 0x06CE
    583e:	f0 91 cf 06 	lds	r31, 0x06CF
    5842:	25 a5       	ldd	r18, Z+45	; 0x2d
    5844:	36 a5       	ldd	r19, Z+46	; 0x2e
    5846:	47 a5       	ldd	r20, Z+47	; 0x2f
    5848:	50 a9       	ldd	r21, Z+48	; 0x30
    584a:	8a 81       	ldd	r24, Y+2	; 0x02
    584c:	9b 81       	ldd	r25, Y+3	; 0x03
    584e:	ac 81       	ldd	r26, Y+4	; 0x04
    5850:	bd 81       	ldd	r27, Y+5	; 0x05
    5852:	80 95       	com	r24
    5854:	90 95       	com	r25
    5856:	a0 95       	com	r26
    5858:	b0 95       	com	r27
    585a:	82 23       	and	r24, r18
    585c:	93 23       	and	r25, r19
    585e:	a4 23       	and	r26, r20
    5860:	b5 23       	and	r27, r21
    5862:	85 a7       	std	Z+45, r24	; 0x2d
    5864:	96 a7       	std	Z+46, r25	; 0x2e
    5866:	a7 a7       	std	Z+47, r26	; 0x2f
    5868:	b0 ab       	std	Z+48, r27	; 0x30

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    586a:	e0 91 ce 06 	lds	r30, 0x06CE
    586e:	f0 91 cf 06 	lds	r31, 0x06CF
    5872:	81 e0       	ldi	r24, 0x01	; 1
    5874:	81 ab       	std	Z+49, r24	; 0x31

				if( xTicksToWait > ( TickType_t ) 0 )
    5876:	8c 85       	ldd	r24, Y+12	; 0x0c
    5878:	9d 85       	ldd	r25, Y+13	; 0x0d
    587a:	00 97       	sbiw	r24, 0x00	; 0
    587c:	39 f0       	breq	.+14     	; 0x588c <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    587e:	8c 85       	ldd	r24, Y+12	; 0x0c
    5880:	9d 85       	ldd	r25, Y+13	; 0x0d
    5882:	61 e0       	ldi	r22, 0x01	; 1
    5884:	0e 94 2a 2f 	call	0x5e54	; 0x5e54 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    5888:	0e 94 c2 12 	call	0x2584	; 0x2584 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    588c:	0f 90       	pop	r0
    588e:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    5890:	0f b6       	in	r0, 0x3f	; 63
    5892:	f8 94       	cli
    5894:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    5896:	8a 85       	ldd	r24, Y+10	; 0x0a
    5898:	9b 85       	ldd	r25, Y+11	; 0x0b
    589a:	00 97       	sbiw	r24, 0x00	; 0
    589c:	71 f0       	breq	.+28     	; 0x58ba <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    589e:	e0 91 ce 06 	lds	r30, 0x06CE
    58a2:	f0 91 cf 06 	lds	r31, 0x06CF
    58a6:	85 a5       	ldd	r24, Z+45	; 0x2d
    58a8:	96 a5       	ldd	r25, Z+46	; 0x2e
    58aa:	a7 a5       	ldd	r26, Z+47	; 0x2f
    58ac:	b0 a9       	ldd	r27, Z+48	; 0x30
    58ae:	ea 85       	ldd	r30, Y+10	; 0x0a
    58b0:	fb 85       	ldd	r31, Y+11	; 0x0b
    58b2:	80 83       	st	Z, r24
    58b4:	91 83       	std	Z+1, r25	; 0x01
    58b6:	a2 83       	std	Z+2, r26	; 0x02
    58b8:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    58ba:	e0 91 ce 06 	lds	r30, 0x06CE
    58be:	f0 91 cf 06 	lds	r31, 0x06CF
    58c2:	81 a9       	ldd	r24, Z+49	; 0x31
    58c4:	82 30       	cpi	r24, 0x02	; 2
    58c6:	11 f0       	breq	.+4      	; 0x58cc <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    58c8:	19 82       	std	Y+1, r1	; 0x01
    58ca:	1a c0       	rjmp	.+52     	; 0x5900 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    58cc:	e0 91 ce 06 	lds	r30, 0x06CE
    58d0:	f0 91 cf 06 	lds	r31, 0x06CF
    58d4:	25 a5       	ldd	r18, Z+45	; 0x2d
    58d6:	36 a5       	ldd	r19, Z+46	; 0x2e
    58d8:	47 a5       	ldd	r20, Z+47	; 0x2f
    58da:	50 a9       	ldd	r21, Z+48	; 0x30
    58dc:	8e 81       	ldd	r24, Y+6	; 0x06
    58de:	9f 81       	ldd	r25, Y+7	; 0x07
    58e0:	a8 85       	ldd	r26, Y+8	; 0x08
    58e2:	b9 85       	ldd	r27, Y+9	; 0x09
    58e4:	80 95       	com	r24
    58e6:	90 95       	com	r25
    58e8:	a0 95       	com	r26
    58ea:	b0 95       	com	r27
    58ec:	82 23       	and	r24, r18
    58ee:	93 23       	and	r25, r19
    58f0:	a4 23       	and	r26, r20
    58f2:	b5 23       	and	r27, r21
    58f4:	85 a7       	std	Z+45, r24	; 0x2d
    58f6:	96 a7       	std	Z+46, r25	; 0x2e
    58f8:	a7 a7       	std	Z+47, r26	; 0x2f
    58fa:	b0 ab       	std	Z+48, r27	; 0x30
				xReturn = pdTRUE;
    58fc:	81 e0       	ldi	r24, 0x01	; 1
    58fe:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5900:	e0 91 ce 06 	lds	r30, 0x06CE
    5904:	f0 91 cf 06 	lds	r31, 0x06CF
    5908:	11 aa       	std	Z+49, r1	; 0x31
		}
		taskEXIT_CRITICAL();
    590a:	0f 90       	pop	r0
    590c:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    590e:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5910:	2d 96       	adiw	r28, 0x0d	; 13
    5912:	0f b6       	in	r0, 0x3f	; 63
    5914:	f8 94       	cli
    5916:	de bf       	out	0x3e, r29	; 62
    5918:	0f be       	out	0x3f, r0	; 63
    591a:	cd bf       	out	0x3d, r28	; 61
    591c:	cf 91       	pop	r28
    591e:	df 91       	pop	r29
    5920:	1f 91       	pop	r17
    5922:	0f 91       	pop	r16
    5924:	ff 90       	pop	r15
    5926:	ef 90       	pop	r14
    5928:	08 95       	ret

0000592a <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    592a:	0f 93       	push	r16
    592c:	1f 93       	push	r17
    592e:	df 93       	push	r29
    5930:	cf 93       	push	r28
    5932:	cd b7       	in	r28, 0x3d	; 61
    5934:	de b7       	in	r29, 0x3e	; 62
    5936:	2f 97       	sbiw	r28, 0x0f	; 15
    5938:	0f b6       	in	r0, 0x3f	; 63
    593a:	f8 94       	cli
    593c:	de bf       	out	0x3e, r29	; 62
    593e:	0f be       	out	0x3f, r0	; 63
    5940:	cd bf       	out	0x3d, r28	; 61
    5942:	9e 83       	std	Y+6, r25	; 0x06
    5944:	8d 83       	std	Y+5, r24	; 0x05
    5946:	4f 83       	std	Y+7, r20	; 0x07
    5948:	58 87       	std	Y+8, r21	; 0x08
    594a:	69 87       	std	Y+9, r22	; 0x09
    594c:	7a 87       	std	Y+10, r23	; 0x0a
    594e:	2b 87       	std	Y+11, r18	; 0x0b
    5950:	1d 87       	std	Y+13, r17	; 0x0d
    5952:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    5954:	81 e0       	ldi	r24, 0x01	; 1
    5956:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    5958:	8d 81       	ldd	r24, Y+5	; 0x05
    595a:	9e 81       	ldd	r25, Y+6	; 0x06
    595c:	9c 83       	std	Y+4, r25	; 0x04
    595e:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    5960:	0f b6       	in	r0, 0x3f	; 63
    5962:	f8 94       	cli
    5964:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    5966:	8c 85       	ldd	r24, Y+12	; 0x0c
    5968:	9d 85       	ldd	r25, Y+13	; 0x0d
    596a:	00 97       	sbiw	r24, 0x00	; 0
    596c:	61 f0       	breq	.+24     	; 0x5986 <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    596e:	eb 81       	ldd	r30, Y+3	; 0x03
    5970:	fc 81       	ldd	r31, Y+4	; 0x04
    5972:	85 a5       	ldd	r24, Z+45	; 0x2d
    5974:	96 a5       	ldd	r25, Z+46	; 0x2e
    5976:	a7 a5       	ldd	r26, Z+47	; 0x2f
    5978:	b0 a9       	ldd	r27, Z+48	; 0x30
    597a:	ec 85       	ldd	r30, Y+12	; 0x0c
    597c:	fd 85       	ldd	r31, Y+13	; 0x0d
    597e:	80 83       	st	Z, r24
    5980:	91 83       	std	Z+1, r25	; 0x01
    5982:	a2 83       	std	Z+2, r26	; 0x02
    5984:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5986:	eb 81       	ldd	r30, Y+3	; 0x03
    5988:	fc 81       	ldd	r31, Y+4	; 0x04
    598a:	81 a9       	ldd	r24, Z+49	; 0x31
    598c:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    598e:	eb 81       	ldd	r30, Y+3	; 0x03
    5990:	fc 81       	ldd	r31, Y+4	; 0x04
    5992:	82 e0       	ldi	r24, 0x02	; 2
    5994:	81 ab       	std	Z+49, r24	; 0x31

			switch( eAction )
    5996:	8b 85       	ldd	r24, Y+11	; 0x0b
    5998:	28 2f       	mov	r18, r24
    599a:	30 e0       	ldi	r19, 0x00	; 0
    599c:	3f 87       	std	Y+15, r19	; 0x0f
    599e:	2e 87       	std	Y+14, r18	; 0x0e
    59a0:	8e 85       	ldd	r24, Y+14	; 0x0e
    59a2:	9f 85       	ldd	r25, Y+15	; 0x0f
    59a4:	82 30       	cpi	r24, 0x02	; 2
    59a6:	91 05       	cpc	r25, r1
    59a8:	59 f1       	breq	.+86     	; 0x5a00 <xTaskGenericNotify+0xd6>
    59aa:	2e 85       	ldd	r18, Y+14	; 0x0e
    59ac:	3f 85       	ldd	r19, Y+15	; 0x0f
    59ae:	23 30       	cpi	r18, 0x03	; 3
    59b0:	31 05       	cpc	r19, r1
    59b2:	34 f4       	brge	.+12     	; 0x59c0 <xTaskGenericNotify+0x96>
    59b4:	8e 85       	ldd	r24, Y+14	; 0x0e
    59b6:	9f 85       	ldd	r25, Y+15	; 0x0f
    59b8:	81 30       	cpi	r24, 0x01	; 1
    59ba:	91 05       	cpc	r25, r1
    59bc:	61 f0       	breq	.+24     	; 0x59d6 <xTaskGenericNotify+0xac>
    59be:	4a c0       	rjmp	.+148    	; 0x5a54 <xTaskGenericNotify+0x12a>
    59c0:	2e 85       	ldd	r18, Y+14	; 0x0e
    59c2:	3f 85       	ldd	r19, Y+15	; 0x0f
    59c4:	23 30       	cpi	r18, 0x03	; 3
    59c6:	31 05       	cpc	r19, r1
    59c8:	59 f1       	breq	.+86     	; 0x5a20 <xTaskGenericNotify+0xf6>
    59ca:	8e 85       	ldd	r24, Y+14	; 0x0e
    59cc:	9f 85       	ldd	r25, Y+15	; 0x0f
    59ce:	84 30       	cpi	r24, 0x04	; 4
    59d0:	91 05       	cpc	r25, r1
    59d2:	89 f1       	breq	.+98     	; 0x5a36 <xTaskGenericNotify+0x10c>
    59d4:	3f c0       	rjmp	.+126    	; 0x5a54 <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    59d6:	eb 81       	ldd	r30, Y+3	; 0x03
    59d8:	fc 81       	ldd	r31, Y+4	; 0x04
    59da:	25 a5       	ldd	r18, Z+45	; 0x2d
    59dc:	36 a5       	ldd	r19, Z+46	; 0x2e
    59de:	47 a5       	ldd	r20, Z+47	; 0x2f
    59e0:	50 a9       	ldd	r21, Z+48	; 0x30
    59e2:	8f 81       	ldd	r24, Y+7	; 0x07
    59e4:	98 85       	ldd	r25, Y+8	; 0x08
    59e6:	a9 85       	ldd	r26, Y+9	; 0x09
    59e8:	ba 85       	ldd	r27, Y+10	; 0x0a
    59ea:	82 2b       	or	r24, r18
    59ec:	93 2b       	or	r25, r19
    59ee:	a4 2b       	or	r26, r20
    59f0:	b5 2b       	or	r27, r21
    59f2:	eb 81       	ldd	r30, Y+3	; 0x03
    59f4:	fc 81       	ldd	r31, Y+4	; 0x04
    59f6:	85 a7       	std	Z+45, r24	; 0x2d
    59f8:	96 a7       	std	Z+46, r25	; 0x2e
    59fa:	a7 a7       	std	Z+47, r26	; 0x2f
    59fc:	b0 ab       	std	Z+48, r27	; 0x30
    59fe:	2a c0       	rjmp	.+84     	; 0x5a54 <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    5a00:	eb 81       	ldd	r30, Y+3	; 0x03
    5a02:	fc 81       	ldd	r31, Y+4	; 0x04
    5a04:	85 a5       	ldd	r24, Z+45	; 0x2d
    5a06:	96 a5       	ldd	r25, Z+46	; 0x2e
    5a08:	a7 a5       	ldd	r26, Z+47	; 0x2f
    5a0a:	b0 a9       	ldd	r27, Z+48	; 0x30
    5a0c:	01 96       	adiw	r24, 0x01	; 1
    5a0e:	a1 1d       	adc	r26, r1
    5a10:	b1 1d       	adc	r27, r1
    5a12:	eb 81       	ldd	r30, Y+3	; 0x03
    5a14:	fc 81       	ldd	r31, Y+4	; 0x04
    5a16:	85 a7       	std	Z+45, r24	; 0x2d
    5a18:	96 a7       	std	Z+46, r25	; 0x2e
    5a1a:	a7 a7       	std	Z+47, r26	; 0x2f
    5a1c:	b0 ab       	std	Z+48, r27	; 0x30
    5a1e:	1a c0       	rjmp	.+52     	; 0x5a54 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    5a20:	eb 81       	ldd	r30, Y+3	; 0x03
    5a22:	fc 81       	ldd	r31, Y+4	; 0x04
    5a24:	8f 81       	ldd	r24, Y+7	; 0x07
    5a26:	98 85       	ldd	r25, Y+8	; 0x08
    5a28:	a9 85       	ldd	r26, Y+9	; 0x09
    5a2a:	ba 85       	ldd	r27, Y+10	; 0x0a
    5a2c:	85 a7       	std	Z+45, r24	; 0x2d
    5a2e:	96 a7       	std	Z+46, r25	; 0x2e
    5a30:	a7 a7       	std	Z+47, r26	; 0x2f
    5a32:	b0 ab       	std	Z+48, r27	; 0x30
    5a34:	0f c0       	rjmp	.+30     	; 0x5a54 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5a36:	89 81       	ldd	r24, Y+1	; 0x01
    5a38:	82 30       	cpi	r24, 0x02	; 2
    5a3a:	59 f0       	breq	.+22     	; 0x5a52 <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    5a3c:	eb 81       	ldd	r30, Y+3	; 0x03
    5a3e:	fc 81       	ldd	r31, Y+4	; 0x04
    5a40:	8f 81       	ldd	r24, Y+7	; 0x07
    5a42:	98 85       	ldd	r25, Y+8	; 0x08
    5a44:	a9 85       	ldd	r26, Y+9	; 0x09
    5a46:	ba 85       	ldd	r27, Y+10	; 0x0a
    5a48:	85 a7       	std	Z+45, r24	; 0x2d
    5a4a:	96 a7       	std	Z+46, r25	; 0x2e
    5a4c:	a7 a7       	std	Z+47, r26	; 0x2f
    5a4e:	b0 ab       	std	Z+48, r27	; 0x30
    5a50:	01 c0       	rjmp	.+2      	; 0x5a54 <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    5a52:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5a54:	89 81       	ldd	r24, Y+1	; 0x01
    5a56:	81 30       	cpi	r24, 0x01	; 1
    5a58:	b9 f5       	brne	.+110    	; 0x5ac8 <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5a5a:	8b 81       	ldd	r24, Y+3	; 0x03
    5a5c:	9c 81       	ldd	r25, Y+4	; 0x04
    5a5e:	02 96       	adiw	r24, 0x02	; 2
    5a60:	0e 94 9a 10 	call	0x2134	; 0x2134 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    5a64:	eb 81       	ldd	r30, Y+3	; 0x03
    5a66:	fc 81       	ldd	r31, Y+4	; 0x04
    5a68:	96 89       	ldd	r25, Z+22	; 0x16
    5a6a:	80 91 d4 06 	lds	r24, 0x06D4
    5a6e:	89 17       	cp	r24, r25
    5a70:	28 f4       	brcc	.+10     	; 0x5a7c <xTaskGenericNotify+0x152>
    5a72:	eb 81       	ldd	r30, Y+3	; 0x03
    5a74:	fc 81       	ldd	r31, Y+4	; 0x04
    5a76:	86 89       	ldd	r24, Z+22	; 0x16
    5a78:	80 93 d4 06 	sts	0x06D4, r24
    5a7c:	eb 81       	ldd	r30, Y+3	; 0x03
    5a7e:	fc 81       	ldd	r31, Y+4	; 0x04
    5a80:	86 89       	ldd	r24, Z+22	; 0x16
    5a82:	28 2f       	mov	r18, r24
    5a84:	30 e0       	ldi	r19, 0x00	; 0
    5a86:	c9 01       	movw	r24, r18
    5a88:	88 0f       	add	r24, r24
    5a8a:	99 1f       	adc	r25, r25
    5a8c:	88 0f       	add	r24, r24
    5a8e:	99 1f       	adc	r25, r25
    5a90:	88 0f       	add	r24, r24
    5a92:	99 1f       	adc	r25, r25
    5a94:	82 0f       	add	r24, r18
    5a96:	93 1f       	adc	r25, r19
    5a98:	ac 01       	movw	r20, r24
    5a9a:	41 52       	subi	r20, 0x21	; 33
    5a9c:	59 4f       	sbci	r21, 0xF9	; 249
    5a9e:	8b 81       	ldd	r24, Y+3	; 0x03
    5aa0:	9c 81       	ldd	r25, Y+4	; 0x04
    5aa2:	9c 01       	movw	r18, r24
    5aa4:	2e 5f       	subi	r18, 0xFE	; 254
    5aa6:	3f 4f       	sbci	r19, 0xFF	; 255
    5aa8:	ca 01       	movw	r24, r20
    5aaa:	b9 01       	movw	r22, r18
    5aac:	0e 94 ea 0f 	call	0x1fd4	; 0x1fd4 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5ab0:	eb 81       	ldd	r30, Y+3	; 0x03
    5ab2:	fc 81       	ldd	r31, Y+4	; 0x04
    5ab4:	96 89       	ldd	r25, Z+22	; 0x16
    5ab6:	e0 91 ce 06 	lds	r30, 0x06CE
    5aba:	f0 91 cf 06 	lds	r31, 0x06CF
    5abe:	86 89       	ldd	r24, Z+22	; 0x16
    5ac0:	89 17       	cp	r24, r25
    5ac2:	10 f4       	brcc	.+4      	; 0x5ac8 <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    5ac4:	0e 94 c2 12 	call	0x2584	; 0x2584 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5ac8:	0f 90       	pop	r0
    5aca:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5acc:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    5ace:	2f 96       	adiw	r28, 0x0f	; 15
    5ad0:	0f b6       	in	r0, 0x3f	; 63
    5ad2:	f8 94       	cli
    5ad4:	de bf       	out	0x3e, r29	; 62
    5ad6:	0f be       	out	0x3f, r0	; 63
    5ad8:	cd bf       	out	0x3d, r28	; 61
    5ada:	cf 91       	pop	r28
    5adc:	df 91       	pop	r29
    5ade:	1f 91       	pop	r17
    5ae0:	0f 91       	pop	r16
    5ae2:	08 95       	ret

00005ae4 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    5ae4:	ef 92       	push	r14
    5ae6:	ff 92       	push	r15
    5ae8:	0f 93       	push	r16
    5aea:	1f 93       	push	r17
    5aec:	df 93       	push	r29
    5aee:	cf 93       	push	r28
    5af0:	cd b7       	in	r28, 0x3d	; 61
    5af2:	de b7       	in	r29, 0x3e	; 62
    5af4:	62 97       	sbiw	r28, 0x12	; 18
    5af6:	0f b6       	in	r0, 0x3f	; 63
    5af8:	f8 94       	cli
    5afa:	de bf       	out	0x3e, r29	; 62
    5afc:	0f be       	out	0x3f, r0	; 63
    5afe:	cd bf       	out	0x3d, r28	; 61
    5b00:	9f 83       	std	Y+7, r25	; 0x07
    5b02:	8e 83       	std	Y+6, r24	; 0x06
    5b04:	48 87       	std	Y+8, r20	; 0x08
    5b06:	59 87       	std	Y+9, r21	; 0x09
    5b08:	6a 87       	std	Y+10, r22	; 0x0a
    5b0a:	7b 87       	std	Y+11, r23	; 0x0b
    5b0c:	2c 87       	std	Y+12, r18	; 0x0c
    5b0e:	1e 87       	std	Y+14, r17	; 0x0e
    5b10:	0d 87       	std	Y+13, r16	; 0x0d
    5b12:	f8 8a       	std	Y+16, r15	; 0x10
    5b14:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    5b16:	81 e0       	ldi	r24, 0x01	; 1
    5b18:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    5b1a:	8e 81       	ldd	r24, Y+6	; 0x06
    5b1c:	9f 81       	ldd	r25, Y+7	; 0x07
    5b1e:	9d 83       	std	Y+5, r25	; 0x05
    5b20:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5b22:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    5b24:	8d 85       	ldd	r24, Y+13	; 0x0d
    5b26:	9e 85       	ldd	r25, Y+14	; 0x0e
    5b28:	00 97       	sbiw	r24, 0x00	; 0
    5b2a:	61 f0       	breq	.+24     	; 0x5b44 <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    5b2c:	ec 81       	ldd	r30, Y+4	; 0x04
    5b2e:	fd 81       	ldd	r31, Y+5	; 0x05
    5b30:	85 a5       	ldd	r24, Z+45	; 0x2d
    5b32:	96 a5       	ldd	r25, Z+46	; 0x2e
    5b34:	a7 a5       	ldd	r26, Z+47	; 0x2f
    5b36:	b0 a9       	ldd	r27, Z+48	; 0x30
    5b38:	ed 85       	ldd	r30, Y+13	; 0x0d
    5b3a:	fe 85       	ldd	r31, Y+14	; 0x0e
    5b3c:	80 83       	st	Z, r24
    5b3e:	91 83       	std	Z+1, r25	; 0x01
    5b40:	a2 83       	std	Z+2, r26	; 0x02
    5b42:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5b44:	ec 81       	ldd	r30, Y+4	; 0x04
    5b46:	fd 81       	ldd	r31, Y+5	; 0x05
    5b48:	81 a9       	ldd	r24, Z+49	; 0x31
    5b4a:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5b4c:	ec 81       	ldd	r30, Y+4	; 0x04
    5b4e:	fd 81       	ldd	r31, Y+5	; 0x05
    5b50:	82 e0       	ldi	r24, 0x02	; 2
    5b52:	81 ab       	std	Z+49, r24	; 0x31

			switch( eAction )
    5b54:	8c 85       	ldd	r24, Y+12	; 0x0c
    5b56:	28 2f       	mov	r18, r24
    5b58:	30 e0       	ldi	r19, 0x00	; 0
    5b5a:	3a 8b       	std	Y+18, r19	; 0x12
    5b5c:	29 8b       	std	Y+17, r18	; 0x11
    5b5e:	89 89       	ldd	r24, Y+17	; 0x11
    5b60:	9a 89       	ldd	r25, Y+18	; 0x12
    5b62:	82 30       	cpi	r24, 0x02	; 2
    5b64:	91 05       	cpc	r25, r1
    5b66:	59 f1       	breq	.+86     	; 0x5bbe <xTaskGenericNotifyFromISR+0xda>
    5b68:	29 89       	ldd	r18, Y+17	; 0x11
    5b6a:	3a 89       	ldd	r19, Y+18	; 0x12
    5b6c:	23 30       	cpi	r18, 0x03	; 3
    5b6e:	31 05       	cpc	r19, r1
    5b70:	34 f4       	brge	.+12     	; 0x5b7e <xTaskGenericNotifyFromISR+0x9a>
    5b72:	89 89       	ldd	r24, Y+17	; 0x11
    5b74:	9a 89       	ldd	r25, Y+18	; 0x12
    5b76:	81 30       	cpi	r24, 0x01	; 1
    5b78:	91 05       	cpc	r25, r1
    5b7a:	61 f0       	breq	.+24     	; 0x5b94 <xTaskGenericNotifyFromISR+0xb0>
    5b7c:	4a c0       	rjmp	.+148    	; 0x5c12 <xTaskGenericNotifyFromISR+0x12e>
    5b7e:	29 89       	ldd	r18, Y+17	; 0x11
    5b80:	3a 89       	ldd	r19, Y+18	; 0x12
    5b82:	23 30       	cpi	r18, 0x03	; 3
    5b84:	31 05       	cpc	r19, r1
    5b86:	59 f1       	breq	.+86     	; 0x5bde <xTaskGenericNotifyFromISR+0xfa>
    5b88:	89 89       	ldd	r24, Y+17	; 0x11
    5b8a:	9a 89       	ldd	r25, Y+18	; 0x12
    5b8c:	84 30       	cpi	r24, 0x04	; 4
    5b8e:	91 05       	cpc	r25, r1
    5b90:	89 f1       	breq	.+98     	; 0x5bf4 <xTaskGenericNotifyFromISR+0x110>
    5b92:	3f c0       	rjmp	.+126    	; 0x5c12 <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    5b94:	ec 81       	ldd	r30, Y+4	; 0x04
    5b96:	fd 81       	ldd	r31, Y+5	; 0x05
    5b98:	25 a5       	ldd	r18, Z+45	; 0x2d
    5b9a:	36 a5       	ldd	r19, Z+46	; 0x2e
    5b9c:	47 a5       	ldd	r20, Z+47	; 0x2f
    5b9e:	50 a9       	ldd	r21, Z+48	; 0x30
    5ba0:	88 85       	ldd	r24, Y+8	; 0x08
    5ba2:	99 85       	ldd	r25, Y+9	; 0x09
    5ba4:	aa 85       	ldd	r26, Y+10	; 0x0a
    5ba6:	bb 85       	ldd	r27, Y+11	; 0x0b
    5ba8:	82 2b       	or	r24, r18
    5baa:	93 2b       	or	r25, r19
    5bac:	a4 2b       	or	r26, r20
    5bae:	b5 2b       	or	r27, r21
    5bb0:	ec 81       	ldd	r30, Y+4	; 0x04
    5bb2:	fd 81       	ldd	r31, Y+5	; 0x05
    5bb4:	85 a7       	std	Z+45, r24	; 0x2d
    5bb6:	96 a7       	std	Z+46, r25	; 0x2e
    5bb8:	a7 a7       	std	Z+47, r26	; 0x2f
    5bba:	b0 ab       	std	Z+48, r27	; 0x30
    5bbc:	2a c0       	rjmp	.+84     	; 0x5c12 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    5bbe:	ec 81       	ldd	r30, Y+4	; 0x04
    5bc0:	fd 81       	ldd	r31, Y+5	; 0x05
    5bc2:	85 a5       	ldd	r24, Z+45	; 0x2d
    5bc4:	96 a5       	ldd	r25, Z+46	; 0x2e
    5bc6:	a7 a5       	ldd	r26, Z+47	; 0x2f
    5bc8:	b0 a9       	ldd	r27, Z+48	; 0x30
    5bca:	01 96       	adiw	r24, 0x01	; 1
    5bcc:	a1 1d       	adc	r26, r1
    5bce:	b1 1d       	adc	r27, r1
    5bd0:	ec 81       	ldd	r30, Y+4	; 0x04
    5bd2:	fd 81       	ldd	r31, Y+5	; 0x05
    5bd4:	85 a7       	std	Z+45, r24	; 0x2d
    5bd6:	96 a7       	std	Z+46, r25	; 0x2e
    5bd8:	a7 a7       	std	Z+47, r26	; 0x2f
    5bda:	b0 ab       	std	Z+48, r27	; 0x30
    5bdc:	1a c0       	rjmp	.+52     	; 0x5c12 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    5bde:	ec 81       	ldd	r30, Y+4	; 0x04
    5be0:	fd 81       	ldd	r31, Y+5	; 0x05
    5be2:	88 85       	ldd	r24, Y+8	; 0x08
    5be4:	99 85       	ldd	r25, Y+9	; 0x09
    5be6:	aa 85       	ldd	r26, Y+10	; 0x0a
    5be8:	bb 85       	ldd	r27, Y+11	; 0x0b
    5bea:	85 a7       	std	Z+45, r24	; 0x2d
    5bec:	96 a7       	std	Z+46, r25	; 0x2e
    5bee:	a7 a7       	std	Z+47, r26	; 0x2f
    5bf0:	b0 ab       	std	Z+48, r27	; 0x30
    5bf2:	0f c0       	rjmp	.+30     	; 0x5c12 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5bf4:	8b 81       	ldd	r24, Y+3	; 0x03
    5bf6:	82 30       	cpi	r24, 0x02	; 2
    5bf8:	59 f0       	breq	.+22     	; 0x5c10 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    5bfa:	ec 81       	ldd	r30, Y+4	; 0x04
    5bfc:	fd 81       	ldd	r31, Y+5	; 0x05
    5bfe:	88 85       	ldd	r24, Y+8	; 0x08
    5c00:	99 85       	ldd	r25, Y+9	; 0x09
    5c02:	aa 85       	ldd	r26, Y+10	; 0x0a
    5c04:	bb 85       	ldd	r27, Y+11	; 0x0b
    5c06:	85 a7       	std	Z+45, r24	; 0x2d
    5c08:	96 a7       	std	Z+46, r25	; 0x2e
    5c0a:	a7 a7       	std	Z+47, r26	; 0x2f
    5c0c:	b0 ab       	std	Z+48, r27	; 0x30
    5c0e:	01 c0       	rjmp	.+2      	; 0x5c12 <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    5c10:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5c12:	8b 81       	ldd	r24, Y+3	; 0x03
    5c14:	81 30       	cpi	r24, 0x01	; 1
    5c16:	09 f0       	breq	.+2      	; 0x5c1a <xTaskGenericNotifyFromISR+0x136>
    5c18:	4f c0       	rjmp	.+158    	; 0x5cb8 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5c1a:	80 91 de 06 	lds	r24, 0x06DE
    5c1e:	88 23       	and	r24, r24
    5c20:	61 f5       	brne	.+88     	; 0x5c7a <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5c22:	8c 81       	ldd	r24, Y+4	; 0x04
    5c24:	9d 81       	ldd	r25, Y+5	; 0x05
    5c26:	02 96       	adiw	r24, 0x02	; 2
    5c28:	0e 94 9a 10 	call	0x2134	; 0x2134 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5c2c:	ec 81       	ldd	r30, Y+4	; 0x04
    5c2e:	fd 81       	ldd	r31, Y+5	; 0x05
    5c30:	96 89       	ldd	r25, Z+22	; 0x16
    5c32:	80 91 d4 06 	lds	r24, 0x06D4
    5c36:	89 17       	cp	r24, r25
    5c38:	28 f4       	brcc	.+10     	; 0x5c44 <xTaskGenericNotifyFromISR+0x160>
    5c3a:	ec 81       	ldd	r30, Y+4	; 0x04
    5c3c:	fd 81       	ldd	r31, Y+5	; 0x05
    5c3e:	86 89       	ldd	r24, Z+22	; 0x16
    5c40:	80 93 d4 06 	sts	0x06D4, r24
    5c44:	ec 81       	ldd	r30, Y+4	; 0x04
    5c46:	fd 81       	ldd	r31, Y+5	; 0x05
    5c48:	86 89       	ldd	r24, Z+22	; 0x16
    5c4a:	28 2f       	mov	r18, r24
    5c4c:	30 e0       	ldi	r19, 0x00	; 0
    5c4e:	c9 01       	movw	r24, r18
    5c50:	88 0f       	add	r24, r24
    5c52:	99 1f       	adc	r25, r25
    5c54:	88 0f       	add	r24, r24
    5c56:	99 1f       	adc	r25, r25
    5c58:	88 0f       	add	r24, r24
    5c5a:	99 1f       	adc	r25, r25
    5c5c:	82 0f       	add	r24, r18
    5c5e:	93 1f       	adc	r25, r19
    5c60:	ac 01       	movw	r20, r24
    5c62:	41 52       	subi	r20, 0x21	; 33
    5c64:	59 4f       	sbci	r21, 0xF9	; 249
    5c66:	8c 81       	ldd	r24, Y+4	; 0x04
    5c68:	9d 81       	ldd	r25, Y+5	; 0x05
    5c6a:	9c 01       	movw	r18, r24
    5c6c:	2e 5f       	subi	r18, 0xFE	; 254
    5c6e:	3f 4f       	sbci	r19, 0xFF	; 255
    5c70:	ca 01       	movw	r24, r20
    5c72:	b9 01       	movw	r22, r18
    5c74:	0e 94 ea 0f 	call	0x1fd4	; 0x1fd4 <vListInsertEnd>
    5c78:	0a c0       	rjmp	.+20     	; 0x5c8e <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5c7a:	8c 81       	ldd	r24, Y+4	; 0x04
    5c7c:	9d 81       	ldd	r25, Y+5	; 0x05
    5c7e:	9c 01       	movw	r18, r24
    5c80:	24 5f       	subi	r18, 0xF4	; 244
    5c82:	3f 4f       	sbci	r19, 0xFF	; 255
    5c84:	82 e2       	ldi	r24, 0x22	; 34
    5c86:	97 e0       	ldi	r25, 0x07	; 7
    5c88:	b9 01       	movw	r22, r18
    5c8a:	0e 94 ea 0f 	call	0x1fd4	; 0x1fd4 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5c8e:	ec 81       	ldd	r30, Y+4	; 0x04
    5c90:	fd 81       	ldd	r31, Y+5	; 0x05
    5c92:	96 89       	ldd	r25, Z+22	; 0x16
    5c94:	e0 91 ce 06 	lds	r30, 0x06CE
    5c98:	f0 91 cf 06 	lds	r31, 0x06CF
    5c9c:	86 89       	ldd	r24, Z+22	; 0x16
    5c9e:	89 17       	cp	r24, r25
    5ca0:	58 f4       	brcc	.+22     	; 0x5cb8 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    5ca2:	8f 85       	ldd	r24, Y+15	; 0x0f
    5ca4:	98 89       	ldd	r25, Y+16	; 0x10
    5ca6:	00 97       	sbiw	r24, 0x00	; 0
    5ca8:	21 f0       	breq	.+8      	; 0x5cb2 <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    5caa:	ef 85       	ldd	r30, Y+15	; 0x0f
    5cac:	f8 89       	ldd	r31, Y+16	; 0x10
    5cae:	81 e0       	ldi	r24, 0x01	; 1
    5cb0:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    5cb2:	81 e0       	ldi	r24, 0x01	; 1
    5cb4:	80 93 d7 06 	sts	0x06D7, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    5cb8:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    5cba:	62 96       	adiw	r28, 0x12	; 18
    5cbc:	0f b6       	in	r0, 0x3f	; 63
    5cbe:	f8 94       	cli
    5cc0:	de bf       	out	0x3e, r29	; 62
    5cc2:	0f be       	out	0x3f, r0	; 63
    5cc4:	cd bf       	out	0x3d, r28	; 61
    5cc6:	cf 91       	pop	r28
    5cc8:	df 91       	pop	r29
    5cca:	1f 91       	pop	r17
    5ccc:	0f 91       	pop	r16
    5cce:	ff 90       	pop	r15
    5cd0:	ef 90       	pop	r14
    5cd2:	08 95       	ret

00005cd4 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    5cd4:	df 93       	push	r29
    5cd6:	cf 93       	push	r28
    5cd8:	cd b7       	in	r28, 0x3d	; 61
    5cda:	de b7       	in	r29, 0x3e	; 62
    5cdc:	28 97       	sbiw	r28, 0x08	; 8
    5cde:	0f b6       	in	r0, 0x3f	; 63
    5ce0:	f8 94       	cli
    5ce2:	de bf       	out	0x3e, r29	; 62
    5ce4:	0f be       	out	0x3f, r0	; 63
    5ce6:	cd bf       	out	0x3d, r28	; 61
    5ce8:	9e 83       	std	Y+6, r25	; 0x06
    5cea:	8d 83       	std	Y+5, r24	; 0x05
    5cec:	78 87       	std	Y+8, r23	; 0x08
    5cee:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    5cf0:	8d 81       	ldd	r24, Y+5	; 0x05
    5cf2:	9e 81       	ldd	r25, Y+6	; 0x06
    5cf4:	9c 83       	std	Y+4, r25	; 0x04
    5cf6:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5cf8:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5cfa:	eb 81       	ldd	r30, Y+3	; 0x03
    5cfc:	fc 81       	ldd	r31, Y+4	; 0x04
    5cfe:	81 a9       	ldd	r24, Z+49	; 0x31
    5d00:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5d02:	eb 81       	ldd	r30, Y+3	; 0x03
    5d04:	fc 81       	ldd	r31, Y+4	; 0x04
    5d06:	82 e0       	ldi	r24, 0x02	; 2
    5d08:	81 ab       	std	Z+49, r24	; 0x31

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    5d0a:	eb 81       	ldd	r30, Y+3	; 0x03
    5d0c:	fc 81       	ldd	r31, Y+4	; 0x04
    5d0e:	85 a5       	ldd	r24, Z+45	; 0x2d
    5d10:	96 a5       	ldd	r25, Z+46	; 0x2e
    5d12:	a7 a5       	ldd	r26, Z+47	; 0x2f
    5d14:	b0 a9       	ldd	r27, Z+48	; 0x30
    5d16:	01 96       	adiw	r24, 0x01	; 1
    5d18:	a1 1d       	adc	r26, r1
    5d1a:	b1 1d       	adc	r27, r1
    5d1c:	eb 81       	ldd	r30, Y+3	; 0x03
    5d1e:	fc 81       	ldd	r31, Y+4	; 0x04
    5d20:	85 a7       	std	Z+45, r24	; 0x2d
    5d22:	96 a7       	std	Z+46, r25	; 0x2e
    5d24:	a7 a7       	std	Z+47, r26	; 0x2f
    5d26:	b0 ab       	std	Z+48, r27	; 0x30

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5d28:	8a 81       	ldd	r24, Y+2	; 0x02
    5d2a:	81 30       	cpi	r24, 0x01	; 1
    5d2c:	09 f0       	breq	.+2      	; 0x5d30 <vTaskNotifyGiveFromISR+0x5c>
    5d2e:	4f c0       	rjmp	.+158    	; 0x5dce <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5d30:	80 91 de 06 	lds	r24, 0x06DE
    5d34:	88 23       	and	r24, r24
    5d36:	61 f5       	brne	.+88     	; 0x5d90 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5d38:	8b 81       	ldd	r24, Y+3	; 0x03
    5d3a:	9c 81       	ldd	r25, Y+4	; 0x04
    5d3c:	02 96       	adiw	r24, 0x02	; 2
    5d3e:	0e 94 9a 10 	call	0x2134	; 0x2134 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5d42:	eb 81       	ldd	r30, Y+3	; 0x03
    5d44:	fc 81       	ldd	r31, Y+4	; 0x04
    5d46:	96 89       	ldd	r25, Z+22	; 0x16
    5d48:	80 91 d4 06 	lds	r24, 0x06D4
    5d4c:	89 17       	cp	r24, r25
    5d4e:	28 f4       	brcc	.+10     	; 0x5d5a <vTaskNotifyGiveFromISR+0x86>
    5d50:	eb 81       	ldd	r30, Y+3	; 0x03
    5d52:	fc 81       	ldd	r31, Y+4	; 0x04
    5d54:	86 89       	ldd	r24, Z+22	; 0x16
    5d56:	80 93 d4 06 	sts	0x06D4, r24
    5d5a:	eb 81       	ldd	r30, Y+3	; 0x03
    5d5c:	fc 81       	ldd	r31, Y+4	; 0x04
    5d5e:	86 89       	ldd	r24, Z+22	; 0x16
    5d60:	28 2f       	mov	r18, r24
    5d62:	30 e0       	ldi	r19, 0x00	; 0
    5d64:	c9 01       	movw	r24, r18
    5d66:	88 0f       	add	r24, r24
    5d68:	99 1f       	adc	r25, r25
    5d6a:	88 0f       	add	r24, r24
    5d6c:	99 1f       	adc	r25, r25
    5d6e:	88 0f       	add	r24, r24
    5d70:	99 1f       	adc	r25, r25
    5d72:	82 0f       	add	r24, r18
    5d74:	93 1f       	adc	r25, r19
    5d76:	ac 01       	movw	r20, r24
    5d78:	41 52       	subi	r20, 0x21	; 33
    5d7a:	59 4f       	sbci	r21, 0xF9	; 249
    5d7c:	8b 81       	ldd	r24, Y+3	; 0x03
    5d7e:	9c 81       	ldd	r25, Y+4	; 0x04
    5d80:	9c 01       	movw	r18, r24
    5d82:	2e 5f       	subi	r18, 0xFE	; 254
    5d84:	3f 4f       	sbci	r19, 0xFF	; 255
    5d86:	ca 01       	movw	r24, r20
    5d88:	b9 01       	movw	r22, r18
    5d8a:	0e 94 ea 0f 	call	0x1fd4	; 0x1fd4 <vListInsertEnd>
    5d8e:	0a c0       	rjmp	.+20     	; 0x5da4 <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5d90:	8b 81       	ldd	r24, Y+3	; 0x03
    5d92:	9c 81       	ldd	r25, Y+4	; 0x04
    5d94:	9c 01       	movw	r18, r24
    5d96:	24 5f       	subi	r18, 0xF4	; 244
    5d98:	3f 4f       	sbci	r19, 0xFF	; 255
    5d9a:	82 e2       	ldi	r24, 0x22	; 34
    5d9c:	97 e0       	ldi	r25, 0x07	; 7
    5d9e:	b9 01       	movw	r22, r18
    5da0:	0e 94 ea 0f 	call	0x1fd4	; 0x1fd4 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5da4:	eb 81       	ldd	r30, Y+3	; 0x03
    5da6:	fc 81       	ldd	r31, Y+4	; 0x04
    5da8:	96 89       	ldd	r25, Z+22	; 0x16
    5daa:	e0 91 ce 06 	lds	r30, 0x06CE
    5dae:	f0 91 cf 06 	lds	r31, 0x06CF
    5db2:	86 89       	ldd	r24, Z+22	; 0x16
    5db4:	89 17       	cp	r24, r25
    5db6:	58 f4       	brcc	.+22     	; 0x5dce <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    5db8:	8f 81       	ldd	r24, Y+7	; 0x07
    5dba:	98 85       	ldd	r25, Y+8	; 0x08
    5dbc:	00 97       	sbiw	r24, 0x00	; 0
    5dbe:	21 f0       	breq	.+8      	; 0x5dc8 <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    5dc0:	ef 81       	ldd	r30, Y+7	; 0x07
    5dc2:	f8 85       	ldd	r31, Y+8	; 0x08
    5dc4:	81 e0       	ldi	r24, 0x01	; 1
    5dc6:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    5dc8:	81 e0       	ldi	r24, 0x01	; 1
    5dca:	80 93 d7 06 	sts	0x06D7, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    5dce:	28 96       	adiw	r28, 0x08	; 8
    5dd0:	0f b6       	in	r0, 0x3f	; 63
    5dd2:	f8 94       	cli
    5dd4:	de bf       	out	0x3e, r29	; 62
    5dd6:	0f be       	out	0x3f, r0	; 63
    5dd8:	cd bf       	out	0x3d, r28	; 61
    5dda:	cf 91       	pop	r28
    5ddc:	df 91       	pop	r29
    5dde:	08 95       	ret

00005de0 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    5de0:	df 93       	push	r29
    5de2:	cf 93       	push	r28
    5de4:	cd b7       	in	r28, 0x3d	; 61
    5de6:	de b7       	in	r29, 0x3e	; 62
    5de8:	27 97       	sbiw	r28, 0x07	; 7
    5dea:	0f b6       	in	r0, 0x3f	; 63
    5dec:	f8 94       	cli
    5dee:	de bf       	out	0x3e, r29	; 62
    5df0:	0f be       	out	0x3f, r0	; 63
    5df2:	cd bf       	out	0x3d, r28	; 61
    5df4:	9d 83       	std	Y+5, r25	; 0x05
    5df6:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    5df8:	8c 81       	ldd	r24, Y+4	; 0x04
    5dfa:	9d 81       	ldd	r25, Y+5	; 0x05
    5dfc:	00 97       	sbiw	r24, 0x00	; 0
    5dfe:	39 f4       	brne	.+14     	; 0x5e0e <xTaskNotifyStateClear+0x2e>
    5e00:	80 91 ce 06 	lds	r24, 0x06CE
    5e04:	90 91 cf 06 	lds	r25, 0x06CF
    5e08:	9f 83       	std	Y+7, r25	; 0x07
    5e0a:	8e 83       	std	Y+6, r24	; 0x06
    5e0c:	04 c0       	rjmp	.+8      	; 0x5e16 <xTaskNotifyStateClear+0x36>
    5e0e:	8c 81       	ldd	r24, Y+4	; 0x04
    5e10:	9d 81       	ldd	r25, Y+5	; 0x05
    5e12:	9f 83       	std	Y+7, r25	; 0x07
    5e14:	8e 83       	std	Y+6, r24	; 0x06
    5e16:	8e 81       	ldd	r24, Y+6	; 0x06
    5e18:	9f 81       	ldd	r25, Y+7	; 0x07
    5e1a:	9b 83       	std	Y+3, r25	; 0x03
    5e1c:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    5e1e:	0f b6       	in	r0, 0x3f	; 63
    5e20:	f8 94       	cli
    5e22:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    5e24:	ea 81       	ldd	r30, Y+2	; 0x02
    5e26:	fb 81       	ldd	r31, Y+3	; 0x03
    5e28:	81 a9       	ldd	r24, Z+49	; 0x31
    5e2a:	82 30       	cpi	r24, 0x02	; 2
    5e2c:	31 f4       	brne	.+12     	; 0x5e3a <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5e2e:	ea 81       	ldd	r30, Y+2	; 0x02
    5e30:	fb 81       	ldd	r31, Y+3	; 0x03
    5e32:	11 aa       	std	Z+49, r1	; 0x31
				xReturn = pdPASS;
    5e34:	81 e0       	ldi	r24, 0x01	; 1
    5e36:	89 83       	std	Y+1, r24	; 0x01
    5e38:	01 c0       	rjmp	.+2      	; 0x5e3c <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    5e3a:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    5e3c:	0f 90       	pop	r0
    5e3e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5e40:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5e42:	27 96       	adiw	r28, 0x07	; 7
    5e44:	0f b6       	in	r0, 0x3f	; 63
    5e46:	f8 94       	cli
    5e48:	de bf       	out	0x3e, r29	; 62
    5e4a:	0f be       	out	0x3f, r0	; 63
    5e4c:	cd bf       	out	0x3d, r28	; 61
    5e4e:	cf 91       	pop	r28
    5e50:	df 91       	pop	r29
    5e52:	08 95       	ret

00005e54 <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    5e54:	df 93       	push	r29
    5e56:	cf 93       	push	r28
    5e58:	cd b7       	in	r28, 0x3d	; 61
    5e5a:	de b7       	in	r29, 0x3e	; 62
    5e5c:	27 97       	sbiw	r28, 0x07	; 7
    5e5e:	0f b6       	in	r0, 0x3f	; 63
    5e60:	f8 94       	cli
    5e62:	de bf       	out	0x3e, r29	; 62
    5e64:	0f be       	out	0x3f, r0	; 63
    5e66:	cd bf       	out	0x3d, r28	; 61
    5e68:	9e 83       	std	Y+6, r25	; 0x06
    5e6a:	8d 83       	std	Y+5, r24	; 0x05
    5e6c:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    5e6e:	80 91 d2 06 	lds	r24, 0x06D2
    5e72:	90 91 d3 06 	lds	r25, 0x06D3
    5e76:	9a 83       	std	Y+2, r25	; 0x02
    5e78:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5e7a:	80 91 ce 06 	lds	r24, 0x06CE
    5e7e:	90 91 cf 06 	lds	r25, 0x06CF
    5e82:	02 96       	adiw	r24, 0x02	; 2
    5e84:	0e 94 9a 10 	call	0x2134	; 0x2134 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    5e88:	8d 81       	ldd	r24, Y+5	; 0x05
    5e8a:	9e 81       	ldd	r25, Y+6	; 0x06
    5e8c:	2f ef       	ldi	r18, 0xFF	; 255
    5e8e:	8f 3f       	cpi	r24, 0xFF	; 255
    5e90:	92 07       	cpc	r25, r18
    5e92:	81 f4       	brne	.+32     	; 0x5eb4 <prvAddCurrentTaskToDelayedList+0x60>
    5e94:	8f 81       	ldd	r24, Y+7	; 0x07
    5e96:	88 23       	and	r24, r24
    5e98:	69 f0       	breq	.+26     	; 0x5eb4 <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5e9a:	80 91 ce 06 	lds	r24, 0x06CE
    5e9e:	90 91 cf 06 	lds	r25, 0x06CF
    5ea2:	9c 01       	movw	r18, r24
    5ea4:	2e 5f       	subi	r18, 0xFE	; 254
    5ea6:	3f 4f       	sbci	r19, 0xFF	; 255
    5ea8:	84 e3       	ldi	r24, 0x34	; 52
    5eaa:	97 e0       	ldi	r25, 0x07	; 7
    5eac:	b9 01       	movw	r22, r18
    5eae:	0e 94 ea 0f 	call	0x1fd4	; 0x1fd4 <vListInsertEnd>
    5eb2:	43 c0       	rjmp	.+134    	; 0x5f3a <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    5eb4:	29 81       	ldd	r18, Y+1	; 0x01
    5eb6:	3a 81       	ldd	r19, Y+2	; 0x02
    5eb8:	8d 81       	ldd	r24, Y+5	; 0x05
    5eba:	9e 81       	ldd	r25, Y+6	; 0x06
    5ebc:	82 0f       	add	r24, r18
    5ebe:	93 1f       	adc	r25, r19
    5ec0:	9c 83       	std	Y+4, r25	; 0x04
    5ec2:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    5ec4:	e0 91 ce 06 	lds	r30, 0x06CE
    5ec8:	f0 91 cf 06 	lds	r31, 0x06CF
    5ecc:	8b 81       	ldd	r24, Y+3	; 0x03
    5ece:	9c 81       	ldd	r25, Y+4	; 0x04
    5ed0:	93 83       	std	Z+3, r25	; 0x03
    5ed2:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    5ed4:	2b 81       	ldd	r18, Y+3	; 0x03
    5ed6:	3c 81       	ldd	r19, Y+4	; 0x04
    5ed8:	89 81       	ldd	r24, Y+1	; 0x01
    5eda:	9a 81       	ldd	r25, Y+2	; 0x02
    5edc:	28 17       	cp	r18, r24
    5ede:	39 07       	cpc	r19, r25
    5ee0:	70 f4       	brcc	.+28     	; 0x5efe <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5ee2:	80 91 20 07 	lds	r24, 0x0720
    5ee6:	90 91 21 07 	lds	r25, 0x0721
    5eea:	20 91 ce 06 	lds	r18, 0x06CE
    5eee:	30 91 cf 06 	lds	r19, 0x06CF
    5ef2:	2e 5f       	subi	r18, 0xFE	; 254
    5ef4:	3f 4f       	sbci	r19, 0xFF	; 255
    5ef6:	b9 01       	movw	r22, r18
    5ef8:	0e 94 2e 10 	call	0x205c	; 0x205c <vListInsert>
    5efc:	1e c0       	rjmp	.+60     	; 0x5f3a <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5efe:	40 91 1e 07 	lds	r20, 0x071E
    5f02:	50 91 1f 07 	lds	r21, 0x071F
    5f06:	80 91 ce 06 	lds	r24, 0x06CE
    5f0a:	90 91 cf 06 	lds	r25, 0x06CF
    5f0e:	9c 01       	movw	r18, r24
    5f10:	2e 5f       	subi	r18, 0xFE	; 254
    5f12:	3f 4f       	sbci	r19, 0xFF	; 255
    5f14:	ca 01       	movw	r24, r20
    5f16:	b9 01       	movw	r22, r18
    5f18:	0e 94 2e 10 	call	0x205c	; 0x205c <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    5f1c:	20 91 da 06 	lds	r18, 0x06DA
    5f20:	30 91 db 06 	lds	r19, 0x06DB
    5f24:	8b 81       	ldd	r24, Y+3	; 0x03
    5f26:	9c 81       	ldd	r25, Y+4	; 0x04
    5f28:	82 17       	cp	r24, r18
    5f2a:	93 07       	cpc	r25, r19
    5f2c:	30 f4       	brcc	.+12     	; 0x5f3a <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    5f2e:	8b 81       	ldd	r24, Y+3	; 0x03
    5f30:	9c 81       	ldd	r25, Y+4	; 0x04
    5f32:	90 93 db 06 	sts	0x06DB, r25
    5f36:	80 93 da 06 	sts	0x06DA, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5f3a:	27 96       	adiw	r28, 0x07	; 7
    5f3c:	0f b6       	in	r0, 0x3f	; 63
    5f3e:	f8 94       	cli
    5f40:	de bf       	out	0x3e, r29	; 62
    5f42:	0f be       	out	0x3f, r0	; 63
    5f44:	cd bf       	out	0x3d, r28	; 61
    5f46:	cf 91       	pop	r28
    5f48:	df 91       	pop	r29
    5f4a:	08 95       	ret

00005f4c <memcpy>:
    5f4c:	fb 01       	movw	r30, r22
    5f4e:	dc 01       	movw	r26, r24
    5f50:	02 c0       	rjmp	.+4      	; 0x5f56 <memcpy+0xa>
    5f52:	01 90       	ld	r0, Z+
    5f54:	0d 92       	st	X+, r0
    5f56:	41 50       	subi	r20, 0x01	; 1
    5f58:	50 40       	sbci	r21, 0x00	; 0
    5f5a:	d8 f7       	brcc	.-10     	; 0x5f52 <memcpy+0x6>
    5f5c:	08 95       	ret

00005f5e <memset>:
    5f5e:	dc 01       	movw	r26, r24
    5f60:	01 c0       	rjmp	.+2      	; 0x5f64 <memset+0x6>
    5f62:	6d 93       	st	X+, r22
    5f64:	41 50       	subi	r20, 0x01	; 1
    5f66:	50 40       	sbci	r21, 0x00	; 0
    5f68:	e0 f7       	brcc	.-8      	; 0x5f62 <memset+0x4>
    5f6a:	08 95       	ret

00005f6c <itoa>:
    5f6c:	fb 01       	movw	r30, r22
    5f6e:	9f 01       	movw	r18, r30
    5f70:	e8 94       	clt
    5f72:	42 30       	cpi	r20, 0x02	; 2
    5f74:	c4 f0       	brlt	.+48     	; 0x5fa6 <itoa+0x3a>
    5f76:	45 32       	cpi	r20, 0x25	; 37
    5f78:	b4 f4       	brge	.+44     	; 0x5fa6 <itoa+0x3a>
    5f7a:	4a 30       	cpi	r20, 0x0A	; 10
    5f7c:	29 f4       	brne	.+10     	; 0x5f88 <itoa+0x1c>
    5f7e:	97 fb       	bst	r25, 7
    5f80:	1e f4       	brtc	.+6      	; 0x5f88 <itoa+0x1c>
    5f82:	90 95       	com	r25
    5f84:	81 95       	neg	r24
    5f86:	9f 4f       	sbci	r25, 0xFF	; 255
    5f88:	64 2f       	mov	r22, r20
    5f8a:	77 27       	eor	r23, r23
    5f8c:	0e 94 e7 2f 	call	0x5fce	; 0x5fce <__udivmodhi4>
    5f90:	80 5d       	subi	r24, 0xD0	; 208
    5f92:	8a 33       	cpi	r24, 0x3A	; 58
    5f94:	0c f0       	brlt	.+2      	; 0x5f98 <itoa+0x2c>
    5f96:	89 5d       	subi	r24, 0xD9	; 217
    5f98:	81 93       	st	Z+, r24
    5f9a:	cb 01       	movw	r24, r22
    5f9c:	00 97       	sbiw	r24, 0x00	; 0
    5f9e:	a1 f7       	brne	.-24     	; 0x5f88 <itoa+0x1c>
    5fa0:	16 f4       	brtc	.+4      	; 0x5fa6 <itoa+0x3a>
    5fa2:	5d e2       	ldi	r21, 0x2D	; 45
    5fa4:	51 93       	st	Z+, r21
    5fa6:	10 82       	st	Z, r1
    5fa8:	c9 01       	movw	r24, r18
    5faa:	0c 94 d7 2f 	jmp	0x5fae	; 0x5fae <strrev>

00005fae <strrev>:
    5fae:	dc 01       	movw	r26, r24
    5fb0:	fc 01       	movw	r30, r24
    5fb2:	67 2f       	mov	r22, r23
    5fb4:	71 91       	ld	r23, Z+
    5fb6:	77 23       	and	r23, r23
    5fb8:	e1 f7       	brne	.-8      	; 0x5fb2 <strrev+0x4>
    5fba:	32 97       	sbiw	r30, 0x02	; 2
    5fbc:	04 c0       	rjmp	.+8      	; 0x5fc6 <strrev+0x18>
    5fbe:	7c 91       	ld	r23, X
    5fc0:	6d 93       	st	X+, r22
    5fc2:	70 83       	st	Z, r23
    5fc4:	62 91       	ld	r22, -Z
    5fc6:	ae 17       	cp	r26, r30
    5fc8:	bf 07       	cpc	r27, r31
    5fca:	c8 f3       	brcs	.-14     	; 0x5fbe <strrev+0x10>
    5fcc:	08 95       	ret

00005fce <__udivmodhi4>:
    5fce:	aa 1b       	sub	r26, r26
    5fd0:	bb 1b       	sub	r27, r27
    5fd2:	51 e1       	ldi	r21, 0x11	; 17
    5fd4:	07 c0       	rjmp	.+14     	; 0x5fe4 <__udivmodhi4_ep>

00005fd6 <__udivmodhi4_loop>:
    5fd6:	aa 1f       	adc	r26, r26
    5fd8:	bb 1f       	adc	r27, r27
    5fda:	a6 17       	cp	r26, r22
    5fdc:	b7 07       	cpc	r27, r23
    5fde:	10 f0       	brcs	.+4      	; 0x5fe4 <__udivmodhi4_ep>
    5fe0:	a6 1b       	sub	r26, r22
    5fe2:	b7 0b       	sbc	r27, r23

00005fe4 <__udivmodhi4_ep>:
    5fe4:	88 1f       	adc	r24, r24
    5fe6:	99 1f       	adc	r25, r25
    5fe8:	5a 95       	dec	r21
    5fea:	a9 f7       	brne	.-22     	; 0x5fd6 <__udivmodhi4_loop>
    5fec:	80 95       	com	r24
    5fee:	90 95       	com	r25
    5ff0:	bc 01       	movw	r22, r24
    5ff2:	cd 01       	movw	r24, r26
    5ff4:	08 95       	ret

00005ff6 <_exit>:
    5ff6:	f8 94       	cli

00005ff8 <__stop_program>:
    5ff8:	ff cf       	rjmp	.-2      	; 0x5ff8 <__stop_program>
